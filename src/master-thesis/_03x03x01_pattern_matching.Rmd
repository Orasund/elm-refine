
We will need the semantics of $\mf{<type>}$, namely a function that maps $\text{values}_\Gamma(\mf{<type>})$ to $\mathcal{T}$.

```{definition,name="Semantics of <type>"}
\begin{letIn}
$n\in\mathbb{N}$. Let $t,t_1,t_2:\mf{<type>}$ and $c:\mf{<upper-var>}$.
Let $t_i:\mf{<type>}$ for all $i\in\mathbb{N}_3^n$ and $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $C$ be a symbol. Let $\Gamma$ be a type context. Let $\mathit{Nat}=\mu C.1 \ | \ \mathit{Succ} \ C$.
\end{letIn}
We define

$$
\begin{aligned}
  \syntax{.}_\Gamma: \ &\text{values}_\Gamma(\mf{<type>})\to\mathcal{T}\\
  \syntax{Bool}_\Gamma =& \mu\_.\mathit{True}\ | \ \mathit{False}\\
  \syntax{Int}_\Gamma =& \mu\_.0 \ | \ \mathit{Pos} \ \mathit{Nat} | \mathit{Neg} \ \mathit{Nat}\\
  \syntax{List}_\Gamma =& \forall a.\mu C.[ \ ] \ | \ \mathit{Cons} \ a \ C\\
  \syntax{"(" $t_1$ , $t_2$ ")"}_\Gamma =& \{1:\syntax{$t_1$}_\Gamma, 2: \syntax{$t_2$}_\Gamma\}\\
  \syntax{"\{\}"}_\Gamma =& \mathit{\{\}}\\
  \syntax{"\{" $v_1$ ":" $t_1$ "," $\dots$ "," $v_n$ ":" $t_n$ "\}"}_\Gamma =& \{v_1:\syntax{$t_1$}_\Gamma , \dots , v_n:\syntax{$t_n$}_\Gamma\}\\
  \syntax{$t_1$ "->" $t_2$}_\Gamma =& \syntax{$t_1$}_\Gamma \to \syntax{$t_2$}_\Gamma\\
  \syntax{$c \ t_1 \dots t_n$} =& [\syntax{$c$}]_\Gamma(t_1,\dots,t_n)
\end{aligned}
$$
```

Additionally, we will need to introduce a pattern matching function:

$$
\text{match}_\Theta:\text{value}(\mf{<type>})\times\text{value}(\mf{<exp>})\to\{\mathit{True},\mathit{False}\}
$$
for a given substitution $\Theta$. The function will be defined afterwards. For now its definition will be arbitrary.

We can already state two universal inference rules for any Hindley-Milner type system.

```{definition,name="Instantiation, Generalization"}
\begin{letIn}
$T',T\in\mathcal{T}$ and $e\in\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})$. Let $a$ be a type variable. Let $\Delta$ be a variable context. Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})\to A$
\end{letIn}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Delta\vdash\syntax{e}:_\Gamma T'
}
{\Delta\vdash \syntax{e}:_\Gamma T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Delta\quad
\Delta\vdash \syntax{e}:_\Gamma T
}
{\Delta\vdash \syntax{e}:_\Gamma \mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be inferred, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be inferred, then the same holds for a poly type, binding the free variable.

### Inference Rules for Programs

The inference rules for programs will done statement for statement. Note that every statement has one rule that can be applied, statement with optional parameters have a rule with and one without the optional parameter.

```{definition,name="Inference rules for programs"}
\begin{letIn}
$n,m\in\mathbb{N}$. Let $k_i\in\mathbb{N}$ for all $i\in\mathbb{N}_1^m$.
Let $T,T_1,T_2,T_3\in\mathcal{T}$ Let $v:\mf{<lower-var>},e:\mf{<exp>},t:\mf{<type>}$. Let $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $s:\mf{<list-statement>}$. Let $c:\mf{<lower-var>}$ and $c_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^m$. Let $t_{i,j}:\mf{<type>}$ for all $i\in\mathbb{N}_1^m$ and $j\in\mathbb{N}_1^{k_i}$. Let $mt:\mf{<maybe-main-sign>}$ and $me:\mf{<exp>}$.
Let $\Gamma$ be a type context and $\Delta$ a variable context.
Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}
The inference rules for programs are defined in table \ref{tab:inf_state}.
```

\begin{table}
\caption{Inference rules for programs}
\label{tab:inf_state}
\begin{center}
\begin{tabular}{c l}
\hline
& \\
\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{$v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\quad
\syntax{$t$}_\Gamma = T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2\quad
\end{gathered}
}
{\Delta\vdash\syntax{$v$ ":" $t$ ";" $v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant2}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\\
\syntax{t}_\Gamma=T_1\quad
T_2 \text{ is a mono type}\\
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\syntax{"type alias" $c$ $v_1 \dots v_n$ "=" $t$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_3}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\mu C.c_1 \ \syntax{$t_{1,1}$}_\Gamma \ \dots \ \syntax{$t_{1,k_1}$}_\Gamma \ | \ \dots \ | \ c_m \ \syntax{$t_{m,1}$}_\Gamma \ \dots \ \syntax{$t_{m,k_m}$}_\Gamma=T_2\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\Bigg\llbracket
\begin{aligned}
&\mf{"type"} \ c \ v_1 \dots v_n \mf{"="}\\
&c_1 \ t_{1,1} \dots t_{1,k_1} \ | \ \dots | \ c_m \ t_{m,1} \dots t_{m,k_m}\\ &\mf{";"} s \ mt \mf{"main = "} me
\end{aligned}\Bigg\rrbracket:_\Gamma T_3
}
{TCustomType}

& \\

\logicRule
{\Delta\vdash\syntax{$e$}:_\Gamma T}
{\Delta\vdash\syntax{"main = " $e$}:_\Gamma T}
{TMain}

\logicRule
{
\Delta\vdash\syntax{$e$}:_\Gamma T\quad
\syntax{$t$}_\Gamma=T
}
{\Delta\vdash\syntax{"main :" $t$ "; main = " $e$}:_\Gamma T}
{TMain2}

\hline
\end{tabular}
\end{center}
\end{table}

\begin{description}
\item[TConstant,TConstant2] Check if $v$ is still free then add $(v,T_1)$ to the variable context and evaluate the next statement.
\item[TAlias] Check if $c$ is still free. $\{v_1,\dots,v_2\}$ needs to be the set of all free variables in $T_2$. If all checks are valid we add $(v,T_1)$ to the type context and evaluate the next statement.
\item[TCustomType] Similar to $[\mathit{TAlias}]$ we add $(v,T_1)$ to the type context with the only difference that we explicitly define $T_1$ as an algebraic type.
\item[TMain,TMain2] Evaluate $e$.
\end{description}

### Inference Rules for Expressions

In the inference rules $[\mathit{TConstant}],[\mathit{TConstant2}]$ and $[\mathit{Main}],[\mathit{Main2}]$ we used a judgment for expressions. We will now give the corresponding inference rules. As before, each expression has one or two rules depending on optional parameters.

```{definition,name="Inference rules for expressions"}
\begin{letIn}
$n\in\mathbb{N}$. Let $T,T_0,T_1,T_2,T_3\in\mathcal{T}$.
Let $v,v_0,v_1,v_2,v_3:\mf{<lower-var>}$.
Let $e,e_0,e_1,e_2,e_3:\mf{<exp>}$.
Let $T_i:\mathcal{T}$ for all $i\in\mathbb{N}_4^n$.
Let $v_i:\mf{<lower-var>}$ for $i\in\mathbb{N}_4^n$.
Let $a_i:\mathcal{V}$ for all $i\in\mathbb{N}_4^n$.
Let $e_i:\mf{<exp>}$ for all $i\in\mathbb{N}_4^n$.
Let $p:\mf{<pattern>}$,
$\mathit{le}:\mf{<list.exp>}$,
$\mathit{lc}:\mf{<list-case>}$,
$\mathit{lef}:\mf{<list-exp-field>}$,
$c:\mf{<upper-var>}$ and
$t:\mf{<type>}.$
Let $\Gamma$ be a type context and $\Delta$ a variable context. Let $A$ be a set and
$\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}

The inference rules for expressions can be found in table \ref{tab:inf_exp}.
```


\topcaption{Inference rules for expressions}\label{tab:inf_exp}
\tablefirsthead{\hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}

&\\
\logicRule
{(v,T)\in\Delta
}
{\Delta\vdash\syntax{$v$}:_\Gamma T}
{TVariable}

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Delta\cup\Theta\vdash\syntax{$e$}:_\Gamma T_2
}
{\Delta\vdash\syntax{"\textbackslash" $p$ "->" $e$}:_\Gamma T_1\to T_2}
{TLambda}

\logicRule
{\syntax{$e_1$}_\Gamma:T_1\quad
\syntax{$e_2$}_\Gamma:T_2
}
{\Delta\vdash\syntax{"(" $e_1$ "," $e_2$ ")"}:_\Gamma\{1:T_1, 2:T_2\}}
{TTuple}

\logicRule
{}
{\Delta\vdash\syntax{"[]"}:_\Gamma\forall a.\mathit{List} \ a}
{TEmptyList}

\logicRule
{
\Delta\vdash\syntax{$e$}:_\Gamma T\quad
\Delta\vdash\syntax{"[" $\mathit{le}$ "]"}:_\Gamma \mathit{List} \ T
}
{\Delta\vdash\syntax{"[" $e$ "," $\mathit{le}$ "]"}:_\Gamma \mathit{List} \ T}
{TList}

\logicRule
{e:\mf{<int>}}
{\Delta\vdash\syntax{$e$}:_\Gamma \mathit{Int}}
{TInt}

\logicRule
{e:\mf{<bool>}}
{\Delta\vdash\syntax{$e$}:_\Gamma \mathit{Bool}}
{TBool}

\logicRule
{\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\to T_2\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_1
}
{\Delta\vdash\syntax{$e_1$ $e_2$}:_\Gamma T_2}
{TCall}

\logicRule
{\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Delta\cup\Theta\vdash\syntax{$e_2$}:_\Gamma T_2
}
{\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ "]"}:_\Gamma T_2}
{TSingleCaseOf}

\logicRule
{\begin{gathered}
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Delta\cup\Theta\vdash\syntax{$e_2$}:_\Gamma T_2\\
\Delta\vdash\syntax{"case" $e_1$ "of" "[" $\mathit{lc}$ "]"}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ ";" $\mathit{lc}$ "]"}:_\Gamma T_2}
{TCaseOf}

\logicRule
{
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:_\Gamma T_2
}
{
\Delta\vdash\syntax{"let" $v$ "=" $e_1$ "in" $e_2$}:_\Gamma T_2
}
{TLetIn}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\syntax{$t$}_\Gamma = T_1\quad
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{"let" $v$ ":" $t$ ";" $v$ "=" $e_1$ "in" $e_2$}:_\Gamma T_2
}
{TLetIn2}

\logicRule
{(v_1,\{v_2:T,\dots\})\in\Delta
}
{\Delta\vdash\syntax{$v_1$ "." $v_2$}:_\Gamma T}
{TGetter}

\logicRule
{\begin{gathered}
\Delta\vdash\syntax{$e$}:_\Gamma T_2\\
T_1=\{v_2:T_2,\dots\}\quad
(v_1,T_1)\in\Delta
\end{gathered}
}
{\Delta\vdash\syntax{"\{" $v1$ "|" $v2$ "=" $e$ "\}"}:_\Gamma T_1}
{TSingleSetter}

\logicRule
{\begin{gathered}
\mathit{lef}:\mf{<list-exp-field>}\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_2\\
T_1=\{v_2:T_2,..\}\quad
(v_1,T_1)\in\Delta\quad
\Delta\vdash\syntax{"\{" $v$ "|" $\mathit{lef}$ "\}"}:_\Gamma T_1
\end{gathered}
}
{\Delta\vdash\syntax{"\{" $v$ "|" $v2$ "=" $e$ "," $\mathit{lef}$ "\}"}:_\Gamma T_1}
{TSetter}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{TEmptyRecord}

\logicRule
{\Delta\vdash\forall i \in\mathbb{N}_1^n.\syntax{$e_i$}:_\Gamma T_i
}
{\Delta\vdash\syntax{"\{" $v_1$ "=" $e_1$ "," \dots "," $v_n$ "=" $e_n$ "\}"}:_\Gamma \{v_1:T_1,\dots,v_n:T_n\}
}
{TRecord}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma\textit{Bool}\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T\quad
\Delta\vdash\syntax{$e_3$}:_\Gamma T
}
{\Delta\vdash\syntax{"if" $e_1$ "then" $e_2$ "else" $e_3$}:_\Gamma T}
{TIfElse}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1 \to T_2\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_2 \to T_3
}
{\Delta\vdash\syntax{$e_1$ ">>" $e_2$}:_\Gamma T_1 \to T_3}
{TComposition}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_1 \to T_2
}
{\Delta\vdash\syntax{$e_1$ "|>" $e_2$}:_\Gamma T_2}
{TPipe}

\logicRule
{}
{\vdash\syntax{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{}
{\vdash\syntax{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\vdash\syntax{"not"}:\mathit{Bool}\to \mathit{Bool}}
{TNot}

\logicRule
{}
{\vdash\syntax{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\vdash\syntax{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\vdash\syntax{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\vdash\syntax{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\vdash\syntax{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\vdash\syntax{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\vdash\syntax{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\vdash\syntax{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\end{xtabular*}
\end{center}

\begin{description}
\item[TVariable] Find the type in the context.
\item[TLambda] Elm allows the parameters of a function to be pattern matched. Therefore, we first need to find a matching type $T_1$ and can then infer the type of $e$ by including the additional bindings $\Theta$ to the context.
\item[TTuple] Find the types of $e_1$ and $e_2$, then construct the tuple.
\item[TEmptyList] The empty list is a literal for every list, therefore we can infer the list poly type.
\item[TSingleList,TList] Recursively we check that every element has the same type.
\item[TInt,TBool] The type of literals can be inferred without any restrictions.
\item[TCall] The first expression needs to be a function that the the second type can be passed to.
\item[TSingleCaseOf,TCaseOf] First match the type of the expression $e_1$ to the pattern, then use the additional bindings $\Theta$ to obtain the type of $e_2$. As all patterns need to have the same type, we can then recursively check the other patterns as well.
\item[TLetIn,TLetIn2] The variable $v$ may not have a value assined in the conext $\Gamma$. If so, we can infer the type $T_1$ of $e_1$ and add $(v,T_1)$ to the context before we evaluate $e_2$. For $[TLetIn2]$ we already the type is already given as $t$. Note that $t$ can be more specific as the type we would usually infer.
\item[TGetter] The second variable $v_2$ is a label of the record, that is bound to $v_1$.
\item[TSingleSetter,TSetter] Setters can not change the type in Elm. But we still need to ensure that the fields are also correctly typed.
\item[TElmptyRecord] The empty record can be directly infered, as it has only one element.
\item[TRecord] Each field and its value must be given at the same time. That is why we can not use a recursive definition.
\item[TIfElse] The first expression $e_1$ needs to be a boolean and the branches $e_2,e_3$ must have the same type.
\item[TComposition,TPipe] The pipe applies the first expression to the second. The composition is similar to the pipe, but results in a function.
\item[TOr,TAnd,TNot,TEqual,TDivide,TMultiply,TMinus,TPlus,TCons,TFoldl] These functions can be seen as lambda function literals.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$, $\Delta = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl (::) []
\end{lstlisting}

Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```

### type inference for Patterns

For pattern matching we do not only want to infer a type that matches the pattern, but also find all substitutions for doing so. We will see that patterns also allow for variable declarations by using the `as` keyword.

```{definition,name="Type inference for pattern matching"}
\begin{letIn}$\Theta\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
p:\mf{<pattern>};\quad
v:\mf{<lower-var>};\quad
T:\mathcal{T};\\
\forall i\in\mathbb{N}_0^2.p_i:\mf{<pattern>};\quad
\forall i\in\mathbb{N}_3^n.p_i:\mf{<pattern>};\\
\forall i\in\mathbb{N}_0^n.v_i:\mf{<lower-var>};\quad
\forall i\in\mathbb{N}_0^n.T_i:\mathcal{T};\\
\forall i\in\mathbb{N}_0^3.\Theta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
\forall i\in\mathbb{N}_4^n.\Theta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\\
lpl:\mf{<list-pattern-list>}$
\end{letIn}

we say a pattern $p$ matches a type $T$ for the context $\Gamma$ using the bindings $\Theta$ if $\Gamma\vdash \text{match}_\Theta(T,p)$.

$\Theta$ contains the minimal substitutions and variable bindings needed to match the type to the pattern.

Instantiation and Generalization applies to pattern matching as well.

\begin{center}
\begin{tabular}{c l}
\logicRule
{
 T' \sqsubseteq T\quad
 \Gamma\vdash \text{match}_\Theta(T',\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Theta(T,\syntax{e})
}
{PInstantiation}

\logicRule
{(a,\_)\not\in\Gamma\quad
\Gamma\vdash \text{match}_\Theta(T,\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Theta(\forall a.T,\syntax{e})
}
{PGeneralization}
\end{tabular}
\end{center}

The type inference rules for pattern matching are as follows

\begin{center}
\begin{xtabular}{c l}
\logicRule
{}
{\vdash \text{match}_\varnothing(\mathit{Bool},$\_$:\syntax{<bool>})}
{PBool}

\logicRule{}
{\vdash \text{match}_\varnothing(\mathit{Int},$\_$:\syntax{<int>})}
{PInt}

\logicRule{}
{\vdash \text{match}_\varnothing(\forall a.\mathit{List} \ a,\syntax{"[]"})}
{PEmptyList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T_1,\syntax{$p$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(T_2,\syntax{"[" $lpl$ "]"})\\
\Theta_1\cap\Theta_2=\varnothing\quad
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\\
\Theta_1\cup\Theta_2=\Theta_3\quad
T_2 = \textit{List} \ T_1
\end{gathered}
}
{\Gamma\vdash \text{match}_{\Theta_3}(T_2,\syntax{"[" $p$ "," $lpl$ "]"}
}
{PList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T_1,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(T_2,\syntax{$p_2$})\quad\\
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\quad
\Theta_1\cup\Theta_2=\Theta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Theta_3}(T_1 \times T_2,\syntax{"(" $p_1$ "," $p_2$ ")"})
}
{PTuple}

\logicRule
{\syntax{$v$}=a\quad
(a,\_)\not\in\Gamma\quad
\Theta = \{(a,T)\}
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{$v$})
}
{PVariable}

\logicRule
{
\syntax{$v$}=a\quad
(v,T)\in\Gamma\quad
}
{
\Gamma\vdash\text{match}_\varnothing(T,\syntax{$v$})
}
{PSingleApplication}

\logicRule
{
\begin{gathered}
\Gamma\vdash \forall i\in\mathbb{N}_1^n.\text{match}_{\Theta_i}(\syntax{$p_i$}:T_i)\quad\\
(p_0,T_1\to \dots \to T_n\to T_0)\in\Gamma\quad\\
\forall i\in\mathbb{N}_1^n.\forall j\in\mathbb{N}_1^n.i\neq j \Rightarrow\forall (a_1,\_)\in \Theta_i,(a_2,\_)\in\Theta_j.a_1 \neq a_2\\
\Theta_0 = \bigcup_{i\in\mathbb{N}_1^n}\Theta_i
\end{gathered} 
}
{
\Gamma\vdash \text{match}_{\Theta_0}(T_0,\syntax{$p_0$ $p_1$ .. $p_n$})
}
{PApplication}
\logicRule
{(v,\_)\not\in\Gamma\quad
(v,T)\in\Theta\quad
\Gamma\vdash \text{match}_{\Theta\backslash\{(v,T)\}}(T,\syntax{$p$})
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{$p$ "as" $v$})}
{PAs}

\logicRule
{}
{\vdash \text{match}_\varnothing(\{\},\syntax{"\{\}"})}
{PEmptyRecord}

\logicRule
{
\begin{gathered}
k:\mathbb{N}_1^m\to\mathbb{N}_1^n\quad
k \text{ is injective}\quad\quad
\forall i\in\mathcal{N}_1^n.(v_{k(i)},\_)\not\in\Gamma\\
\Theta = \bigcup_{i\in\mathbb{N}_1^n} \{(v_{k(i)},T_{k(i))}\}\quad
T = \{v_1:T_1,\dots,v_n:T_n\}
\end{gathered}
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{"\{" $v_{k_1}$ "," $\dots$ "," $v_{k_m}$ "\}"})
}
{PRecord}

\logicRule
{
\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(List \ T,\syntax{$p_2$})\quad\\
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\quad
\Theta_1\cup\Theta_2=\Theta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Theta_3}(\textit{List} \ T,\syntax{$p_1$ "::" $p_2$})
}
{PHeadAndTail}

\logicRule
{}
{\Gamma\vdash \text{match}_\varnothing(\forall a. a,\syntax{"\_"})}
{PWildcard}



\end{xtabular}
\end{center}
```

\begin{description}
\item[PBool,PInt,PEmptyList] The type of literals can be infered without any restrictions.
\item[PList,PTuple] Recursively we need to ensure that every element has the same type. Additionally every binding needs to be unique.
\item[PVariable] If the variable is not yet bound in context, will can be added to $\Theta$.
\item[PSingleApplication] A single application ist just a Terminal. Its type is defined in the context $\Gamma$.
\item[PApplication] For a generell application the constructor can again be found in the context.Again we need to ensure that the elements of all $\Theta_i$ sets are unique in the first element.
\item[PAs] We bind the variable in $\Theta$ and then ensure that it can not be bound again. Note that binding are done bottom up, so $\Theta$ contains all bindings that occure in $p$.
\item[PEmptyRecord] The empty record ist just a literal.
\item[PRecord] Here the variable names and the field names are the same. For every field that we name, the type will be bound to the variable that has the same name. This requires that all the field names are not yet bound in $\Gamma$.
\item[PHeadAndTail] This is the same as $\mathit{[PList]}$ with the difference that now we intentially look at one elment at a time, where as PList has already given the length of the list.
\item[PWildcard] Anything is allowed, thus we infere the smalles type: $\forall a.a$.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. Now we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$ and $\Gamma = \varnothing$.

We start by proving $\vdash \text{match}_\varnothing(\mathit{List} \ \mathit{Int},\syntax{"\_"})$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[PWildcard]}$}
  \UnaryInfC{$\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
\RightLabel{$\mathit{[PInstantiation]}$}
\UnaryInfC{$\vdash \text{match}_\varnothing(\textit{List} \ \text{Int},\syntax{"\_"})$}
\end{prooftree}
\end{center}

Next we prove $\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{\(a\):<lower-var> " :: \_"})$ for $\Theta=\{(a,\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\vdash \text{match}_\Theta(\textit{Int},\syntax{a})$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Theta\cap\varnothing=\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\textit{List} \ \textit{Int},\syntax{"\_"})$}
\RightLabel{$(1)$}
\TrinaryInfC{$\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{a:<lower-var> " :: \_"})$}
\end{prooftree}
\end{center}
$(1) \mathit{[PHeadAndTail]}, (2) \mathit{[PInstantiation]}, (3) \mathit{[PWildcard]},(4) \mathit{[PVariable]}$
```