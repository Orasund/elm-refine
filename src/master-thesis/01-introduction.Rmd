# Introduction

On 21. September 1997, the onboard computer of the USS Yorktown aircraft carrier threw an uncaught division by zero exception. This resulted in the computer shutting down and the ship becoming unable to be controlled until an engineer was able to restart the computer. Fortunately this happened during a training maneuver&nbsp;[@humblePi].

Typically, such errors can only be found by extensive testing. Instead one might try to use a more expressive type system that can ensure at compile time that division by zero and similar bugs are impossible to occur.

These more expressive types are called *Refinement Types* [@refinement_types_for_ML]. Some authors also call them *Dependent Types*&nbsp;[@little_typer], though dependent types are typically more general: They are used to prove specific properties by letting the type definition depend on a quantified predicate, whereas a refinement type takes an existing type and excludes certain values that do not ensure a specific property. To avoid confusion, we will use the term \enquote{refinement types} within this thesis. The predicate describing the valid values of a refinement type is called a _refinement_.

Refinement types were first introduced by Tim Freeman and Frank Pfenning in 1991&nbsp;[@refinement_types_for_ML]. In 2008, Patrick M. Rondon, Ming Kawaguchi, and Ranjit Jhala from the university of California came up with a variant of refinement types called Logically Quantified Data types, or *Liquid* types for short. Liquid types limit themself to refinements on Integers and Booleans written in propositional logic together with order relations and addition.

Most work on liquid types was done in the UCSD Programming System research group, from which the original paper originated. This group has presented different implementations of liquid types:

* **DSolve** for OCaml/ML&nbsp;[@DSolve]. This type checker originated from the original paper, where liquid types could only be established for a calculus called $\lambda_L$. DSolve first translates OCaml to $\lambda_L$ and then checks the result for type safety.
* **CSolve** for C&nbsp;[@CSolve]. As a follow-up to DSolve, this checker implements Low-Level Liquid Type (LTLL) [@LTLL] for a formal language called *NanoC* that extends $\lambda_L$ with pointer arithmetic.
* **LiquidHaskell** for Haskell [@RT_for_Haskell]. Extending $\lambda_L$, this type checker uses a new calculus called $\lambda_P$, a polymorphic $\lambda$-calculus [@abstract_refinement_types]. Newer versions can also reason about termination, totality (of functions) and basic theorems.
* **RefScript** for TypeScript [@Refined_TypeScript]. In a two phase process, the dynamic typed language gets translated into a static typed abstract language [@trust_but_verify]. This language can then be type checked using $\lambda_P$.

Outside of that research group, refinement types have also been implemented for Racket&nbsp;[@Racket], Ruby&nbsp;[@Ruby] and F#&nbsp;[@F_sharp].

Elm is a pure functional programming language invented in 2012 by Evan Czaplicki in his master thesis [@elm]. Elm has many similarities to Haskell but is simpler in nature. Its programs are based on a special architecture similar to state machines instead of the monads used in Haskell. This architecture ensures that no runtime error can occur: Errors are modelled via types and therefore need to be handled at compile time. The language compiles to JavaScript which gives the Elm community the unique position of being the first contact with functional programming for many web developers.

This unique position gave rise to design philosophies for writing good functional code, not only for Elm. One such philosophy is \enquote{Make impossible states impossible}: Model your program in such a way that any possible state of the model represents a valid state of the program. Refinement types provide a way to achieve that rule for integers. Even simple types like a subtype containing all natural numbers or a type containing a range of numbers would be of help. 

The goal of this thesis is therefore to define Liquid Types for Elm. In particular, we define a set of predicates $\mathcal{Q}$ such that the type of ever Elm program with if-conditions in $\mathcal{Q}$ can be inferred. $\mathcal{Q}$ needs to allow the definition of range types, natural numbers, and non-zero integers.

Elm has changed a lot since 2012 and therefore the formal model described in the original thesis is outdated. We have started our work by formally defining the Elm language. This includes the syntax, denotational semantic, types and a system of inference rules to infer them. We then introduce the formal notion of liquid types to our type system. We also define the subset of allowed predicates in an if-condition and extend the syntax with refinement types. Furthermore, we present altered inference rules to ensure that liquid types can be defined. Here we introduce the notion of subtyping conditions. We describe an algorithm to solve these conditions and specify a set of predicates that may be used for deriving a refinement solving the subtyping conditions. The algorithm generates SMT statements that can be checked using an SMT solver. To demonstrate everything in tandem, we provide an implementation of the subtyping algorithm using Z3[@z3] for solving the SMT statements.

The remaining thesis is structured as follows:
In Chapter \@ref(state-of-the-art), we give a quick history of type systems and the Elm language. In Chapter \@ref(formal-definition-of-elm), we formally define the type system of Elm. In Chapter \@ref(liquid-types), we introduce refinement types and describe how we can extend the type system using liquid types. In Chapter \@ref(implementation), we discuss the implementation and provide a demonstration. In Chapter \@ref(conclusions), we evaluate our results and present our conclusions.