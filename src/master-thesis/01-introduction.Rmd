# Introduction

On 21. September 1997 the onboard computer of the USS Yorktown aircraft carrier threw an uncaught division by zero exception. This resulted in the board computer shutting down and the ship becoming unable to be controlled until an engineer was able to restart the computer. Fortunately this happened during a training maneuver [@humblePi].

Typically, such errors can only be found by extensive testing. Instead one might try to use a more expressive type system that can ensure at compile time that division by zero and similar bugs are impossible to occur.

These more expressive types are called *Refinement Types* [@refinement_types_for_ML]. Some authors also call them *Dependent Types*&nbsp;[@little_typer], though dependent types are typically more general: They are used to prove specific properties by letting the type definition depend on a quantified predicate, whereas a refinement type takes an existing type and excludes certain values that do not ensure a specific property. To avoid confusion, we will use the term \enquote{refinement types} within this thesis. The predicate describing the valid values of a refinement type is called a _refinement_.

Refinement types were first introduced by Tim Freeman and Frank Pfenning in 1991 [@refinement_types_for_ML]. In 2008 Patrick M. Rondon, Ming Kawaguchi and Ranjit Jhala from the university of California came up with a variant of refinement types called Logically Quantified Data Types, or *Liquid Types* for short. Liquid Types limit themself to refinements on Integers and Booleans written in propositional logic together with order relations and addition.

Most work on Liquid Types was done in the UCSD Programming System research group, from which the original paper originated. The group has presented different implementations of Liquid types:

* **DSolve** for OCaml/ML&nbsp;[@DSolve]. This type checker originated from the original paper. In the original paper Liquid types could only be ensured for a calculus called $\lambda_L$. It first translates OCaml to $\lambda_L$ and then checks for type safety.
* **CSolve** for C&nbsp;[@CSolve]. As a follow-up to DSolve, this checker implements Low-Level Liquid Type (LTLL) [@LTLL] for a formal language called *NanoC* that extends $\lambda_L$ with pointer arithmetics.
* **LiquidHaskell** for Haskell [@RT_for_Haskell]. Extending $\lambda_L$, this type checker uses a new calculus called $\lambda_P$, a polymorphic $\lambda$-calculus [@abstract_refinement_types]. Newer versions can also reason about termination, totalness (of functions) and basic theorems.
* **RefScript** for TypeScript [@Refined_TypeScript]. In a two phase process, the dynamic typed language gets translated into a static typed abstract language [@trust_but_verify]. This language can then be type checked using $\lambda_P$.

Outside of that research group, refinement types have also been implemented for Racket&nbsp;[@Racket], Ruby&nbsp;[@Ruby] and F#&nbsp;[@F_sharp].

Elm is a pure functional programming language invented in 2012 by Evan Czaplicki as his master thesis _Elm_&nbsp;[@elm]. Elm has many similarities to Haskell but is simpler in nature. It uses a special architecture similar to state machines instead of monads used in Haskell. This architecture ensures that no runtime error can occur: Error are modelled as a type and therefore need to be handled. The language compiles to JavaScript. This gives the Elm community the unique position being the first contact with functional programming for many programmers.

This unique position gave rise to design philosophies for writing good functional code, not only for Elm. One such philosophie is \enquote{Make impossible states impossible}: Model your program in such a way that any possible state of the model represents a valid state of the program. Refinement types provide a way to achieve that rule for integers. Even simple types like a subtype containing all natural numbers or a type containing a range of numbers would be of help. 

The goal of this thesis is therefore to define Liquid Types for Elm. In particular to define a set of predicates $\mathcal{Q}$ such that the type of ever Elm program with if-then-else conditions in $\mathcal{Q}$ can be inferred. $\mathcal{Q}$ needs to allow the definition of range types, natural numbers and non-zero integers.

Elm has changed a lot since 2012 and therefore the formal model described in the original thesis is outdated. We therefore start by formally defining the Elm language. This will include the syntax, denotational semantic, types and a system of inference rules to infer them. We then will introduce the formal notion of Liquid types to our type system. We also will define the subset of allowed predicates in an if-then-else condition and will extend the syntax with refinement types. Furthermore, we will present altered inference rules to ensure that Liquid types can be defined. Here we will introduce the notion of subtyping conditions. We will describe an algorithm to solve these conditions. Here we will specify a set of predicates that may be used for deriving a refinement solving the subtyping conditions. The algorithm generates SMT statements that can be checked using an SMT solver. To demonstrate everything in tandem we will provide an implementation of the subtyping algorithm using Z3 for solving the SMT statements.

In Chapter \@ref(state-of-the-art) we will give a quick history of type systems and the Elm language. In Chapter \@ref(formal-definition-of-elm) we will formally define the type system of Elm. In Chapter \@ref(liquid-types) we introduce refinement types and describe how we can extend the type system using Liquid types. In Chapter \@ref(implementation) we discuss the implementation and provide a demonstration. In Chapter \@ref(conclusion) we give the conclusion of the thesis.