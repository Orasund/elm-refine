### Inference Rules for Statements

#### list-statement-var

Judgment: $lsv:(a_1,\dots,a_n)$

\logicRule
{}
{\mf{""}:()}
{}

\logicRule
{lsv:(a_1,\dots,a_n)}
{a_0 \ lsv:(a_0,a_1,\dots,a_n)}
{}

#### list-statement-sort

Judgment: $lss:(c_1:(T_{1,1}, \dots,T_{1,k_1}),\dots,c_n:(T_{n,1}, \dots,T_{n,k_n}))$

\logicRule
{\Gamma\vdash lt:(T_0,\dots,T_n)
}
{c \ lt:(c:(T_0,\dots,T_n))}
{}

\logicRule
{\begin{gathered}
\Gamma\vdash lt:(T_{0,1},\dots,T_{0,k_n})\\
lss:\begin{pmatrix*}[l]
a_1:(T_{1,1}, \dots,T_{1,k_1}),\\
\vdots\\
a_n:(T_{n,1}, \dots,T_{n,k_n})
\end{pmatrix*}
\end{gathered}
}
{c \ lt \ \mf{"|"} \ lss:\begin{pmatrix*}[l]
a_0:(T_{0,1}, \dots,T_{0,k_0}),\\
a_1:(T_{1,1}, \dots,T_{1,k_1}),\\
\vdots\\
a_n:(T_{n,1}, \dots,T_{n,k_n})
\end{pmatrix*}
}
{}

#### list-statement

Judgment: $\Gamma_1,\Delta_1,ls\vdash \Gamma_2,\Delta_2$

\logicRule
{\Gamma_1=\Gamma_2\quad
\Delta_1=\Delta_2
}
{\Gamma_1,\Delta_1\mf{""}\vdash \Gamma_2,\Delta_2}
{}

\logicRule
{\Gamma_1,\Delta_1,s\vdash \Gamma_2,\Delta_2\quad
\Gamma_2,\Delta_2, ls \vdash \Gamma_3,\Delta_3
}
{\Gamma_1,\Delta_1, s \ \mf{";"} \ ls \vdash \Gamma_3,\Delta_3}
{}

#### maybe-statement-sign

Judgment: $\Gamma,mss\vdash a:T$

\logicRule
{}
{\Gamma,\mf{""}\vdash a:T}
{}

\logicRule
{\Gamma\vdash t:T
a_1 = a_2}
{\Gamma,a_1 \ \mf{":"} \ t \ \mf{";"}\vdash a_2:T}
{}

#### statement

Judgment: $\Gamma_1,\Delta_1,s\vdash \Gamma_2,\Delta_2$

\logicRule
{\begin{gathered}
\Gamma_1 = \Gamma_2\quad
(a,\_)\not\in\Delta_1\\
\Gamma_1,mss\vdash e:T\quad
\Gamma_1,\Delta_1\vdash e : T\quad
\Delta_2 = \Delta_1\cup\{(a,T)\}
\end{gathered}
}
{\Gamma_1,\Delta_1, mss \ a \ \mf{"="} e\vdash \Gamma_2,\Delta_2
}
{TConstant}

\logicRule
{\begin{gathered}
\Delta_1=\Delta_2\quad
(c,\_)\not\in\Gamma_1\quad
\Gamma\vdash t:T_1\\
T_2 \text{ is a mono type}\quad
lsv:(a_1,\dots,a_n)\quad
\{a_1 \dots a_n \} = \text{free}(T_2)\\
\forall a_1. \dots \forall a_n. T_2 = T_1\quad
\Gamma_2 = \Gamma_2\cup\{(c,T_1)\}
\end{gathered}
}
{\Gamma_1,\Delta_1,\mf{"type alias"} \ c \ lsv \ \mf{"="} \ t \vdash \Gamma_2,\Delta_2
}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma_1\quad
lsv:(a_1,\dots,a_n)\\
lss:(c_1:(T_{1,1}, \dots,T_{1,k_1}),\dots,c_n:(T_{n,1}, \dots,T_{n,k_n}))\\
\Delta_1\cap\{(c_1,\_),\dots,(c_n,\_)\} = \varnothing\quad
\{a_1 \dots a_n \} = \text{free}(T_2)\\
\mu C.c_1 \ T_{1,1} \ \dots \ T_{1,k_1} \ | \ \dots \ | \ c_n \ T_{n,1} \ \dots \ T_{n,k_n}=T_2\quad
\forall a_1. \dots \forall a_n. T_2 = T_1\\
\Gamma_1\cup\{(c,T_1)\} = \Gamma_2\quad
\Delta_1\cup
\begin{Bmatrix*}[l]
(c_1,T_{1,1}\to\dots\to T_{1,k_1}\to T_1),\\
\vdots\\
(c_n,T_{n,1}\to\dots\to T_{n,k_n}\to T_1)
\end{Bmatrix*} = \Delta_2
\end{gathered}
}
{\Gamma_1,\Delta_1,\mf{"type"} \ c \ lsv \mf{"="} lss \vdash\Gamma_2,\Delta_2
}
{TCustomType}
Algebraic types are called "Custom Types" in Elm. The list $lss$ provides us with the structure of the type. From there we construct the type $T_2$ and bind all variables, thus creating the poly type $T_1$. Additionally, every sort $c_i$ for $i\in\mathbb{N}_1^n$ has its own constructor that gets added to $\Delta_1$ under the name $c_i$. In Elm these constructors are the only constants beginning with an upper-case letter.

#### maybe-main-sign

Judgment: $\Gamma,mms\vdash \text{main}:T$

\logicRule
{}
{\Gamma,\mf{""}\vdash \text{main}:T}
{}

\logicRule
{\Gamma\vdash t:T}
{\Gamma,\mf{"main :"} t \mf{";"}\vdash \text{main}:T}
{}

#### program

Judgment: $\textit{prog}:T$

\logicRule
{
\varnothing,\varnothing ls \vdash \Gamma,\Delta\quad
\Gamma,mms\vdash \text{main}:T\quad
\Gamma,\Delta\vdash e:T
}
{ls \ mms \ \mf{"main = "} e}
{}



```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. Now we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$ and $\Gamma = \varnothing$.

We start by proving $\vdash \text{match}_\varnothing(\mathit{List} \ \mathit{Int},\syntax{"\_"})$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[PWildcard]}$}
  \UnaryInfC{$\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
\RightLabel{$\mathit{[PInstantiation]}$}
\UnaryInfC{$\vdash \text{match}_\varnothing(\textit{List} \ \text{Int},\syntax{"\_"})$}
\end{prooftree}
\end{center}

Next we prove $\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{\(a\):<lower-var> " :: \_"})$ for $\Theta=\{(a,\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\vdash \text{match}_\Theta(\textit{Int},\syntax{a})$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Theta\cap\varnothing=\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\textit{List} \ \textit{Int},\syntax{"\_"})$}
\RightLabel{$(1)$}
\TrinaryInfC{$\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{a:<lower-var> " :: \_"})$}
\end{prooftree}
\end{center}
$(1) \mathit{[PHeadAndTail]}, (2) \mathit{[PInstantiation]}, (3) \mathit{[PWildcard]},(4) \mathit{[PVariable]}$
```

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$, $\Delta = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl (::) []
\end{lstlisting}

Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```