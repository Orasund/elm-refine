### Inference Rules for Statements

#### list-statement-sort

Judgment: $lss:((c_1:(T_{1,1}, \dots,T_{1,k_1}),T'_1),\dots,(c_n:(T_{n,1}, \dots,T_{n,k_n}),T'_n))$

\logicRule
{\Gamma\vdash lt:(T_1,\dots,T_n)\quad
T_1\to\dots\to T_n = T'
}
{c \ lt:(c:(T_1,\dots,T_n),T'))}
{}

\logicRule
{\Gamma\vdash lt:(T_{0,1},\dots,T_{0,k_n})\quad
T_{0,1}\to\dots\to T_{0,k_n}= T'_0\quad
lss:((a_1:(T_{1,1}, \dots,T_{1,k_1}),T'_1),\dots,(a_n:(T_{n,1}, \dots,T_{n,k_n}),T'_n))
}
{c \ lt \ \mf{"|"} \ lss:((a_0:(T_{0,1}, \dots,T_{0,k_0}),T'_0),(a_1:(T_{1,1}, \dots,T_{1,k_1}),T'_1),\dots,(a_n:(T_{n,1}, \dots,T_{n,k_n}),T'_n))
}
{}

#### list-statement

//TODO

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{$v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\quad
\syntax{$t$}_\Gamma = T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2\quad
\end{gathered}
}
{\Delta\vdash\syntax{$v$ ":" $t$ ";" $v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant2}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\\
\syntax{t}_\Gamma=T_1\quad
T_2 \text{ is a mono type}\\
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\syntax{"type alias" $c$ $v_1 \dots v_n$ "=" $t$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_3}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\mu C.c_1 \ \syntax{$t_{1,1}$}_\Gamma \ \dots \ \syntax{$t_{1,k_1}$}_\Gamma \ | \ \dots \ | \ c_m \ \syntax{$t_{m,1}$}_\Gamma \ \dots \ \syntax{$t_{m,k_m}$}_\Gamma=T_2\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\Bigg\llbracket
\begin{aligned}
&\mf{"type"} \ c \ v_1 \dots v_n \mf{"="}\\
&c_1 \ t_{1,1} \dots t_{1,k_1} \ | \ \dots | \ c_m \ t_{m,1} \dots t_{m,k_m}\\ &\mf{";"} s \ mt \mf{"main = "} me
\end{aligned}\Bigg\rrbracket:_\Gamma T_3
}
{TCustomType}

\logicRule
{\Delta\vdash\syntax{$e$}:_\Gamma T}
{\Delta\vdash\syntax{"main = " $e$}:_\Gamma T}
{TMain}

\logicRule
{
\Delta\vdash\syntax{$e$}:_\Gamma T\quad
\syntax{$t$}_\Gamma=T
}
{\Delta\vdash\syntax{"main :" $t$ "; main = " $e$}:_\Gamma T}
{TMain2}



```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. Now we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$ and $\Gamma = \varnothing$.

We start by proving $\vdash \text{match}_\varnothing(\mathit{List} \ \mathit{Int},\syntax{"\_"})$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[PWildcard]}$}
  \UnaryInfC{$\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
\RightLabel{$\mathit{[PInstantiation]}$}
\UnaryInfC{$\vdash \text{match}_\varnothing(\textit{List} \ \text{Int},\syntax{"\_"})$}
\end{prooftree}
\end{center}

Next we prove $\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{\(a\):<lower-var> " :: \_"})$ for $\Theta=\{(a,\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\vdash \text{match}_\Theta(\textit{Int},\syntax{a})$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Theta\cap\varnothing=\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\textit{List} \ \textit{Int},\syntax{"\_"})$}
\RightLabel{$(1)$}
\TrinaryInfC{$\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{a:<lower-var> " :: \_"})$}
\end{prooftree}
\end{center}
$(1) \mathit{[PHeadAndTail]}, (2) \mathit{[PInstantiation]}, (3) \mathit{[PWildcard]},(4) \mathit{[PVariable]}$
```

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$, $\Delta = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl (::) []
\end{lstlisting}

Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```