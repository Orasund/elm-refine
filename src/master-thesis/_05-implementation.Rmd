\setcounter{section}{4}

# Implementation

## The Inference Algorithm

We start by introducing constraint. These constrains will later be used to derive liquid types.

```{definition,name="Constraint, Template, Liquid type Variable"}

A constraint is a judgment of the form 

$$
  \mathit{predicate} \vdash \mathcal{Q} <: \mathit{template}
$$
  
where

\[
\begin{aligned}
\mathit{template} ::=& \mathcal{T}\\
                 | \ & \kappa_\mathcal{V}\\
                 | \ & \mathit{template} \rightarrow \mathit{template}
\end{aligned}
\]\[
\begin{aligned}
\mathit{predicate} ::=& \mathcal{V} : \mathit{template}\\
                  | \ & \mathcal{Q}
\end{aligned}
\]\[
\begin{aligned}
\mathit{constraint} ::=& \mathit{predicate} \vdash \mathcal{Q} <: \mathit{template}
\end{aligned}
\]
  
Note that the symbol $\kappa$ is called a _Liquid Type Variable_ within that context.

We call a partial function $\Theta:\mathcal{V}\nrightarrow\mathit{template}$ a _template context_.
```

The type inference for liquid types goes in three phases:

1. Let the base types be derived and replaced by template liquid types
2. Generate constraints by using predicate abstraction
Refine the templates to make them as sharp as possible. (Find the strongest constraints for each liquid type variable)
3. Change templates into liquid types using a divide and conqure approach.

```{block2, type="myexample",latex.options="_"}
We will now look at the following code snippet.

\begin{lstlisting}[language=elm]
max : a:Int -> b:Int 
  -> {v:Int| (a =< b && v = b) || (a > b && v = a)};
max =
  \n -> \m -> if n =< m then m else n;
\end{lstlisting}

We can easily infer the type for $\mf{\textbackslash n -> \textbackslash m -> if n =< m then m else n}$ namely $a:\kappa_a\to b:\kappa_b\to \kappa_x$.

We additionally have two judments that need to be proven:

$$
\begin{aligned}
\Gamma,\Delta,\Theta,\Lambda\cup\{n \leq m\}\vdash& m: \hat{T}\\
\Gamma,\Delta,\Theta,\Lambda\cup\{\neg (n \leq m)\}\vdash& n: \hat{T}
\end{aligned}
$$

These can be turned into constraints:
  
$$
\begin{aligned}
m:\kappa_a,n:\kappa_b,n \leq m\vdash& m<:_{\Theta,\Lambda}\kappa_x\\
m:\kappa_a,n:\kappa_b,\neg (n \leq m)\vdash& n<:_{\Theta,\Lambda}\kappa_x
\end{aligned}
$$
  
We can infer (//TODO from where?) that $\kappa_a = \kappa_b = \{v:\mathit{Int}|\mathit{True}\}$
  
Thus we are left with the constraints

$$
\begin{aligned}
m:Int,n:Int,n \leq m\vdash& m<:\kappa_x\\
m:Int,n:Int,\neg (n \leq m)\vdash& n<:\kappa_x
\end{aligned}
$$
  
Using and special algorithm and an SMT-Solver we then infer from there that

$\kappa_x = \{v:\mathit{Int}|{v:Int| (a =< b \land v = b) \lor (a > b \land v = a)}\} =: \hat{T}$.

//TODO: How do we check this is a valid type?
```