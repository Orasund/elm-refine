### Inference Rules for Expressions

#### list-exp-field

Judgment: $\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}$

\logicRule
{\Gamma,\Delta\vdash e:T}
{\Gamma,\Delta\vdash a \ \mf{"="} \ e : \{a:T\}}
{}

\logicRule
{\Gamma,\Delta\vdash lef:T\quad
\Gamma,\Delta\vdash e:T_0\quad
\{a_0:T_0,\dots,a_n:T_n\}=T
}
{\Gamma,\Delta\vdash a_0 \ \mf{"="} \ e \ \mf{","} \ lef : T}
{}

#### maybe-exp-sign

Judgment: $mes:T_1\vdash a:T_2$

\logicRule
{}
{\mf{""} : T_1 \vdash a : T_2}
{}
If no argument is given, then we do nothing, therefore the additional information of $T_1$ will be discarded.

\logicRule
{a_1 = a_2\quad
T_2 \sqsubseteq T_1
}
{a_1 : T_1 \vdash a_2 \ \mf{";"}: T_2}
{}
If we have a variable $a_1$ and a type $T_1$, then the variables $a_2$ need to match. The type signiture $T_1$ defines the type of $a_2$, even if we would be able to infer a weaker type $T_2$.

#### list-case

Judgment: $\Gamma,\Delta,T_1\vdash lc:T_2$

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\Delta\cup\Theta\vdash e:T_2
}
{\Gamma,\Delta,T_1\vdash p \ \mf{"->"} \ e:T_2}
{}
Given the type $T_1$ of the expression that is being matched,
we can now find all new binding $\Theta$ by matching $p$ with $T_1$.
Finally we unify $\Delta$ with $\Theta$.

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\Delta\cup\Theta\vdash e:T_2\quad
\Gamma,\Delta,T_1\vdash lc:T_2
}
{\Gamma,\Delta,T_1\vdash p \ \mf{"->"} \ e \ \mf{";"} \ lc:T_2}
{}

#### bool

Judgment: $b:T$

\logicRule
{}
{b:\mathit{Bool}}
{}

#### int

Judgment: $i:T$

\logicRule
{}
{i:\mathit{Int}}
{}
We have proven in theorem \ref{ex:int} that $\mathit{Nat}$ is isomorph to $\mathbb{N}$. Is should be trivial to therefore conclude that $\mathit{Int}$ is insomorph to $\mathbb{Z}$. And therefore this rule is justified.

#### list-exp

Judgment: $\Gamma,\Delta\vdash le:T$

\logicRule
{}
{\Gamma,\Delta\vdash \mf{""}:\forall a. \mathit{List} a}
{}

\logicRule
{\Gamma,\Delta\vdash e:T\quad
\Gamma,\Delta\vdash le:\mathit{List} \ T\quad
}
{\Gamma,\Delta\vdash e \ \mf{","} \ le:\mathit{List} \ T}
{}

#### exp

Judgment: $\Gamma,\Delta\vdash e:T$

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"not"}:\mathit{Bool}\to \mathit{Bool}}
{TNot}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{
\Gamma,\Delta\vdash e_1: T_1\quad
\Gamma,\Delta\vdash e_2: T_1 \to T_2
}
{\Gamma,\Delta\vdash e_1 \ \mf{"|>"} \ e_2:T_2}
{TPipe}

\logicRule
{
\Gamma,\Delta\vdash e_1: T_1 \to T_2\quad
\Gamma,\Delta\vdash e_2: T_2 \to T_3
}
{\Gamma,\Delta\vdash e_1 \ \mf{">>"} \ e_2:T_1 \to T_3}
{TComposition}

\logicRule
{
\Gamma,\Delta\vdash e_1:\textit{Bool}\quad
\Gamma,\Delta\vdash e_2: T\quad
\Gamma,\Delta\vdash e_3: T
}
{\Gamma,\Delta\vdash\mf{"if"} \ e_1  \ \mf{"then"} \ e_2 \ \mf{"else"} e_3:T}
{TIfElse}

\logicRule
{\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}
}
{\Gamma,\Delta\vdash\mf{"\{"} lef \mf{"\}"}: \{a_1:T_1,\dots,a_n:T_n\}
}
{TRecord}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"\{\}"}:\{\}
}
{TEmptyRecord}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}\\
\Gamma,\Delta\vdash (a,T_0)\in\Delta\quad
T_0=\{a_1:T_1,\dots,a_n:T_n,\dots \}
\end{gathered}
}
{\Gamma,\Delta\vdash\mf{"\{"} \ a \ \mf{"|"} \ lef \ \mf{"\}"}:T_0}
{TSetter}
Since Elm Version 1.19, released in 2018, setters are not allowed to change the type of a field in a record.

\logicRule
{(a_1,\{a_2:T,\dots\})\in\Delta
}
{\Gamma,\Delta\vdash a_1 \mf{"."} a_2:T}
{TGetter}

\logicRule
{\begin{gathered}
(a,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash e_1:T_1\quad
mes:T_1\vdash a:T_1\\
\Gamma,\Delta\cup(a,T_1)\vdash e_2:T_2
\end{gathered}
}
{\Gamma,\Delta\vdash\mf{"let"} mes \ a \mf{"="} e_1 \mf{"in"} e_2: T_2
}
{TLetIn}

\logicRule
{\Gamma,\Delta\vdash e_1: T_1\quad
\Gamma,\Delta,T_1\vdash lc:T_2
}
{\Gamma,\Delta\vdash\mf{"case"} \ e_1 \ \mf{"of" "["} \ lc \ \mf{"]"}: T_2
}
{TCaseOf}

\logicRule
{\Gamma,\Delta\vdash e_1: T_1\to T_2\quad
\Gamma,\Delta\vdash e_2: T_1
}
{\Gamma,\Delta\vdash e_1 \ e_2: T_2}
{TCall}

\logicRule
{b:T}
{\Gamma,\Delta\vdash b : T}
{TBool}

\logicRule
{i:T}
{\Gamma,\Delta\vdash i:T}
{TInt}

\logicRule
{\Gamma,\Delta\vdash le:T
}
{\Gamma,\Delta\vdash\mf{"["} \mathit{le} \mf{"]"}: T}
{TList}

\logicRule
{\Gamma,\Delta\vdash e_1:T_1\quad
\Gamma,\Delta\vdash e_2:T_2
}
{\Gamma,\Delta\vdash\mf{"("} \ e_1 \ \mf{","} \ e_2 \mf{")"}:(T_1,T_2)}
{TTuple}

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\Delta\cup\Theta\vdash e: T_2
}
{\Gamma,\Delta\vdash\mf{"\textbackslash"} p \mf{"->"} e: T_1\to T_2}
{TLambda}
In Elm function arguments may be pattern matched, this mostly used to "unwrap" a type, meaning to bind contained elements to variables.

\logicRule
{(c,T)\in\Delta
}
{\Gamma,\Delta\vdash c: T}
{TConstructor}

\logicRule
{(a,T)\in\Delta
}
{\Gamma,\Delta\vdash a: T}
{TVariable}

\textemdash

There rules do not work on there own, as the type might be too specific or a poly type needs to be instancated. Therefore the hindley-Milner type system comes with two additional rules:

\logicRule
{\Gamma,\Delta\vdash e: T_2\quad
T_2 \sqsubseteq T_1
}
{\Gamma,\Delta\vdash e: T_1}
{Instantiation}
Read top to bottom, this rule states that if an expression $e$ is of type $T_2$ is we may also conclude that $e$ is of a more specific type $T_1$.

\logicRule
{(a,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash e: T
}
{\Gamma,\Delta\vdash e:\mathit{\forall a.T}}
{Generalization}
Read bottom up, for a poly type $\forall a.T$ we may remove the the for-all-quantor if the variable $a$ has already a binding in $\Delta$.

Taking these two new rules into account, the resulting inference rules do not have a unique rule for every expression any longer. This means we are able to type check but not to infer a type.

We will fix this problem at the end of the chapter by introducing two different methods how to imbedd these two rules amoung the others.