### Inference Rules for Expressions

#### list-exp-field

Judgment: $\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}$

\logicRule
{\Gamma,\Delta\vdash e:T}
{\Gamma,\Delta\vdash a \ \mf{"="} \ e : \{a:T\}}
{}

\logicRule
{\Gamma,\Delta\vdash lef:T\quad
\Gamma,\Delta\vdash e:T_0\quad
\{a_0:T_0,\dots,a_n:T_n\}=T
}
{\Gamma,\Delta\vdash a_0 \ \mf{"="} \ e \ \mf{","} \ lef : T}
{}

#### maybe-exp-sign

Judgment: $\Gamma,mes\vdash a:T$

\logicRule
{}
{\Gamma,\mf{""} \vdash a : T}
{}
If no argument is given, then we do nothing.

\logicRule
{\Gamma\vdash t:T
a_1 = a_2
}
{\Gamma,a_1 \mf{":"} t \mf{";"} \vdash a_2 : T}
{}
If we have a variable $a_1$ and a type $T$, then the variables $a_2$ need to match. The type signature $t$ defines the type of $a_2$.

#### list-case

Judgment: $\Gamma,\Delta,T_1\vdash lc:T_2$

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\text{insert}_\Delta(\Theta)\vdash e:T_2
}
{\Gamma,\Delta,T_1\vdash p \ \mf{"->"} \ e:T_2}
{}
Given the type $T_1$ of the expression that is being matched,
we can now find all new binding $\Theta$ by matching $p$ with $T_1$.
Finally, we unify $\Delta$ with $\Theta$.

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\text{insert}_\Delta(\Theta)\vdash e:T_2\quad
\Gamma,\Delta,T_1\vdash lc:T_2
}
{\Gamma,\Delta,T_1\vdash p \ \mf{"->"} \ e \ \mf{";"} \ lc:T_2}
{}

#### bool

Judgment: $b:T$

\logicRule
{}
{b:\mathit{Bool}}
{}

#### int

Judgment: $i:T$

\logicRule
{}
{i:\mathit{Int}}
{}
We have proven in theorem \ref{ex:int} that $\mathit{Nat}$ is isomorph to $\mathbb{N}$. Is should be trivial to therefore conclude that $\mathit{Int}$ is isomorph to $\mathbb{Z}$. And therefore this rule is justified.

#### list-exp

Judgment: $\Gamma,\Delta\vdash le:\mathit{List} \ T$

\logicRule
{}
{\Gamma,\Delta\vdash \mf{""}:\forall a. \mathit{List} \ a}
{}

\logicRule
{\Gamma,\Delta\vdash e:T\quad
\Gamma,\Delta\vdash le:\mathit{List} \ T\quad
}
{\Gamma,\Delta\vdash e \ \mf{","} \ le:\mathit{List} \ T}
{}

#### exp

Judgment: $\Gamma,\Delta\vdash e:T$

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"not"}:\mathit{Bool}\to \mathit{Bool}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{}

\logicRule
{
\Gamma,\Delta\vdash e_1: T_1\quad
\Gamma,\Delta\vdash e_2: T_1 \to T_2
}
{\Gamma,\Delta\vdash e_1 \ \mf{"|>"} \ e_2:T_2}
{}

\logicRule
{
\Gamma,\Delta\vdash e_1: T_1 \to T_2\quad
\Gamma,\Delta\vdash e_2: T_2 \to T_3
}
{\Gamma,\Delta\vdash e_1 \ \mf{">>"} \ e_2:T_1 \to T_3}
{}

\logicRule
{
\Gamma,\Delta\vdash e_1:\textit{Bool}\quad
\Gamma,\Delta\vdash e_2: T\quad
\Gamma,\Delta\vdash e_3: T
}
{\Gamma,\Delta\vdash\mf{"if"} \ e_1  \ \mf{"then"} \ e_2 \ \mf{"else"} \ e_3:T}
{}

\logicRule
{\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}
}
{\Gamma,\Delta\vdash\mf{"\{"} lef \mf{"\}"}: \{a_1:T_1,\dots,a_n:T_n\}
}
{}

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"\{\}"}:\{\}
}
{}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}\\
\Gamma,\Delta\vdash \Delta(a) \sqsubseteq T_0\quad
T_0=\{a_1:T_1,\dots,a_n:T_n,\dots \}
\end{gathered}
}
{\Gamma,\Delta\vdash\mf{"\{"} \ a \ \mf{"|"} \ lef \ \mf{"\}"}:T_0}
{}
Since Elm version 0.19, released in 2018, setters are not allowed to change the type of a field in a record.

\logicRule
{(a_1,\{a_2:T,\dots\})\in\Delta
}
{\Gamma,\Delta\vdash a_1 \mf{"."} a_2:T}
{}

\logicRule
{\begin{gathered}
(a,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash e_1:T_1\quad
mes:T_1\vdash a:T_1\\
\Gamma,\text{insert}_\Delta(\{(a,T_1)\})\vdash e_2:T_2
\end{gathered}
}
{\Gamma,\Delta\vdash\mf{"let"} \ mes \ a \mf{"="} \ e_1 \ \mf{"in"} \ e_2: T_2
}
{}

\logicRule
{\Gamma,\Delta\vdash e_1: T_1\quad
\Gamma,\Delta,T_1\vdash lc:T_2
}
{\Gamma,\Delta\vdash\mf{"case"} \ e_1 \ \mf{"of" "["} \ lc \ \mf{"]"}: T_2
}
{}

\logicRule
{\Gamma,\Delta\vdash e_1: T_1\to T_2\quad
\Gamma,\Delta\vdash e_2: T_1
}
{\Gamma,\Delta\vdash e_1 \ e_2: T_2}
{}

\logicRule
{b:T}
{\Gamma,\Delta\vdash b : T}
{}

\logicRule
{i:T}
{\Gamma,\Delta\vdash i:T}
{}

\logicRule
{\Gamma,\Delta\vdash le:T
}
{\Gamma,\Delta\vdash\mf{"["} \mathit{le} \mf{"]"}: T}
{}

\logicRule
{\Gamma,\Delta\vdash e_1:T_1\quad
\Gamma,\Delta\vdash e_2:T_2
}
{\Gamma,\Delta\vdash\mf{"("} \ e_1 \ \mf{","} \ e_2 \mf{")"}:(T_1,T_2)}
{}

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\text{insert}_\Delta(\Theta)\vdash e: T_2
}
{\Gamma,\Delta\vdash\mf{"\textbackslash"} p \mf{"->"} e: T_1\to T_2}
{}
In Elm function arguments may be pattern matched, this mostly used to "unwrap" a type, meaning to bind contained elements to variables.

\logicRule
{\Delta(c)\sqsubseteq T
}
{\Gamma,\Delta\vdash c: T}
{}

\logicRule
{\Delta(a)\sqsubseteq T
}
{\Gamma,\Delta\vdash a: T}
{}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now check the type $T_0 = \forall a.\mathit{List} \ a \to \mathit{List} \ a$ of the `reverse` function for $\Gamma = \Delta = \varnothing$, $\Delta = \varnothing$. The body of the $reverse$ function is as follows:

\begin{lstlisting}[language=elm]
foldl (::) []
\end{lstlisting}

\begin{center}
\small
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\varnothing,\varnothing\vdash \mf{"foldl"}:T_2$}
    \AxiomC{}
  \UnaryInfC{$\varnothing,\varnothing\vdash \mf{"(::)"}:\forall a.\mathit{List} \ a \to \mathit{List} \ a$}
  \BinaryInfC{$\varnothing,\varnothing\vdash \mf{"foldl (::)"}:T_1$}
      \AxiomC{}
    \UnaryInfC{$\varnothing,\varnothing\vdash \mf{""}:\forall a.a$}
  \UnaryInfC{$\varnothing,\varnothing\vdash \mf{"[]"}:\forall a.\mathit{List} \ a$}
\BinaryInfC {$\varnothing,\varnothing\vdash  \mf{"foldl (::) []"}:T_0$}
\end{prooftree}
\end{center}

where
$T_1 = \forall a.\mathit{List} \ a \to \mathit{List} \ a \to \mathit{List} \ a$ and 
$T_2= \forall a.(\mathit{List} \ a \to \mathit{List} \ a)\to \mathit{List} \ a \to \mathit{List} \ a \to \mathit{List} \ a$.
```