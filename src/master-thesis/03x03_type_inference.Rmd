\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

In the first section of this chapter we defined a type system, in the second section we introduced a syntax for our language. Now we want to define rules how to obtain the type of a given program written in our language.

### Typing Judgments

A type system is a set of inference rules to derive various kinds of typing judgments. These _inference rules_ have the following form

$$
\frac
{P_1 \dots P_n}
{C}
$$
where the judgments $P_1$ up to $P_n$ are the premises of the rule and the judgment $C$ is its conclusion.

We can read it in two ways:

* "if all premises hold then the conclusion holds as well" or
* "to prove the conclusion we need to prove all premises"

We will now provide a judgment for every production rule defined in the last section. Ultimatly, we will have a judgment $p:T$ which indicates that a program $p$ is of a type $T$ and therefore well-formed.

#### Type Signature Judgments

For type signature judgments, let $\Gamma$ be a type context, $T\in\mathcal{T}$ and $a_i\in\mathcal{V},T_i\in\mathcal{T}$ for $i\in\mathbb{N}_1^n$ and $n\in\mathbb{N}$.

For $llv\in\mf{<list-lower-var>}$ the judgment has the form
$$llv:(a_1,\dots,a_n)$$
which can be read as "$llv$ defines the list $(a_1,\dots,a_n$)".

For $ltf\in\mf{<list-type-fields>}$ the judgment has the form
$$\Gamma\vdash ltf:\{a_1:T_1,\dots,a_n:T_n\}$$
which can be read as "given $\Gamma$, $ltf$ has the type $\{a_1:T_1,\dots,a_n:T_n\}$".

For $lt\in\mf{<list-type>}$ the judgment has the form
$$\Gamma\vdash lt:(T_1,\dots,T_n)$$
which can be read as "given $\Gamma$, $lt$ defines the list $(T_1,\dots,T_n)$".

For $t\in\mf{<type>}$ the judgment has the form
$$\Gamma\vdash t:T$$
which can be read as "given $\Gamma$, $t$ has the type $T$".

#### Pattern Judgments

For pattern judgments, let $\Gamma,\Delta$ and $\Theta$ be type contexts. Let $T\in\mathcal{T}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n$ and $n\in\mathbb{N}$.

For $lpl\in\mf{<list-pattern-list>}$ the judgment has the form
$$\Gamma,\Delta\vdash:\text{match}_\Theta ((T_1,\dots,T_n),lpl)$$
which can be read as "given $\Gamma,\Delta$, we can match $(T_1,\dots,T_n)$ with the pattern $lpl$ by using the context $\Theta$".

For $lps\in\mf{<list-pattern-sort>}$ the judgment has the form
$$\Gamma,\Delta\vdash\text{match}_\Theta ((T_1,\dots,T_n),lps)$$
which can be read as "Given $\Gamma$ and $\Delta$, we can match $(T_1,\dots,T_n)$ with the pattern $lps$ by using the context $\Theta$".

For $lpv\in\mf{<list-pattern-vars>}$ the judgment has the form
$$lpv:(a_1,\dots,a_n)$$
which can be read as "$lpv$ defines the list $(a_1,\dots,a_n)$".

For $p\in\mf{<pattern>}$ the judgment has the form
$$\Gamma,\Delta\vdash\text{match}_\Theta(T,p)$$
which can be read as "Given $\Gamma$ and $\Delta$, we can match $T$ with the pattern $p$ by using the context $\Theta$".

#### Expression Judgments

For expression judgments, let $\Gamma,\Delta$ be type contexts, $T\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n,n\in\mathbb{N}$.

For $lef\in\mf{<list-exp-field>}$ the judgment has the form
$$\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}$$
which can be read as "given $\Gamma$ and $\Delta$, $lef$ has the type $\{a_1:T_1,\dots,a_n:T_n\}$".

For $mes\in\mf{<maybe-exp-sign>}$ the judgment has the form
$$mes:T_1\vdash a:T_2$$
which can be read as "given that $mes$ has the type $T_1$, $a$ has the type $T_2$".

For $lc\in\mf{<list-case>}$ the judgment has the form
$$\Gamma,\Delta,T_1\vdash lc:T_2$$
which can be read as "given $\Gamma$ and $\Delta$ and a type $T_1$, $lc$ has the type $T_2$".

For $b\in\mf{<bool>}$ the judgment has the form
$$b:T$$
which can be read as "$b$ has the type $T$".

For $i\in\mf{<int>}$ the judgment has the form
$$e:T$$
which can be read as "$i$ has the type $T$".

For $le\in\mf{<list-exp>}$ the judgment has the form
$$\Gamma,\Delta\vdash le:T$$
which can be read as "given $\Gamma$ and $\Delta$, $le$ has the type $\mathit{List} \ T$".

For $e\in\mf{<exp>}$ the judgment has the form
$$\Gamma,\Delta\vdash e:T$$
which can be read as "given $\Gamma$ and $\Delta$, $e$ is of type $T$".

If the type $T$ is known then we talk about _type checking_ else we call the process of finding the judgment _type inference_.

#### Statement Judgments

For statement judgments, let $\Gamma,\Gamma_1,\Gamma_2,\Delta,\Delta_1,\Delta_2$ be a type contexts, $T,T_1,T_2\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i,A_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n$
and $T_{i,j}\in\mathcal{T}$ for $i\in\mathbb{N}_0^n,n\in\mathbb{N},j\in\mathbb{N}_0^{k_i}$ and $k_i\in\mathbb{N}$.

For $lss\in\mf{<list-statement-sort>}$ the judgment has the form
$$lss:((c_1:(T_{1,1}, \dots,T_{1,k_1}),T'_1),\dots,(c_n:(T_{n,1}, \dots,T_{n,k_n}),T'_n))$$
which can be read as "$lss$ is a tuple of sorts $c_i$ for $i\in\mathbb{N}_1^n$ that each define a list $(T_{i,1},\dots,T_{i,k_i})$ and provide a curresponding constructor function with type $T'_i$".

For $mss\in\mf{<maybe-statement-sign>}$ the judgment has the form
$$mss:T_1\vdash a:T_2$$
which can be read as "$a$ has the type $T_2$ under the assumtion that $mss$ has the type $T_1$".

For $ls\in\mf{<list-statement>}$ the judgment has the form
$$\Gamma_1,\Delta_2,ls\vdash \Gamma_2,\Delta_2$$
which can be read as "the list of statements $ls$ maps $\Gamma_1$ to $\Gamma_2$ and $\Delta_1$ to $\Delta_2$".

For $s\in\mf{<statement>}$ the judgment has the form
$$\Gamma_1,\Delta_2,s\vdash \Gamma_2,\Delta_2$$
which can be read as "the statement $s$ maps $\Gamma_1$ to $\Gamma_2$ and $\Delta_1$ to $\Delta_2$".

For $mms\in\mf{<maybe-main-sign>}$ the judgment has the form
$$mms:T_1\vdash \text{main}:T_2$$
which can be read as "the main function has type $T_2$ under the assumtion that $mms$ has the type $T_1$".

For $\textit{prog}\in\mf{<program>}$ the judgment has the form
$$\textit{prog}:T$$
which can be read as "the program $prog$ is wellformed and has the type $T$".

### Auxiliary Definitions

We will use $(e,T)\in\Gamma$ and $(e,T)\in\Delta$ to denote that a tuple $(e,T)$ exists in $\Gamma$ or $\Delta$. We will also sometimes use a wildcard $\_$ instead of a T if we are only interested in e.

We will use $T_1 \sqsubseteq T_2$ for given types $T_1,T_2$ to denote that $T_1$ is more general than $T_2$.

We will use "$T \text{ is a mono type}$", $T \text{ is a type variable}$ and type equivalence $T_1 = T_2$ for two given types $T_1$ and $T_2$.

We will use ${a_1,\dots,a_n}=\text{free}(T)$ to get all free variables of $T$.

Additionally, we define

$$
\begin{aligned}
\mathit{Bool}&:=\mu \_.\mathit{True} | \mathit{False}\\
\mathit{Nat}&:=\mu C. 1 | \mathit{Succ} \ 1\\
\mathit{Int}&:=\mu \_. 0 \ | \ \mathit{Pos} \ Nat \ | \ \mathit{Neg} \ \mathit{Nat}\\
\mathit{List}&:=\forall a.\mu C. [ \ ] \ | \mathit{Cons} \ a \ C
\end{aligned}
$$