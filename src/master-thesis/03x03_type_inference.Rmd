\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

We will now discuss the methods used to infer a type from a given expression.

```{definition,name="Type of an expression"}
\begin{letIn}
$T \in\mathcal{T}$. Let $\Gamma$ be a type context. Let $e$ be arbitary.
\end{letIn}
We say $e$ _is of type_ $T$ _in the context of_ $\Gamma$ (Notation: $e:T$)$:\Leftrightarrow$
  
$$
e \in values_\Gamma(T)
$$
```

Next we will need the semantics of $mf{<type>}, namely a function that maps $\text{value}(\mf{<type>})$ to $\mathcal{T}$. Note that the general discussion about semantics will occur in a later section of this chapter.

```{definition,name="Semantics of <type>"}
\begin{letIn}
$n\in\mathbb{N}$. Let $t,t_1,t_2:\mf{<type>}$ and $c:\mf{<upper-var>}$.
Let $t_i:\mf{<type>}$ for all $i\in\mathbb{N}_3^n$ and $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$.Let $\Gamma$ be a type context. Let $\mathit{Nat}=\mu C.1 \ | \ \mathit{Succ} \ C$.
\end{letIn}
We define

$$
\begin{aligned}
  \syntax{.}_\Gamma:&\text{value}(\mf{<type>})\to\mathcal{T}\\
  \syntax{Bool}_\Gamma =& \mu\_.\mathit{True}\ | \ \mathit{False}\\
  \syntax{Int}_\Gamma =& \mu\_.0 \ | \ \mathit{Pos} \ \mathit{Nat} | \mathit{Neg} \ \mathit{Nat}\\
  \syntax{List}_\Gamma =& \forall a.\mu C.[ \ ] \ | \ \mathit{Cons} \ a \ C\\
  \syntax{"(" $t_1$ , $t_2$ ")"}_\Gamma =& \{1:\syntax{$t_1$}, 2: \syntax{$t_2$}\}\\
  \syntax{"\{\}"}_\Gamma =& \mathit{\{\}}\\
  \syntax{"\{" $v_1$ ":" $t_1$ "," $\dots$ "," $v_n$ ":" $t_n$ "\}"}_\Gamma =& \{v_1:\syntax{$t_1$}_\Gamma , \dots , v_n:\syntax{$t_n$}_\Gamma\}\\
  \syntax{$t_1$ "->" $t_2$}_\Gamma =& \syntax{$t_1$}_\Gamma \to \syntax{$t_2$}_\Gamma\\
  \syntax{$c \ t_1 \dots t_n$} =& [\syntax{$c$}]_\Gamma(a_1,\dots,a_n)
\end{aligned}
$$
We say $\syntax{.}_\Gamma$ is the _interpretation_ of \mf{<type>}. For any $t\in\mf{<type>}$,we call \(\syntax{$t$}_\Gamma\) the _semantic_ of $t$.
```

For this section we will also use a interpretation function for expressions

$$
\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A
$$
for some non empty set $A$. We will discuss the definition of such a function as well as the definition of $A$ in the next chapter. For now they will be arbitary.

```{definition,name="Variable Context"}
$\Delta:\mathcal{V} \nleftrightarrow \mathcal{T}$ is called the _variable context_.
```

Types are typically infered using so called _inference rules_. Using these rules we can construct a truth tree, who's leafs are axioms, to prove that $\Delta\vdash\syntax{e}:T$ for an expression $e$, a type $T$, a variable context $\Delta$ and a interpretation function for expressions $\Delta$. Such a proving process is called _type checking_. It is also possible to find to most general $T$ such that $\Delta\vdash\syntax{e}:T$ using the inference rules. This is called _type inference_ \cite{Types_and_Programming_Languages}.

There are two universial inference rules for any Hindley-Milner type system.

```{definition,name="Instantiation, Generalization"}
\begin{letIn}
$T',T\in\mathcal{T}$ and $e\in\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})$. Let $a$ be a type variable. Let $\Delta$ be a variable context. Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$
\end{letIn}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Gamma,\Delta\vdash\syntax{e}:T'
}
{\Gamma,\Delta\vdash \syntax{e}:T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash \syntax{e}:T
}
{\Gamma,\Delta\vdash \syntax{e}:\mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be infered, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be infered, then the same holds for a poly type, binding the free variable.

### Type inference for statement

The inference Rules for statements are as follows.

```{definition,name="type inference for statement"}
\begin{letIn}
$n,m\in\mathbb{N}$. Let $k_i\in\mathbb{N}$ for all $i\in\mathbb{N}_1^m$. Let $T,T_1,T_2,T_3:\mathcal{T}$ Let $v:\mf{<lower-var>},e:\mf{<exp>},t:\mf{<type>}$. Let $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $s:\mf{<statement>}$. Let $c:\mf{<lower-var>}$ and $c_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^m$. Let $t_{i,j}:\mf{<type>}$ for all $i\in\mathbb{N}_1^m$ and $j\in\mathbb{N}_1^{k_i}$.
Let $\Gamma$ be a type context and $\Delta$ a variable context. Let $A$ be a set and
$\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}
The inference rules for statements are defined in table \ref{tab:inf_state}.
```

\tablefirsthead{Table \ref{tab:inf_state}: Inference rule for statements\\ \hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}
\label{tab:inf_state}
& \\
\logicRule
{(v,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash\syntax{$e$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\vdash\syntax{$s$}:T_2\}
}
{\Delta,\Gamma\vdash\syntax{$v$ "=" $e$ ";" $s$}:T_2
}
{TConstant}

\logicRule
{
(v,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash\syntax{$e$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\vdash\syntax{$s$}:T_2\}\quad
\syntax{$t$}_\Gamma = T_1
}
{\Gamma,\Delta\vdash\syntax{$v$ ":" $t$ ";" $v$ "=" $e$ ";" $s$}:T_2
}
{TConstant2}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\syntax{t}_\Gamma=T_1\\
T_2 \text{ is a mono type}\quad\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\\
\forall v_1. \dots \forall v_n. T_2 = T_1\quad
\Gamma\cup\{(c,(T_1))\},\Delta\cup\{(c,T_1)\}\vdash\syntax{s}:T_3
\end{gathered}
}
{\Gamma\Delta\vdash\syntax{"type alias" $c$ $v_1 \dots v_n$ "=" $t$ ";" $s$ }:T_3}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\\
\mu C.c_1 \ \syntax{$t_{1,1}$}_\Gamma \ \dots \ \syntax{$t_{1,k_1}$}_\Gamma \ | \ \dots \ | \ c_m \ \syntax{$t_{m,1}$}_\Gamma \ \dots \ \syntax{$t_{m,k_m}$}_\Gamma=T_2\\
\forall v_1. \dots \forall v_n. T_2 = T_1\quad
\Gamma\cup\{(c,(T_1))\},\Delta\cup\{(c,T_1)\}\vdash\syntax{s}:T_3
\end{gathered}
}
{\Gamma,\Delta\vdash\Bigg\llbracket
\begin{aligned}
&\mf{"type"} \ c \ v_1 \dots v_n \mf{"="}\\
&c_1 \ t_{1,1} \dots t_{1,k_1} \ | \ \dots | \ c_m \ t_{m,1} \dots t_{m,k_m} \mf{";"} s
\end{aligned}\Bigg\rrbracket:T_3
}
{TCustomType}

& \\

\logicRule
{\Gamma,\Delta\vdash\syntax{$e$}:T}
{\Gamma,\Delta\vdash\syntax{"main" $e$}:T}
{TMain}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e$}:T\quad
\syntax{$t$}_\Gamma=T
}
{\Gamma,\Delta\vdash\syntax{"main :" $t$ "; main" $e$}:T}
{TMain2}
\end{xtabular*}
\end{center}

\begin{description}
\item[TConstant,TConstant2] Check if $v$ is still free then add $(v,T_1)$ to the variable context and evulate the next statement.
\item[TAlias] Check if $c$ is still free. $\{v_1,\dots,v_2\}$ need to be set set of all free variables in $T_2$. If all checks are valid we add $(v,T_1)$ to the type context and evaluate the next satement.
\item[TCustomType] Similar to [TAlias] we add $(v,T_1)$ to the type context with the only difference that we explicitly define $T_1$ as a algebraic type.
\item[TMain,TMain2] Evaluate $e$.
\end{description}

### Type inference for expressions

For the inference rules of expression we will need to introduce a pattern matching function:

$$
\text{match}_\Theta:\text{value}(\mf{<type>})\times\text{value}(\mf{<exp>})\to\{\mathit{True},\mathit{False}\}
$$
for a given substitution $\Theta$.

The function will be defined afterwards. For now its definition will be arbitrary.

```{definition,name="type inference for expressions"}
\begin{letIn}
$n\in\mathbb{N}$. Let $T,T_0,T_1,T_2,T_3:\mathcal{T}$.
Let $v,v_0,v_1,v_2,v_3:\mf{<lower-var>}$.
Let $a,a_0,a_1,a_2,a_3:\mathcal{V}$
Let $e,e_0,e_1,e_2,e_3:\mf{<exp>}$.
Let $T_i:\mathcal{T}$ for all $i\in\mathbb{N}_4^n$.
Let $v_i:\mf{<lower-var>}$ for $i\in\mathbb{N}_4^n$.
Let $a_i:\mathcal{V}$ for all $i\in\mathbb{N}_4^n$.
Let $e_i:\mf{<exp>}$ for all $i\in\mathbb{N}_4^n$.
Let $p:\mf{<pattern>}$,
$\mathit{le}:\mf{<list.exp>}$,
$\mathit{lc}:\mf{<list-case>}$,
$\mathit{lef}:\mf{<list-exp-field>}$,
$c:\mf{<upper-var>}$ and
$t:\mf{<type>}.$
Let $\Gamma$ be a type context and $\Delta$ a variable context. Let $A$ be a set and
$\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}

The inference rules for expressions can be found in table \ref{tab:inf_exp}.
```

\tablefirsthead{Table \ref{tab:inf_exp}: Inference rule for expressions\\ \hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}
\label{tab:inf_exp}
&\\
\logicRule
{(v,T)\in\Delta
}
{\Gamma,\Delta\vdash\syntax{$v$}:T}
{TVariable}

\logicRule
{(v,T)\in\Delta
}
{\Gamma,\Delta\vdash\syntax{$c$}:T}
{TConstructor}

\logicRule
{\Gamma,\Delta\vdash match_\Theta(T_1,p)\quad
\Gamma,\Delta\cup\Theta\vdash\syntax{$e$}:T_2
}
{\Gamma,\Delta\vdash\syntax{"\textbackslash" $p$ "->" $e$}:T_1\to T_2}
{TLambda}

\logicRule
{\syntax{$e_1$}_\Gamma:T_1\quad
\syntax{$e_2$}_\Gamma:T_2
}
{\Gamma,\Delta\vdash\syntax{"(" $e_1$ "," $e_2$ ")"}:\{1:T_1, 2:T_2\}}
{TTuple}

\logicRule
{}
{\Gamma,\Delta\vdash\syntax{"[]"}:\forall a.\mathit{List} \ a}
{TEmptyList}

\logicRule
{
\Gamma\vdash\syntax{$e$}:T
}
{\Gamma\vdash\syntax{"[" $e$ "]"}: \mathit{List} \ T}
{TSingleList}

\logicRule
{
\Gamma\vdash\syntax{$e$}:T\quad
\Gamma\vdash\syntax{"[" $\mathit{le}$ "]"}:\mathit{List} \ T
}
{\Gamma\vdash\syntax{"[" $e$ "," $\mathit{le}$ "]"}: \mathit{List} \ T}
{TList}

\logicRule
{e:\mf{<int>}}
{\Gamma,\Delta\vdash\syntax{$e$}:\mathit{Int}}
{TInt}

\logicRule
{e:\mf{<bool>}}
{\Gamma,\Delta\vdash\syntax{$e$}:\mathit{Bool}}
{TBool}

\logicRule
{\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\to T_2\quad
\Gamma,\Delta\vdash\syntax{$e_2$}:T_1
}
{\Gamma,\Delta\vdash\syntax{$e_1$ $e_2$}:T_2}
{TCall}

\logicRule
{\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Gamma,\Delta\cup\Theta\vdash\syntax{$e_2$}:T_2
}
{\Gamma\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ "]"}:T_2}
{TSingleCaseOf}

\logicRule
{\begin{gathered}
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Gamma\cup\Theta\vdash\syntax{$e_2$}:T_2\quad\\
\Gamma\vdash\syntax{"case" $e_1$ "of" "[" $\mathit{lc}$ "]"}:T_2
\end{gathered}
}
{\Gamma\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ ";" $\mathit{lc}$ "]"}:T_2}
{TCaseOf}

\logicRule
{
\syntax{$v$}=a\quad
(a,\_)\not\in\Gamma\quad
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\cup\{(a,T_1)\}\vdash\syntax{$e_2$}:T_2
}
{
\Gamma\vdash\syntax{"let" $v$ "=" $e_1$ "in" $e_2$}:T_2
}
{TLetIn}

\logicRule
{\begin{gathered}
\syntax{$v$}=a\quad
(a,\_)\not\in\Gamma\quad
\syntax{$v$ ":" t}:T_1\\
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\cup\{(a,T_1)\}\vdash\syntax{$e_2$}:T_2
\end{gathered}
}
{\Gamma\vdash\syntax{"let" $v$ ":" $t$ ";" $v$ "=" $e_1$ "in" $e_2$}:T_2
}
{TLetIn2}

\logicRule
{\syntax{$v_1$}=a_1\quad
\syntax{$v_2$}=a_2\quad
(a_1,\{a_2:T,\dots\})\in\Gamma
}
{\Gamma\vdash\syntax{$v_1$ "." $v_2$}:T}
{TGetter}

\logicRule
{\begin{gathered}
\syntax{$v_1$}=a_1\quad
\syntax{$v_2$}=a_2\quad
\Gamma\vdash\syntax{$e$}:T_2\\
T_1=\{a_2:T_2,..\}\quad
(a_1,T_1)\in\Gamma
\end{gathered}
}
{\Gamma\vdash\syntax{"\{" $v1$ "|" $v2$ "=" $e$ "\}"}:T_1}
{TSingleSetter}

\logicRule
{\begin{gathered}
\syntax{$v_1$}=a_1\quad
\syntax{$v_2$}=a_2\quad
\Gamma\vdash\syntax{$e$}:T_2\\
T_1=\{a_2:T_2,..\}\quad
(a_1,T_1)\in\Gamma\quad
\Gamma\vdash\syntax{$\mathit{lef}$}:T_1
\end{gathered}
}
{\Gamma\vdash\syntax{"\{" $v$ "|" $v2$ "=" $e$ "," $\mathit{lef}$:<list-exp-field> "\}"}:T_1}
{TSetter}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{TEmptyRecord}

\logicRule
{\forall i \in\mathbb{N}_1^n.\syntax{$v_i$}=a_i
\Gamma\vdash\forall i \in\mathbb{N}_1^n.\syntax{$e_i$}:T_i
}
{\Gamma\vdash\syntax{"\{" $v_1$ "=" $e_1$ "," \dots "," $v_n$ "=" $e_n$ "\}"}:\{v_1:T_1,\dots,v_n:T_n\}
}
{TRecord}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:\textit{Bool}\quad
\Gamma\vdash\syntax{$e_2$}:T\quad
\Gamma\vdash\syntax{$e_3$}:T
}
{\Gamma\vdash\syntax{"if" $e_1$ "then" $e_2$ "else" $e_3$}:T}
{TIfElse}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:T_1 \to T_2\quad
\Gamma\vdash\syntax{$e_2$}:T_2 \to T_3
}
{\Gamma\vdash\syntax{$e_1$ ">>" $e_2$}:T_1 \to T_3}
{TComposition}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\syntax{$e_2$}:T_1 \to T_2
}
{\Gamma\vdash\syntax{$e_1$ "|>" $e_2$}:T_2}
{TPipe}

\logicRule
{}
{\vdash\syntax{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{}
{\vdash\syntax{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\vdash\syntax{"not"}:\mathit{Bool}\to \mathit{Bool}}
{TNot}

\logicRule
{}
{\vdash\syntax{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\vdash\syntax{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\vdash\syntax{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\vdash\syntax{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\vdash\syntax{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\vdash\syntax{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\vdash\syntax{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\vdash\syntax{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\end{xtabular*}
\end{center}

\begin{description}
\item[TVariable,TConstructor] Interprete the syntactical variable and find the type in the context.
\item[TLambda] Elm allows the parameters of a function to be pattern matched. Therefore we first need to find a patching type $T_1$ and can then infer the type of $e$ by including the additional bindings $\Theta$ to the context.
\item[TEmptyList] The empty list is a literal for every list, therefore we can infer the most general of all lists.
\item[TList] Recursively we check that every element has the same type.
\item[TInt,TBool] The type of Literals infered without any restrictions.
\item[TCall] The first expression needs to be a function that the the second type can be passed to.
\item[TSingleCaseOf,TCaseOf] First match the type of the expression $e_1$ to the pattern, then use the additional bindings $\Theta$ to obtain the type of $e_2$. As all patterns need to have the same type, we can then recursively check the other patterns as well.
\item[TLetIn,TLetIn2] The variable $a$ may not have a value assined in the conext $\Gamma$. If so, we can infer the type $T_1$ of $e_1$ and add $(a,T_1)$ to the context before we evaluate $e_2$. For $[TLetIn2]$ we already the type is already given as $t$. Note that $t$ can more specific as the type we would usually infer.
\item[TGetter] The second variable $a_2$ is a label of the record, that is bound to $a_1$.
\item[TSingleSetter,TSetter] Setters can not change the type in Elm. But we still need to ensure that the field are also correctly typed.
\item[TElmptyRecord] The empty record is a type with just a single element.
\item[TRecord] Each field and its value must be given at the same time. Thats why we can not use a recursive definition.
\item[TIfElse] The first expression $e_1$ needs to be a boolean and the branches $e_2,e_3$ must have the same type.
\item[TComposition,TPipe] The pipe applies the first expression to the second. The composition is similar to the pipe, but results in a function.
\item[TOr,TAnd,TNot,TEqual,TDivide,TMultiply,TMinus,TPlus,TCons,TFoldl] These functions can be seen as lambda function literals.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl
    (::)
    []
\end{lstlisting}

We will add brackets around $foldl (::)$ to make it more readable. The bracket do not change the type inference or evaluation. Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```

#### type inference for Patterns

For pattern matching we do not only want to infer a type that matches the pattern, but also find all substitutions for doing so. We will see that patterns also allow for variable declarations by using the `as` keyword.

```{definition,name="Type inference for pattern matching"}
\begin{letIn}$\Theta\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
p:\mf{<pattern>};\quad
v:\mf{<lower-var>};\quad
T:\mathcal{T};\\
\forall i\in\mathbb{N}_0^2.p_i:\mf{<pattern>};\quad
\forall i\in\mathbb{N}_3^n.p_i:\mf{<pattern>};\\
\forall i\in\mathbb{N}_0^n.v_i:\mf{<lower-var>};\quad
\forall i\in\mathbb{N}_0^n.T_i:\mathcal{T};\\
\forall i\in\mathbb{N}_0^3.\Theta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
\forall i\in\mathbb{N}_4^n.\Theta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\\
lpl:\mf{<list-pattern-list>}$
\end{letIn}

we say a pattern $p$ matches a type $T$ for the context $\Gamma$ using the bindings $\Theta$ if $\Gamma\vdash \text{match}_\Theta(T,p)$.

$\Theta$ contains the minimal substitutions and variable bindings needed to match the type to the pattern.

Instantiation and Generalization applies to pattern matching as well.

\begin{center}
\begin{tabular}{c l}
\logicRule
{
 T' \sqsubseteq T\quad
 \Gamma\vdash \text{match}_\Theta(T',\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Theta(T,\syntax{e})
}
{PInstantiation}

\logicRule
{(a,\_)\not\in\Gamma\quad
\Gamma\vdash \text{match}_\Theta(T,\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Theta(\forall a.T,\syntax{e})
}
{PGeneralization}
\end{tabular}
\end{center}

The type inference rules for pattern matching are as follows

\begin{center}
\begin{xtabular}{c l}
\logicRule
{}
{\vdash \text{match}_\varnothing(\mathit{Bool},$\_$:\syntax{<bool>})}
{PBool}

\logicRule{}
{\vdash \text{match}_\varnothing(\mathit{Int},$\_$:\syntax{<int>})}
{PInt}

\logicRule{}
{\vdash \text{match}_\varnothing(\forall a.\mathit{List} \ a,\syntax{"[]"})}
{PEmptyList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T_1,\syntax{$p$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(T_2,\syntax{"[" $lpl$ "]"})\\
\Theta_1\cap\Theta_2=\varnothing\quad
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\\
\Theta_1\cup\Theta_2=\Theta_3\quad
T_2 = \textit{List} \ T_1
\end{gathered}
}
{\Gamma\vdash \text{match}_{\Theta_3}(T_2,\syntax{"[" $p$ "," $lpl$ "]"}
}
{PList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T_1,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(T_2,\syntax{$p_2$})\quad\\
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\quad
\Theta_1\cup\Theta_2=\Theta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Theta_3}(T_1 \times T_2,\syntax{"(" $p_1$ "," $p_2$ ")"})
}
{PTuple}

\logicRule
{\syntax{$v$}=a\quad
(a,\_)\not\in\Gamma\quad
\Theta = \{(a,T)\}
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{$v$})
}
{PVariable}

\logicRule
{
\syntax{$v$}=a\quad
(v,T)\in\Gamma\quad
}
{
\Gamma\vdash\text{match}_\varnothing(T,\syntax{$v$})
}
{PSingleApplication}

\logicRule
{
\begin{gathered}
\Gamma\vdash \forall i\in\mathbb{N}_1^n.\text{match}_{\Theta_i}(\syntax{$p_i$}:T_i)\quad\\
(p_0,T_1\to \dots \to T_n\to T_0)\in\Gamma\quad\\
\forall i\in\mathbb{N}_1^n.\forall j\in\mathbb{N}_1^n.i\neq j \Rightarrow\forall (a_1,\_)\in \Theta_i,(a_2,\_)\in\Theta_j.a_1 \neq a_2\\
\Theta_0 = \bigcup_{i\in\mathbb{N}_1^n}\Theta_i
\end{gathered} 
}
{
\Gamma\vdash \text{match}_{\Theta_0}(T_0,\syntax{$p_0$ $p_1$ .. $p_n$})
}
{PApplication}
\logicRule
{(v,\_)\not\in\Gamma\quad
(v,T)\in\Theta\quad
\Gamma\vdash \text{match}_{\Theta\backslash\{(v,T)\}}(T,\syntax{$p$})
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{$p$ "as" $v$})}
{PAs}

\logicRule
{}
{\vdash \text{match}_\varnothing(\{\},\syntax{"\{\}"})}
{PEmptyRecord}

\logicRule
{
\begin{gathered}
k:\mathbb{N}_1^m\to\mathbb{N}_1^n\quad
k \text{ is injective}\quad\quad
\forall i\in\mathcal{N}_1^n.(v_{k(i)},\_)\not\in\Gamma\\
\Theta = \bigcup_{i\in\mathbb{N}_1^n} \{(v_{k(i)},T_{k(i))}\}\quad
T = \{v_1:T_1,\dots,v_n:T_n\}
\end{gathered}
}
{\Gamma\vdash \text{match}_\Theta(T,\syntax{"\{" $v_{k_1}$ "," $\dots$ "," $v_{k_m}$ "\}"})
}
{PRecord}

\logicRule
{
\begin{gathered}
\Gamma\vdash \text{match}_{\Theta_1}(T,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Theta_2}(List \ T,\syntax{$p_2$})\quad\\
\forall (a_1,\_)\in \Theta_1,(a_2,\_)\in\Theta_2.a_1 \neq a_2\quad
\Theta_1\cup\Theta_2=\Theta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Theta_3}(\textit{List} \ T,\syntax{$p_1$ "::" $p_2$})
}
{PHeadAndTail}

\logicRule
{}
{\Gamma\vdash \text{match}_\varnothing(\forall a. a,\syntax{"\_"})}
{PWildcard}



\end{xtabular}
\end{center}
```

\begin{description}
\item[PBool,PInt,PEmptyList] The type of literals can be infered without any restrictions.
\item[PList,PTuple] Recursively we need to ensure that every element has the same type. Additionally every binding needs to be unique.
\item[PVariable] If the variable is not yet bound in context, will can be added to $\Theta$.
\item[PSingleApplication] A single application ist just a Terminal. Its type is defined in the context $\Gamma$.
\item[PApplication] For a generell application the constructor can again be found in the context.Again we need to ensure that the elements of all $\Theta_i$ sets are unique in the first element.
\item[PAs] We bind the variable in $\Theta$ and then ensure that it can not be bound again. Note that binding are done bottom up, so $\Theta$ contains all bindings that occure in $p$.
\item[PEmptyRecord] The empty record ist just a literal.
\item[PRecord] Here the variable names and the field names are the same. For every field that we name, the type will be bound to the variable that has the same name. This requires that all the field names are not yet bound in $\Gamma$.
\item[PHeadAndTail] This is the same as $\mathit{[PList]}$ with the difference that now we intentially look at one elment at a time, where as PList has already given the length of the list.
\item[PWildcard] Anything is allowed, thus we infere the smalles type: $\forall a.a$.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. Now we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$ and $\Gamma = \varnothing$.

We start by proving $\vdash \text{match}_\varnothing(\mathit{List} \ \mathit{Int},\syntax{"\_"})$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[PWildcard]}$}
  \UnaryInfC{$\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
\RightLabel{$\mathit{[PInstantiation]}$}
\UnaryInfC{$\vdash \text{match}_\varnothing(\textit{List} \ \text{Int},\syntax{"\_"})$}
\end{prooftree}
\end{center}

Next we prove $\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{\(a\):<lower-var> " :: \_"})$ for $\Theta=\{(a,\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\vdash \text{match}_\Theta(\textit{Int},\syntax{a})$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Theta\cap\varnothing=\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\textit{List} \ \textit{Int},\syntax{"\_"})$}
\RightLabel{$(1)$}
\TrinaryInfC{$\vdash \text{match}_\Theta(\textit{List} \ \textit{Int},\syntax{a:<lower-var> " :: \_"})$}
\end{prooftree}
\end{center}
$(1) \mathit{[PHeadAndTail]}, (2) \mathit{[PInstantiation]}, (3) \mathit{[PWildcard]},(4) \mathit{[PVariable]}$
```