\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

In the first section of this chapter we defined a type system, in the second section we introduced a syntax for our language. Now we want to define rules how to obtain the type of a given program written in our language.

### Typing Judgments

A type system is a set of inference rules to derive various kinds of typing judgments. These _inference rules_ have the following form

$$
\frac
{P_1 \dots P_n}
{C}
$$
where the judgments $P_1$ up to $P_n$ are the premises of the rule and the judgment $C$ is its conclusion.

We can read it in two ways:

* "If all premises hold then the conclusion holds as well" or
* "To prove the conclusion we need to prove all premises".

We will now provide a judgment for every production rule defined in the last section. Ultimately, we will have a judgment $p:T$ which indicates that a program $p$ is of a type $T$ and therefore well-formed.

#### Type Signature Judgments

For type signature judgments, let $\Gamma$ be a type context, $T\in\mathcal{T}$ and $a_i\in\mathcal{V},T_i\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $n\in\mathbb{N}$.

For $llv\in\mf{<list-lower-var>}$ the judgment has the form
$$llv:(a_1,\dots,a_n)$$
which can be read as "$llv$ defines the list $(a_1,\dots,a_n$)".

For $ltf\in\mf{<list-type-fields>}$ the judgment has the form
$$\Gamma\vdash ltf:\{a_1:T_1,\dots,a_n:T_n\}$$
which can be read as "given $\Gamma$, $ltf$ has the type $\{a_1:T_1,\dots,a_n:T_n\}$".

For $lt\in\mf{<list-type>}$ the judgment has the form
$$\Gamma\vdash lt:(T_1,\dots,T_n)$$
which can be read as "given $\Gamma$, $lt$ defines the list $(T_1,\dots,T_n)$".

For $t\in\mf{<type>}$ the judgment has the form
$$\Gamma\vdash t:T$$
which can be read as "given $\Gamma$, $t$ has the type $T$".

#### Pattern Judgments

For pattern judgments, let $\Gamma,\Delta$ and $\Theta$ be type contexts. Let $T\in\mathcal{T}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for all $i\in\mathbb{N}_0^n$ and $n\in\mathbb{N}$.

For $lpl\in\mf{<list-pattern-list>}$ the judgment has the form
$$\Gamma,\Delta\vdash:\text{match}_\Theta (\mathit{List} \ T,lpl)$$
which can be read as "given $\Gamma,\Delta$, we can match $\mathit{List} \ T$ with the pattern $lpl$ by using the context $\Theta$".

For $lps\in\mf{<list-pattern-sort>}$ the judgment has the form
$$\Gamma,\Delta\vdash\text{match}_\Theta ((T_1,\dots,T_n),lps)$$
which can be read as "given $\Gamma$ and $\Delta$, we can match $(T_1,\dots,T_n)$ with the pattern $lps$ by using the context $\Theta$".

For $lpv\in\mf{<list-pattern-vars>}$ the judgment has the form
$$lpv:(a_1,\dots,a_n)$$
which can be read as "$lpv$ defines the list $(a_1,\dots,a_n)$".

For $p\in\mf{<pattern>}$ the judgment has the form
$$\Gamma,\Delta\vdash\text{match}_\Theta(T,p)$$
which can be read as "given $\Gamma$ and $\Delta$, we can match $T$ with the pattern $p$ by using the context $\Theta$".

#### Expression Judgments

For expression judgments, let $\Gamma,\Delta$ be type contexts, $T\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for all $i\in\mathbb{N}_0^n,n\in\mathbb{N}$.

For $lef\in\mf{<list-exp-field>}$ the judgment has the form
$$\Gamma,\Delta\vdash lef:\{a_1:T_1,\dots, a_n:T_n\}$$
which can be read as "given $\Gamma$ and $\Delta$, $lef$ has the type $\{a_1:T_1,\dots,a_n:T_n\}$".

For $mes\in\mf{<maybe-exp-sign>}$ the judgment has the form
$$\Gamma,mes\vdash a:T$$
which can be read as "given $\Gamma$, $a$ has the type $T$ under the assumption $mes$".

For $lc\in\mf{<list-case>}$ the judgment has the form
$$\Gamma,\Delta,T_1\vdash lc:T_2$$
which can be read as "given $\Gamma$ and $\Delta$ and a type $T_1$, $lc$ has the type $T_2$".

For $b\in\mf{<bool>}$ the judgment has the form
$$b:T$$
which can be read as "$b$ has the type $T$".

For $i\in\mf{<int>}$ the judgment has the form
$$e:T$$
which can be read as "$i$ has the type $T$".

For $le\in\mf{<list-exp>}$ the judgment has the form
$$\Gamma,\Delta\vdash le:\mathit{List} \ T$$
which can be read as "given $\Gamma$ and $\Delta$, $le$ has the type $\mathit{List} \ T$".

For $e\in\mf{<exp>}$ the judgment has the form
$$\Gamma,\Delta\vdash e:T$$
which can be read as "given $\Gamma$ and $\Delta$, $e$ is of type $T$".

If the type $T$ is known then we talk about _type checking_ else we call the process of finding the judgment _type inference_.

#### Statement Judgments

For statement judgments, let $\Gamma,\Gamma_1,\Gamma_2,\Delta,\Delta_1,\Delta_2$ be a type contexts, $T,T_1,T_2\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i,A_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n$
and $T_{i,j}\in\mathcal{T}$ for $i\in\mathbb{N}_0^n,n\in\mathbb{N},j\in\mathbb{N}_0^{k_i}$ and $k_i\in\mathbb{N}$.

For $lss\in\mf{<list-statement-sort>}$ the judgment has the form
$$lss:(c_1:(T_{1,1}, \dots,T_{1,k_1}),\dots,c_n:(T_{n,1}, \dots,T_{n,k_n}))$$
which can be read as "$lss$ is a tuple of sorts $c_i$ for $i\in\mathbb{N}_1^n$ such that that each define a list $(T_{i,1},\dots,T_{i,k_i})$.

For $lsv\in\mf{<list-statement-var}$ the judgment has the form
$$lsv:(a_1,\dots,a_n)$$
which can be read as "$lsv$ describes the list $(a_1,\dots,a_n)$".

For $ls\in\mf{<list-statement>}$ the judgment has the form
$$\Gamma_1,\Delta_2,ls\vdash \Gamma_2,\Delta_2$$
which can be read as "the list of statements $ls$ maps $\Gamma_1$ to $\Gamma_2$ and $\Delta_1$ to $\Delta_2$".

For $mss\in\mf{<maybe-statement-sign>}$ the judgment has the form
$$\Gamma,mss\vdash a:T$$
which can be read as "given $\Gamma$, $a$ has the type $T_2$ under the assumption $mss$".

For $s\in\mf{<statement>}$ the judgment has the form
$$\Gamma_1,\Delta_1,s\vdash \Gamma_2,\Delta_2$$
which can be read as "the statement $s$ maps $\Gamma_1$ to $\Gamma_2$ and $\Delta_1$ to $\Delta_2$".

For $mms\in\mf{<maybe-main-sign>}$ the judgment has the form
$$\Gamma,mms\vdash \text{main}:T$$
which can be read as "the main function has type $T$ under the assumtion $mms$".

For $\textit{prog}\in\mf{<program>}$ the judgment has the form
$$\textit{prog}:T$$
which can be read as "the program $prog$ is wellformed and has the type $T$".

### Auxiliary Definitions

We will use $"T \text{ is a mono type}"$, $"T \text{ is a type variable}"$ and type equivalence $T_1 = T_2$ for two given types $T_1$ and $T_2$.

We will use ${a_1,\dots,a_n}=\text{free}(T)$ to get all free variables of $T$.

#### Instantiation, Generalization

The type system that we are using is polymorphic, meaning that whenever a judgment holds for a type, it will also hold for a more specific type. To counter this polymorphism we will force the types in a judgment to be unique by explicitly stating whenever we want to use a more specific or general type.

First we will use $\Delta(e)\sqsubseteq T :\Leftrightarrow (e,T_0)\in\Delta \land T_0 \sqsubseteq T$. The act of replacing $T_0$ with the more specific type $T$ is called _Instantiation_ and is typically in the text books introduced as an additional inference rule.

Second we will use a special form of union:
$$\begin{aligned}
\text{insert}_{\Delta_1}&(\Delta_2):=\\
&\Delta_1\cup\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
    (a,\forall b_1\dots\forall b_n.T')&
    \begin{matrix*}[l]
    (a,T)\in\Delta_2\\
    \land \ \forall\_ .\dots\forall\_ T' = T\\
    \land \ T' \text{ is a mono type}\\
    \land \ \{b_1,\dots,b_n\}=\{b\ |\ b\in\text{free}(T)\land (a,\_)\not\in\Delta_2\}
    \end{matrix*}\end{array}\end{Bmatrix*}
\end{aligned}$$
This definition essentially states that all quantfied variables of T, that occure in $\Gamma_2$, will be dropped and any free variables will be quantified. The act of removing a quantified variable that is already in the type context is called _Generalization_ and is also typically found as an inference rule in text books.

#### Predefined Types

Additionally, we define

$$
\begin{aligned}
\mathit{Bool}&:=\mu \_.\mathit{True} | \mathit{False}\\
\mathit{Nat}&:=\mu C. 1 | \mathit{Succ} \ C\\
\mathit{Int}&:=\mu \_. 0 \ | \ \mathit{Pos} \ Nat \ | \ \mathit{Neg} \ \mathit{Nat}\\
\mathit{List}&:=\forall a.\mu C. [ \ ] \ | \mathit{Cons} \ a \ C
\end{aligned}
$$