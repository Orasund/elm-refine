\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

In the first section of this chapter we definied a type system, in the second section we introduced a syntax for our language. Now we want to define rules how to obtain the type of a given program written in our langauge.

### Typing Judgments

To state that a program $p$ is of type $T$ (and therefor well-formed) we write

\begin{equation}
p:T
\end{equation}

We call such statements a judgment. Judgments are generally written in meta-language , thus we also need to provide a system of inference rules how to infer such a judgment. These _inferene rules_ have the following form

$$
\frac
{P_1 \dots P_n}
{C}
$$
where $P_1$ up to $P_n$ are premises and $C$ is a conclusion.

We can read it in both ways:

* "if all premises hold then the conclusion holds as well" or
* "to prove the conclusion we need to prove all premises"

The premises as well as the conclusion are sequents, meaning a meta-langauge statement in the following form

$$A_1,\dots,A_n \vdash B.$$

Such a sequent would be generally read as "If we know $A_1,\dots,A_n$, then we can prove B".

we will now provide a judgment for every production rule definied in the last section.

#### Type Signiture Judments

Let $\Gamma$ be a type context, $T\in\mathcal{T}$ and $a_i\in\mathcal{V},T_i\in\mathcal{T}$ for $i\in\mathbb{N}_1^n$.

For $l\in\mf{<list-lower-var>}$ the judgment is
$$l:(a_1,\dots,a_n).$$

For $l\in\mf{<list-type-fields>}$ the judgment is
$$\Gamma\vdash l:\{a_1:T_1,\dots,a_n:T_n\}.$$

For $l\in\mf{<list-type>}$ the judgment is
$$\Gamma\vdash l:(T_1,\dots,T_n)$$

For $t\in\mf{<txpe>}$ the judgment is
$$\Gamma\vdash t:T$$

#### Pattern Judgments

We will see that the initial judgment ($\syntax{e}\in \text{values}_\Gamma(T)$) is dependent on another context, this time for variables instead of types:

```{definition,name="Variable Context"}
$\Delta\in\mathcal{V} \nrightarrow \mathcal{T}$ is called the _variable context_.
```

We also introduce a new syntax for saying a value is of some type.
```{definition,name="type of value"}
\begin{letIn}
$T \in\mathcal{T}$. Let $\Gamma$ be a type context. Let $e$ be arbitary.
\end{letIn}
We say $e$ _is of type_ $T$ _in the context of_ $\Gamma$ (Notation: $e:_\Gamma T$)$:\Leftrightarrow$
  
$$
e \in \text{values}_\Gamma(T)
$$
  
Is $\Gamma = \varnothing$ then we may write $e:T$ instead of $e:_\Gamma T$.
```

The judgment in question can now be expressed more generally as

$$
\Delta\vdash\syntax{e}:_\Gamma T
$$
where $\Gamma$ is a type context, $\Delta$ is a variable context,  $e\in\text{values}_\Gamma(\mf{<program>})\cup\text{values}_\Gamma(\mf{<expression>})$ and $T$ is a type. Note that we originally assumed $\Delta = \varnothing$. Also, note that the values of `<program>` and `<expression>` are disjoint and therefore we will look at $e:\mf{<program>}$ and $e:\mf{<expression>}$ separately.

If the type $T$ is known then we talk about _type checking_ else we call the judgment a _type inference_. For inferring a type, the result is not necessary unique, that is why we might only want to find the most general type, meaning a type $T_1$ such that

$$
\underbrace{(\forall T_2\in\mathcal{T}\land T_1\sqsubseteq T_2.e:_\Gamma T_2)}_{T_1 \text{ is a infered type}} \land \underbrace{(\forall T_2\in\mathcal{T}\land T_2 \sqsubseteq T_1. \exists T_3\in\mathcal{T} \land T_2 \sqsubseteq T_3.\neg (e:_\Gamma T_3))}_{T_1 \text{ is sharp}}.
$$

### Auxiliary Definitions

We will need the semantics of $\mf{<type>}$, namely a function that maps $\text{values}_\Gamma(\mf{<type>})$ to $\mathcal{T}$.

```{definition,name="Semantics of <type>"}
\begin{letIn}
$n\in\mathbb{N}$. Let $t,t_1,t_2:\mf{<type>}$ and $c:\mf{<upper-var>}$.
Let $t_i:\mf{<type>}$ for all $i\in\mathbb{N}_3^n$ and $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $C$ be a symbol. Let $\Gamma$ be a type context. Let $\mathit{Nat}=\mu C.1 \ | \ \mathit{Succ} \ C$.
\end{letIn}
We define

$$
\begin{aligned}
  \syntax{.}_\Gamma: \ &\text{values}_\Gamma(\mf{<type>})\to\mathcal{T}\\
  \syntax{Bool}_\Gamma =& \mu\_.\mathit{True}\ | \ \mathit{False}\\
  \syntax{Int}_\Gamma =& \mu\_.0 \ | \ \mathit{Pos} \ \mathit{Nat} | \mathit{Neg} \ \mathit{Nat}\\
  \syntax{List}_\Gamma =& \forall a.\mu C.[ \ ] \ | \ \mathit{Cons} \ a \ C\\
  \syntax{"(" $t_1$ , $t_2$ ")"}_\Gamma =& \{1:\syntax{$t_1$}_\Gamma, 2: \syntax{$t_2$}_\Gamma\}\\
  \syntax{"\{\}"}_\Gamma =& \mathit{\{\}}\\
  \syntax{"\{" $v_1$ ":" $t_1$ "," $\dots$ "," $v_n$ ":" $t_n$ "\}"}_\Gamma =& \{v_1:\syntax{$t_1$}_\Gamma , \dots , v_n:\syntax{$t_n$}_\Gamma\}\\
  \syntax{$t_1$ "->" $t_2$}_\Gamma =& \syntax{$t_1$}_\Gamma \to \syntax{$t_2$}_\Gamma\\
  \syntax{$c \ t_1 \dots t_n$} =& [\syntax{$c$}]_\Gamma(t_1,\dots,t_n)
\end{aligned}
$$
```

Additionally, we will need to introduce a pattern matching function:

$$
\text{match}_\Theta:\text{value}(\mf{<type>})\times\text{value}(\mf{<exp>})\to\{\mathit{True},\mathit{False}\}
$$
for a given substitution $\Theta$. The function will be defined afterwards. For now its definition will be arbitrary.

We can already state two universal inference rules for any Hindley-Milner type system.

```{definition,name="Instantiation, Generalization"}
\begin{letIn}
$T',T\in\mathcal{T}$ and $e\in\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})$. Let $a$ be a type variable. Let $\Delta$ be a variable context. Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})\to A$
\end{letIn}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Delta\vdash\syntax{e}:_\Gamma T'
}
{\Delta\vdash \syntax{e}:_\Gamma T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Delta\quad
\Delta\vdash \syntax{e}:_\Gamma T
}
{\Delta\vdash \syntax{e}:_\Gamma \mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be inferred, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be inferred, then the same holds for a poly type, binding the free variable.

### Inference Rules for Programs

The inference rules for programs will done statement for statement. Note that every statement has one rule that can be applied, statement with optional parameters have a rule with and one without the optional parameter.

```{definition,name="Inference rules for programs"}
\begin{letIn}
$n,m\in\mathbb{N}$. Let $k_i\in\mathbb{N}$ for all $i\in\mathbb{N}_1^m$.
Let $T,T_1,T_2,T_3\in\mathcal{T}$ Let $v:\mf{<lower-var>},e:\mf{<exp>},t:\mf{<type>}$. Let $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $s:\mf{<list-statement>}$. Let $c:\mf{<lower-var>}$ and $c_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^m$. Let $t_{i,j}:\mf{<type>}$ for all $i\in\mathbb{N}_1^m$ and $j\in\mathbb{N}_1^{k_i}$. Let $mt:\mf{<maybe-main-sign>}$ and $me:\mf{<exp>}$.
Let $\Gamma$ be a type context and $\Delta$ a variable context.
Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<program>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}
The inference rules for programs are defined in table \ref{tab:inf_state}.
```

\begin{table}
\caption{Inference rules for programs}
\label{tab:inf_state}
\begin{center}
\begin{tabular}{c l}
\hline
& \\
\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{$v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_1\quad
\syntax{$t$}_\Gamma = T_1\\
\Delta\cup\{(v,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_\Gamma T_2\quad
\end{gathered}
}
{\Delta\vdash\syntax{$v$ ":" $t$ ";" $v$ "=" $e$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_2
}
{TConstant2}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\\
\syntax{t}_\Gamma=T_1\quad
T_2 \text{ is a mono type}\\
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\syntax{"type alias" $c$ $v_1 \dots v_n$ "=" $t$ ";" $s$ \ $mt$ "main = " $me$}:_\Gamma T_3}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\quad
\forall v_1. \dots \forall v_n. T_2 = T_1\\
\mu C.c_1 \ \syntax{$t_{1,1}$}_\Gamma \ \dots \ \syntax{$t_{1,k_1}$}_\Gamma \ | \ \dots \ | \ c_m \ \syntax{$t_{m,1}$}_\Gamma \ \dots \ \syntax{$t_{m,k_m}$}_\Gamma=T_2\\
\Delta\cup\{(c,T_1)\}\vdash\syntax{$s$ \ $mt$ "main = " $me$}:_{\Gamma\cup\{(c,(T_1))\}}T_3
\end{gathered}
}
{\Delta\vdash\Bigg\llbracket
\begin{aligned}
&\mf{"type"} \ c \ v_1 \dots v_n \mf{"="}\\
&c_1 \ t_{1,1} \dots t_{1,k_1} \ | \ \dots | \ c_m \ t_{m,1} \dots t_{m,k_m}\\ &\mf{";"} s \ mt \mf{"main = "} me
\end{aligned}\Bigg\rrbracket:_\Gamma T_3
}
{TCustomType}

& \\

\logicRule
{\Delta\vdash\syntax{$e$}:_\Gamma T}
{\Delta\vdash\syntax{"main = " $e$}:_\Gamma T}
{TMain}

\logicRule
{
\Delta\vdash\syntax{$e$}:_\Gamma T\quad
\syntax{$t$}_\Gamma=T
}
{\Delta\vdash\syntax{"main :" $t$ "; main = " $e$}:_\Gamma T}
{TMain2}

\hline
\end{tabular}
\end{center}
\end{table}

\begin{description}
\item[TConstant,TConstant2] Check if $v$ is still free then add $(v,T_1)$ to the variable context and evaluate the next statement.
\item[TAlias] Check if $c$ is still free. $\{v_1,\dots,v_2\}$ needs to be the set of all free variables in $T_2$. If all checks are valid we add $(v,T_1)$ to the type context and evaluate the next statement.
\item[TCustomType] Similar to $[\mathit{TAlias}]$ we add $(v,T_1)$ to the type context with the only difference that we explicitly define $T_1$ as an algebraic type.
\item[TMain,TMain2] Evaluate $e$.
\end{description}

### Inference Rules for Expressions

In the inference rules $[\mathit{TConstant}],[\mathit{TConstant2}]$ and $[\mathit{Main}],[\mathit{Main2}]$ we used a judgment for expressions. We will now give the corresponding inference rules. As before, each expression has one or two rules depending on optional parameters.

```{definition,name="Inference rules for expressions"}
\begin{letIn}
$n\in\mathbb{N}$. Let $T,T_0,T_1,T_2,T_3\in\mathcal{T}$.
Let $v,v_0,v_1,v_2,v_3:\mf{<lower-var>}$.
Let $e,e_0,e_1,e_2,e_3:\mf{<exp>}$.
Let $T_i:\mathcal{T}$ for all $i\in\mathbb{N}_4^n$.
Let $v_i:\mf{<lower-var>}$ for $i\in\mathbb{N}_4^n$.
Let $a_i:\mathcal{V}$ for all $i\in\mathbb{N}_4^n$.
Let $e_i:\mf{<exp>}$ for all $i\in\mathbb{N}_4^n$.
Let $p:\mf{<pattern>}$,
$\mathit{le}:\mf{<list.exp>}$,
$\mathit{lc}:\mf{<list-case>}$,
$\mathit{lef}:\mf{<list-exp-field>}$,
$c:\mf{<upper-var>}$ and
$t:\mf{<type>}.$
Let $\Gamma$ be a type context and $\Delta$ a variable context. Let $A$ be a set and
$\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}

The inference rules for expressions can be found in table \ref{tab:inf_exp}.
```


\topcaption{Inference rules for expressions}\label{tab:inf_exp}
\tablefirsthead{\hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}

&\\
\logicRule
{(v,T)\in\Delta
}
{\Delta\vdash\syntax{$v$}:_\Gamma T}
{TVariable}

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Delta\cup\Theta\vdash\syntax{$e$}:_\Gamma T_2
}
{\Delta\vdash\syntax{"\textbackslash" $p$ "->" $e$}:_\Gamma T_1\to T_2}
{TLambda}

\logicRule
{\syntax{$e_1$}_\Gamma:T_1\quad
\syntax{$e_2$}_\Gamma:T_2
}
{\Delta\vdash\syntax{"(" $e_1$ "," $e_2$ ")"}:_\Gamma\{1:T_1, 2:T_2\}}
{TTuple}

\logicRule
{}
{\Delta\vdash\syntax{"[]"}:_\Gamma\forall a.\mathit{List} \ a}
{TEmptyList}

\logicRule
{
\Delta\vdash\syntax{$e$}:_\Gamma T\quad
\Delta\vdash\syntax{"[" $\mathit{le}$ "]"}:_\Gamma \mathit{List} \ T
}
{\Delta\vdash\syntax{"[" $e$ "," $\mathit{le}$ "]"}:_\Gamma \mathit{List} \ T}
{TList}

\logicRule
{e:\mf{<int>}}
{\Delta\vdash\syntax{$e$}:_\Gamma \mathit{Int}}
{TInt}

\logicRule
{e:\mf{<bool>}}
{\Delta\vdash\syntax{$e$}:_\Gamma \mathit{Bool}}
{TBool}

\logicRule
{\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\to T_2\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_1
}
{\Delta\vdash\syntax{$e_1$ $e_2$}:_\Gamma T_2}
{TCall}

\logicRule
{\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Delta\cup\Theta\vdash\syntax{$e_2$}:_\Gamma T_2
}
{\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ "]"}:_\Gamma T_2}
{TSingleCaseOf}

\logicRule
{\begin{gathered}
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Delta\cup\Theta\vdash\syntax{$e_2$}:_\Gamma T_2\\
\Delta\vdash\syntax{"case" $e_1$ "of" "[" $\mathit{lc}$ "]"}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ ";" $\mathit{lc}$ "]"}:_\Gamma T_2}
{TCaseOf}

\logicRule
{
(v,\_)\not\in\Delta\quad
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:_\Gamma T_2
}
{
\Delta\vdash\syntax{"let" $v$ "=" $e_1$ "in" $e_2$}:_\Gamma T_2
}
{TLetIn}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\syntax{$t$}_\Gamma = T_1\quad
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:_\Gamma T_2
\end{gathered}
}
{\Delta\vdash\syntax{"let" $v$ ":" $t$ ";" $v$ "=" $e_1$ "in" $e_2$}:_\Gamma T_2
}
{TLetIn2}

\logicRule
{(v_1,\{v_2:T,\dots\})\in\Delta
}
{\Delta\vdash\syntax{$v_1$ "." $v_2$}:_\Gamma T}
{TGetter}

\logicRule
{\begin{gathered}
\Delta\vdash\syntax{$e$}:_\Gamma T_2\\
T_1=\{v_2:T_2,\dots\}\quad
(v_1,T_1)\in\Delta
\end{gathered}
}
{\Delta\vdash\syntax{"\{" $v1$ "|" $v2$ "=" $e$ "\}"}:_\Gamma T_1}
{TSingleSetter}

\logicRule
{\begin{gathered}
\mathit{lef}:\mf{<list-exp-field>}\quad
\Delta\vdash\syntax{$e$}:_\Gamma T_2\\
T_1=\{v_2:T_2,..\}\quad
(v_1,T_1)\in\Delta\quad
\Delta\vdash\syntax{"\{" $v$ "|" $\mathit{lef}$ "\}"}:_\Gamma T_1
\end{gathered}
}
{\Delta\vdash\syntax{"\{" $v$ "|" $v2$ "=" $e$ "," $\mathit{lef}$ "\}"}:_\Gamma T_1}
{TSetter}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{TEmptyRecord}

\logicRule
{\Delta\vdash\forall i \in\mathbb{N}_1^n.\syntax{$e_i$}:_\Gamma T_i
}
{\Delta\vdash\syntax{"\{" $v_1$ "=" $e_1$ "," \dots "," $v_n$ "=" $e_n$ "\}"}:_\Gamma \{v_1:T_1,\dots,v_n:T_n\}
}
{TRecord}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma\textit{Bool}\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T\quad
\Delta\vdash\syntax{$e_3$}:_\Gamma T
}
{\Delta\vdash\syntax{"if" $e_1$ "then" $e_2$ "else" $e_3$}:_\Gamma T}
{TIfElse}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1 \to T_2\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_2 \to T_3
}
{\Delta\vdash\syntax{$e_1$ ">>" $e_2$}:_\Gamma T_1 \to T_3}
{TComposition}

\logicRule
{
\Delta\vdash\syntax{$e_1$}:_\Gamma T_1\quad
\Delta\vdash\syntax{$e_2$}:_\Gamma T_1 \to T_2
}
{\Delta\vdash\syntax{$e_1$ "|>" $e_2$}:_\Gamma T_2}
{TPipe}

\logicRule
{}
{\vdash\syntax{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{}
{\vdash\syntax{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\vdash\syntax{"not"}:\mathit{Bool}\to \mathit{Bool}}
{TNot}

\logicRule
{}
{\vdash\syntax{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\vdash\syntax{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\vdash\syntax{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\vdash\syntax{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\vdash\syntax{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\vdash\syntax{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\vdash\syntax{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\vdash\syntax{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\end{xtabular*}
\end{center}

\begin{description}
\item[TVariable] Find the type in the context.
\item[TLambda] Elm allows the parameters of a function to be pattern matched. Therefore, we first need to find a matching type $T_1$ and can then infer the type of $e$ by including the additional bindings $\Theta$ to the context.
\item[TTuple] Find the types of $e_1$ and $e_2$, then construct the tuple.
\item[TEmptyList] The empty list is a literal for every list, therefore we can infer the list poly type.
\item[TSingleList,TList] Recursively we check that every element has the same type.
\item[TInt,TBool] The type of literals can be inferred without any restrictions.
\item[TCall] The first expression needs to be a function that the the second type can be passed to.
\item[TSingleCaseOf,TCaseOf] First match the type of the expression $e_1$ to the pattern, then use the additional bindings $\Theta$ to obtain the type of $e_2$. As all patterns need to have the same type, we can then recursively check the other patterns as well.
\item[TLetIn,TLetIn2] The variable $v$ may not have a value assined in the conext $\Gamma$. If so, we can infer the type $T_1$ of $e_1$ and add $(v,T_1)$ to the context before we evaluate $e_2$. For $[TLetIn2]$ we already the type is already given as $t$. Note that $t$ can be more specific as the type we would usually infer.
\item[TGetter] The second variable $v_2$ is a label of the record, that is bound to $v_1$.
\item[TSingleSetter,TSetter] Setters can not change the type in Elm. But we still need to ensure that the fields are also correctly typed.
\item[TElmptyRecord] The empty record can be directly infered, as it has only one element.
\item[TRecord] Each field and its value must be given at the same time. That is why we can not use a recursive definition.
\item[TIfElse] The first expression $e_1$ needs to be a boolean and the branches $e_2,e_3$ must have the same type.
\item[TComposition,TPipe] The pipe applies the first expression to the second. The composition is similar to the pipe, but results in a function.
\item[TOr,TAnd,TNot,TEqual,TDivide,TMultiply,TMinus,TPlus,TCons,TFoldl] These functions can be seen as lambda function literals.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$, $\Delta = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl (::) []
\end{lstlisting}

Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```