\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

We will now discuss the methods used to infer a type from a given expression.

```{definition,name="Type of an expression"}
\begin{letIn}
$T \in\mathcal{T}$. Let $\Gamma$ be a type context. Let $e$ be arbitary.
\end{letIn}
We say $e$ _is of type_ $T$ _in the context of_ $\Gamma$ (Notation: $e:T$)$:\Leftrightarrow$
  
$$
e \in values_\Gamma(T)
$$
```

Next we will need the semantics of $\mf{<type>}$, namely a function that maps $\text{value}(\mf{<type>})$ to $\mathcal{T}$. Note that the general discussion about semantics will occur in a later chapter.

```{definition,name="Semantics of <type>"}
\begin{letIn}
$n\in\mathbb{N}$. Let $t,t_1,t_2:\mf{<type>}$ and $c:\mf{<upper-var>}$.
Let $t_i:\mf{<type>}$ for all $i\in\mathbb{N}_3^n$ and $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$.Let $\Gamma$ be a type context. Let $\mathit{Nat}=\mu C.1 \ | \ \mathit{Succ} \ C$.
\end{letIn}
We define

$$
\begin{aligned}
  \syntax{.}_\Gamma:&\text{value}(\mf{<type>})\to\mathcal{T}\\
  \syntax{Bool}_\Gamma =& \mu\_.\mathit{True}\ | \ \mathit{False}\\
  \syntax{Int}_\Gamma =& \mu\_.0 \ | \ \mathit{Pos} \ \mathit{Nat} | \mathit{Neg} \ \mathit{Nat}\\
  \syntax{List}_\Gamma =& \forall a.\mu C.[ \ ] \ | \ \mathit{Cons} \ a \ C\\
  \syntax{"(" $t_1$ , $t_2$ ")"}_\Gamma =& \{1:\syntax{$t_1$}, 2: \syntax{$t_2$}\}\\
  \syntax{"\{\}"}_\Gamma =& \mathit{\{\}}\\
  \syntax{"\{" $v_1$ ":" $t_1$ "," $\dots$ "," $v_n$ ":" $t_n$ "\}"}_\Gamma =& \{v_1:\syntax{$t_1$}_\Gamma , \dots , v_n:\syntax{$t_n$}_\Gamma\}\\
  \syntax{$t_1$ "->" $t_2$}_\Gamma =& \syntax{$t_1$}_\Gamma \to \syntax{$t_2$}_\Gamma\\
  \syntax{$c \ t_1 \dots t_n$} =& [\syntax{$c$}]_\Gamma(a_1,\dots,a_n)
\end{aligned}
$$
We say $\syntax{.}_\Gamma$ is the _interpretation_ of \mf{<type>}. For any $t\in\mf{<type>}$,we call \(\syntax{$t$}_\Gamma\) the _semantic_ of $t$.
```

For this section we will also use an interpretation function for expressions

$$
\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A
$$
for some nonempty set $A$. We will discuss the definition of such a function as well as the definition of $A$ in the next chapter. For now, they will be arbitrary.

```{definition,name="Variable Context"}
$\Delta:\mathcal{V} \nleftrightarrow \mathcal{T}$ is called the _variable context_.
```

Types are typically inferred using so called _typing rules_ \cite{Types_and_Programming_Languages}. Using these rules we can construct a truth tree, who's leafs are axioms, to prove that $\Delta\vdash\syntax{e}:T$ for an expression $e$, a type $T$, a variable context $\Delta$ and a interpretation function for expressions $\Delta$. Such a proving process is called _type checking_. It is also possible to find the most general $T$ such that $\Delta\vdash\syntax{e}:T$ using the typing rules. This is called _type inference_.

There are two universal typing rules for any Hindley-Milner type system.

```{definition,name="Instantiation, Generalization"}
\begin{letIn}
$T',T\in\mathcal{T}$ and $e\in\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})$. Let $a$ be a type variable. Let $\Delta$ be a variable context. Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$
\end{letIn}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Gamma,\Delta\vdash\syntax{e}:T'
}
{\Gamma,\Delta\vdash \syntax{e}:T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash \syntax{e}:T
}
{\Gamma,\Delta\vdash \syntax{e}:\mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be infered, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be inferred, then the same holds for a poly type, binding the free variable.

### Typing rules for statements

The typing rules for statements are as follows.

```{definition,name="typing rules for statements"}
\begin{letIn}
$n,m\in\mathbb{N}$. Let $k_i\in\mathbb{N}$ for all $i\in\mathbb{N}_1^m$.
Let $T,T_1,T_2,T_3:\mathcal{T}$ Let $v:\mf{<lower-var>},e:\mf{<exp>},t:\mf{<type>}$. Let $v_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^n$. Let $s:\mf{<statement>}$. Let $c:\mf{<lower-var>}$ and $c_i:\mf{<lower-var>}$ for all $i\in\mathbb{N}_1^m$. Let $t_{i,j}:\mf{<type>}$ for all $i\in\mathbb{N}_1^m$ and $j\in\mathbb{N}_1^{k_i}$.
Let $\Gamma$ be a type context and $\Delta$ a variable context.
Let $A$ be a set and $\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}
The typing rules for statements are defined in table \ref{tab:inf_state}.
```

\tablefirsthead{Table \ref{tab:inf_state}: Typing rules for statements\\ \hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}
\label{tab:inf_state}
& \\
\logicRule
{(v,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash\syntax{$e$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\vdash\syntax{$s$}:T_2\}
}
{\Delta,\Gamma\vdash\syntax{$v$ "=" $e$ ";" $s$}:T_2
}
{TConstant}

\logicRule
{
(v,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash\syntax{$e$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\vdash\syntax{$s$}:T_2\}\quad
\syntax{$t$}_\Gamma = T_1
}
{\Gamma,\Delta\vdash\syntax{$v$ ":" $t$ ";" $v$ "=" $e$ ";" $s$}:T_2
}
{TConstant2}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\syntax{t}_\Gamma=T_1\\
T_2 \text{ is a mono type}\quad\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\\
\forall v_1. \dots \forall v_n. T_2 = T_1\quad
\Gamma\cup\{(c,(T_1))\},\Delta\cup\{(c,T_1)\}\vdash\syntax{s}:T_3
\end{gathered}
}
{\Gamma\Delta\vdash\syntax{"type alias" $c$ $v_1 \dots v_n$ "=" $t$ ";" $s$}:T_3}
{TAlias}

\logicRule
{\begin{gathered}
(c,\_)\not\in\Gamma\quad
(c,\_)\not\in\Delta\quad
\{v_1 \dots v_n \} = \text{free}(T_2)\\
\mu C.c_1 \ \syntax{$t_{1,1}$}_\Gamma \ \dots \ \syntax{$t_{1,k_1}$}_\Gamma \ | \ \dots \ | \ c_m \ \syntax{$t_{m,1}$}_\Gamma \ \dots \ \syntax{$t_{m,k_m}$}_\Gamma=T_2\\
\forall v_1. \dots \forall v_n. T_2 = T_1\quad
\Gamma\cup\{(c,(T_1))\},\Delta\cup\{(c,T_1)\}\vdash\syntax{s}:T_3
\end{gathered}
}
{\Gamma,\Delta\vdash\Bigg\llbracket
\begin{aligned}
&\mf{"type"} \ c \ v_1 \dots v_n \mf{"="}\\
&c_1 \ t_{1,1} \dots t_{1,k_1} \ | \ \dots | \ c_m \ t_{m,1} \dots t_{m,k_m} \mf{";"} s
\end{aligned}\Bigg\rrbracket:T_3
}
{TCustomType}

& \\

\logicRule
{\Gamma,\Delta\vdash\syntax{$e$}:T}
{\Gamma,\Delta\vdash\syntax{"main" $e$}:T}
{TMain}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e$}:T\quad
\syntax{$t$}_\Gamma=T
}
{\Gamma,\Delta\vdash\syntax{"main :" $t$ "; main" $e$}:T}
{TMain2}
\end{xtabular*}
\end{center}

\begin{description}
\item[TConstant,TConstant2] Check if $v$ is still free then add $(v,T_1)$ to the variable context and evaluate the next statement.
\item[TAlias] Check if $c$ is still free. $\{v_1,\dots,v_2\}$ needs to be the set of all free variables in $T_2$. If all checks are valid we add $(v,T_1)$ to the type context and evaluate the next statement.
\item[TCustomType] Similar to [TAlias] we add $(v,T_1)$ to the type context with the only difference that we explicitly define $T_1$ as an algebraic type.
\item[TMain,TMain2] Evaluate $e$.
\end{description}

### Typing rules for expressions

For the typing rules of expressions we will need to introduce a pattern matching function:

$$
\text{match}_\Theta:\text{value}(\mf{<type>})\times\text{value}(\mf{<exp>})\to\{\mathit{True},\mathit{False}\}
$$
for a given substitution $\Theta$.

The function will be defined afterwards. For now its definition will be arbitrary.

```{definition,name="type inference for expressions"}
\begin{letIn}
$n\in\mathbb{N}$. Let $T,T_0,T_1,T_2,T_3:\mathcal{T}$.
Let $v,v_0,v_1,v_2,v_3:\mf{<lower-var>}$.
Let $e,e_0,e_1,e_2,e_3:\mf{<exp>}$.
Let $T_i:\mathcal{T}$ for all $i\in\mathbb{N}_4^n$.
Let $v_i:\mf{<lower-var>}$ for $i\in\mathbb{N}_4^n$.
Let $a_i:\mathcal{V}$ for all $i\in\mathbb{N}_4^n$.
Let $e_i:\mf{<exp>}$ for all $i\in\mathbb{N}_4^n$.
Let $p:\mf{<pattern>}$,
$\mathit{le}:\mf{<list.exp>}$,
$\mathit{lc}:\mf{<list-case>}$,
$\mathit{lef}:\mf{<list-exp-field>}$,
$c:\mf{<upper-var>}$ and
$t:\mf{<type>}.$
Let $\Gamma$ be a type context and $\Delta$ a variable context. Let $A$ be a set and
$\syntax{.}:\text{values}(\mf{<statement>})\cup\text{values}(\mf{<expression>})\to A$.
\end{letIn}

The typing rules for expressions can be found in table \ref{tab:inf_exp}.
```

\tablefirsthead{Table \ref{tab:inf_exp}: Typing rules for expressions\\ \hline}
\tablelasttail{\hline}

\begin{center}
\begin{xtabular*}{\textwidth}{c l}
\label{tab:inf_exp}
&\\
\logicRule
{(v,T)\in\Delta
}
{\Gamma,\Delta\vdash\syntax{$v$}:T}
{TVariable}

\logicRule
{\Gamma,\Delta\vdash \text{match}_\Theta(T_1,p)\quad
\Gamma,\Delta\cup\Theta\vdash\syntax{$e$}:T_2
}
{\Gamma,\Delta\vdash\syntax{"\textbackslash" $p$ "->" $e$}:T_1\to T_2}
{TLambda}

\logicRule
{\syntax{$e_1$}_\Gamma:T_1\quad
\syntax{$e_2$}_\Gamma:T_2
}
{\Gamma,\Delta\vdash\syntax{"(" $e_1$ "," $e_2$ ")"}:\{1:T_1, 2:T_2\}}
{TTuple}

\logicRule
{}
{\Gamma,\Delta\vdash\syntax{"[]"}:\forall a.\mathit{List} \ a}
{TEmptyList}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e$}:T
}
{\Gamma,\Delta\vdash\syntax{"[" $e$ "]"}: \mathit{List} \ T}
{TSingleList}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e$}:T\quad
\Gamma,\Delta\vdash\syntax{"[" $\mathit{le}$ "]"}:\mathit{List} \ T
}
{\Gamma,\Delta\vdash\syntax{"[" $e$ "," $\mathit{le}$ "]"}: \mathit{List} \ T}
{TList}

\logicRule
{e:\mf{<int>}}
{\Gamma,\Delta\vdash\syntax{$e$}:\mathit{Int}}
{TInt}

\logicRule
{e:\mf{<bool>}}
{\Gamma,\Delta\vdash\syntax{$e$}:\mathit{Bool}}
{TBool}

\logicRule
{\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\to T_2\quad
\Gamma,\Delta\vdash\syntax{$e_2$}:T_1
}
{\Gamma,\Delta\vdash\syntax{$e_1$ $e_2$}:T_2}
{TCall}

\logicRule
{\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Gamma,\Delta\cup\Theta\vdash\syntax{$e_2$}:T_2
}
{\Gamma,\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ "]"}:T_2}
{TSingleCaseOf}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\vdash\text{match}_\Theta(T_1,\syntax{$p$})\quad
\Gamma,\Delta\cup\Theta\vdash\syntax{$e_2$}:T_2\\
\Gamma,\Delta\vdash\syntax{"case" $e_1$ "of" "[" $\mathit{lc}$ "]"}:T_2
\end{gathered}
}
{\Gamma,\Delta\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ ";" $\mathit{lc}$ "]"}:T_2}
{TCaseOf}

\logicRule
{
(v,\_)\not\in\Delta\quad
\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:T_2
}
{
\Gamma,\Delta\vdash\syntax{"let" $v$ "=" $e_1$ "in" $e_2$}:T_2
}
{TLetIn}

\logicRule
{\begin{gathered}
(v,\_)\not\in\Delta\quad
\syntax{$t$}_\Gamma = T_1\quad
\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\cup\{(v,T_1)\}\vdash\syntax{$e_2$}:T_2
\end{gathered}
}
{\Gamma,\Delta\vdash\syntax{"let" $v$ ":" $t$ ";" $v$ "=" $e_1$ "in" $e_2$}:T_2
}
{TLetIn2}

\logicRule
{(v_1,\{v_2:T,\dots\})\in\Delta
}
{\Gamma,\Delta\vdash\syntax{$v_1$ "." $v_2$}:T}
{TGetter}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash\syntax{$e$}:T_2\\
T_1=\{v_2:T_2,\dots\}\quad
(v_1,T_1)\in\Delta
\end{gathered}
}
{\Gamma,\Delta\vdash\syntax{"\{" $v1$ "|" $v2$ "=" $e$ "\}"}:T_1}
{TSingleSetter}

\logicRule
{\begin{gathered}
\mathit{lef}:\mf{<list-exp-field>}\quad
\Gamma,\Delta\vdash\syntax{$e$}:T_2\\
T_1=\{v_2:T_2,..\}\quad
(v_1,T_1)\in\Delta\quad
\Gamma,\Delta\vdash\syntax{"\{" $v$ "|" $\mathit{lef}$ "\}"}:T_1
\end{gathered}
}
{\Gamma,\Delta\vdash\syntax{"\{" $v$ "|" $v2$ "=" $e$ "," $\mathit{lef}$ "\}"}:T_1}
{TSetter}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{TEmptyRecord}

\logicRule
{\Gamma,\Delta\vdash\forall i \in\mathbb{N}_1^n.\syntax{$e_i$}:T_i
}
{\Gamma,\Delta\vdash\syntax{"\{" $v_1$ "=" $e_1$ "," \dots "," $v_n$ "=" $e_n$ "\}"}:\{v_1:T_1,\dots,v_n:T_n\}
}
{TRecord}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e_1$}:\textit{Bool}\quad
\Gamma,\Delta\vdash\syntax{$e_2$}:T\quad
\Gamma,\Delta\vdash\syntax{$e_3$}:T
}
{\Gamma,\Delta\vdash\syntax{"if" $e_1$ "then" $e_2$ "else" $e_3$}:T}
{TIfElse}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e_1$}:T_1 \to T_2\quad
\Gamma,\Delta\vdash\syntax{$e_2$}:T_2 \to T_3
}
{\Gamma,\Delta\vdash\syntax{$e_1$ ">>" $e_2$}:T_1 \to T_3}
{TComposition}

\logicRule
{
\Gamma,\Delta\vdash\syntax{$e_1$}:T_1\quad
\Gamma,\Delta\vdash\syntax{$e_2$}:T_1 \to T_2
}
{\Gamma,\Delta\vdash\syntax{$e_1$ "|>" $e_2$}:T_2}
{TPipe}

\logicRule
{}
{\vdash\syntax{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{}
{\vdash\syntax{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\vdash\syntax{"not"}:\mathit{Bool}\to \mathit{Bool}}
{TNot}

\logicRule
{}
{\vdash\syntax{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\vdash\syntax{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\vdash\syntax{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\vdash\syntax{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\vdash\syntax{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\vdash\syntax{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\vdash\syntax{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\vdash\syntax{"foldl"}:\forall a.\forall b.(a\to b\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\end{xtabular*}
\end{center}

\begin{description}
\item[TVariable] Find the type in the context.
\item[TLambda] Elm allows the parameters of a function to be pattern matched. Therefore, we first need to find a matching type $T_1$ and can then infer the type of $e$ by including the additional bindings $\Theta$ to the context.
\item[TTuple] Find the types of $e_1$ and $e_2$, then construct the tuple.
\item[TEmptyList] The empty list is a literal for every list, therefore we can infer the list poly type.
\item[TSingleList,TList] Recursively we check that every element has the same type.
\item[TInt,TBool] The type of literals can be inferred without any restrictions.
\item[TCall] The first expression needs to be a function that the the second type can be passed to.
\item[TSingleCaseOf,TCaseOf] First match the type of the expression $e_1$ to the pattern, then use the additional bindings $\Theta$ to obtain the type of $e_2$. As all patterns need to have the same type, we can then recursively check the other patterns as well.
\item[TLetIn,TLetIn2] The variable $v$ may not have a value assined in the conext $\Gamma$. If so, we can infer the type $T_1$ of $e_1$ and add $(v,T_1)$ to the context before we evaluate $e_2$. For $[TLetIn2]$ we already the type is already given as $t$. Note that $t$ can be more specific as the type we would usually infer.
\item[TGetter] The second variable $v_2$ is a label of the record, that is bound to $v_1$.
\item[TSingleSetter,TSetter] Setters can not change the type in Elm. But we still need to ensure that the fields are also correctly typed.
\item[TElmptyRecord] The empty record can be directly infered, as it has only one element.
\item[TRecord] Each field and its value must be given at the same time. That is why we can not use a recursive definition.
\item[TIfElse] The first expression $e_1$ needs to be a boolean and the branches $e_2,e_3$ must have the same type.
\item[TComposition,TPipe] The pipe applies the first expression to the second. The composition is similar to the pipe, but results in a function.
\item[TOr,TAnd,TNot,TEqual,TDivide,TMultiply,TMinus,TPlus,TCons,TFoldl] These functions can be seen as lambda function literals.
\end{description}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for a list reversing function. We can now prove the typing of the `reverse` function for $\Gamma = \varnothing$, $\Delta = \varnothing$ and $T = \forall a.List \ a \to List \ a$.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl (::) []
\end{lstlisting}

Let $T_1 = \mathit{List} \ a$, $T_0 = \mathit{List} \ a \to \mathit{List} \ a$ and $T_2 = a \to \mathit{List} \ a \to \mathit{List} \ a$

\begin{center}
\small
\begin{prooftree}
      \AxiomC{$\top$}
    \LeftLabel{$(4)$}
    \UnaryInfC{$\vdash \syntax{"foldl"}:\forall a. T_2\to T_1 \to T_0$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\vdash \syntax{"(::)"}:T_2$}
  \LeftLabel{$(1)$}
  \BinaryInfC{$\vdash \syntax{"foldl (::)"}:\forall a.T_1 \to T_0$}
    \AxiomC{$\top$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\vdash \syntax{"[]"}:\forall a.T_1$}
\RightLabel{$(1)$}
\BinaryInfC {$\vdash  \syntax{"(foldl (::)) []"}:\forall a.T_0$}
\end{prooftree}
\end{center}

$(1)\mathit{[TCall]},(2)\mathit{[TEmptyList]},(3)\mathit{[TCons]},(4)\mathit{[TFoldl]}$
```