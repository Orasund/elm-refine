\setcounter{section}{3}
\setcounter{subsection}{2}

## Type Inference

In the first section of this chapter we defined a type system, in the second section we introduced a syntax for our language. Now we want to define rules how to obtain the type of a given program written in our language.

### Typing Judgments

To state that a program $e$ is of type $T$ (and therefor well-formed) we write

$$e:T$$

We call such a statement a judgment. Judgments are generally written in meta-language, thus we also need to provide a system of inference rules how to infer such a judgment. These _inference rules_ have the following form

$$
\frac
{P_1 \dots P_n}
{C}
$$
where $P_1$ up to $P_n$ are premises and $C$ is a conclusion.

We can read it in two ways:

* "if all premises hold then the conclusion holds as well" or
* "to prove the conclusion we need to prove all premises"

The premises as well as the conclusion are  meta-language statements in the following form

$$A_1,\dots,A_n \vdash B.$$

Such a sequent would be generally read as "If we know $A_1,\dots,A_n$ then we can prove B".

We will now provide a judgment for every production rule defined in the last section.

#### Type Signiture Judgments

For type signiture judgments, let $\Gamma$ be a type context, $T\in\mathcal{T}$ and $a_i\in\mathcal{V},T_i\in\mathcal{T}$ for $i\in\mathbb{N}_1^n$ and $n\in\mathbb{N}$.

For $l\in\mf{<list-lower-var>}$ the judgment is
$$l:(a_1,\dots,a_n).$$

For $l\in\mf{<list-type-fields>}$ the judgment is
$$\Gamma\vdash l:\{a_1:T_1,\dots,a_n:T_n\}.$$

For $l\in\mf{<list-type>}$ the judgment is
$$\Gamma\vdash l:(T_1,\dots,T_n)$$

For $t\in\mf{<txpe>}$ the judgment is
$$\Gamma\vdash t:T$$

#### Pattern Judgments

We will now introduce another context, this time for variables instead of types:

```{definition,name="Variable Context"}
$\Delta\in\mathcal{V} \nrightarrow \mathcal{T}$ is called the _variable context_.
```

For pattern judgments, let $\Gamma$ be a type context and $\Delta,\Theta$ be variable contexts. Let $T\in\mathcal{T}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n$ and $n\in\mathbb{N}$.

For $l\in\mf{<list-pattern-list>}$ the judgment is
$$\Gamma,\Delta\vdash:\text{match}_\Theta ((T_1,\dots,T_n),l).$$
This can be read as "given $\Gamma$ and $\Delta$, we can match $(T_1,\dots,T_n)$ with the pattern $l$ by using the variable context $\Theta$".

For $l\in\mf{<list-pattern-sort>}$ the judgment is
$$\Gamma,\Delta\vdash\text{match}_\Theta ((T_1,\dots,T_n),l)$$

For $l\in\mf{<list-pattern-vars>}$ the judgment is
$$l:(a_1,\dots,a_n)$$

For $p\in\mf{<pattern>}$ the judgment is
$$\Gamma,\Delta\vdash\text{match}_\Theta(T,p)$$

#### Expression Judgments

For expression judgments, let $\Gamma$ be a type context, $\Delta$ be a variable context, $T\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n,n\in\mathbb{N}$.

For $l\in\mf{<list-exp-field>}$ the judgment is
$$\Gamma,\Delta\vdash l:\{a_1:T_1,\dots, a_n:T_n\}$$

For $m\in\mf{<maybe-exp-sign>}$ the judgment is
$$m:T_1\vdash a:T_2$$
It can be read as "given that $m$ has the type $T_1$, $a$ has the type $T_2$".

For $l\in\mf{<list-case>}$ the judgment is
$$\Gamma,\Delta\vdash l:T$$

For $e\in\mf{<bool>}$ the judgment is
$$e:T$$

For $e\in\mf{<int>}$ the judgment is
$$e:T$$

For $l\in\mf{<list-exp>}$ the judgment is
$$\Gamma,\Delta\vdash l:(T_1,\dots,T_n)$$

For $e\in\mf{<exp>}$ the judgment is
$$\Gamma,\Delta\vdash e:T$$

If the type $T$ is known then we talk about _type checking_ else we call the process of finding the judgment _type inferring_. For inferring a type (for the judgment $\Gamma,\Delta\vdash e:T$), the result is not necessary unique. Therefore, we want to find the most general type, meaning a type $T_1$ such that

* $T_1$ is an inferred type: for all $T_2\in\mathcal{T}\land T_1\sqsubseteq T_2$ the judgment $\Gamma,\Delta\vdash e:T_2$ holds.
* $T_1$ is sharp: for all $T_2\in\mathcal{T}\land T_2 \sqsubseteq T_1$ we can find $T_3\in\mathcal{T} \land T_2 \sqsubseteq T_3$ such that the judgment $\Gamma,\Delta\vdash e:T_3$ does not hold.

#### Statement Judgments

For statement judgments, let $\Gamma,\Gamma_1,\Gamma_2$ be type contexts, $\Delta,\Delta_1,\Delta_2$ be a variable contexts, $T,T_1,T_2\in\mathcal{T}$, $a\in\mathcal{V}$ and $T_i\in\mathcal{T},a_i\in\mathcal{V}$ for $i\in\mathbb{N}_0^n$
and $T_{i,j}\in\mathcal{T}$ for $i\in\mathbb{N}_0^n,n\in\mathbb{N},j\in\mathbb{N}_0^{k_i}$ and $k_i\in\mathbb{N}$.

For $l\in\mf{<list-sort>}$ the judgment is
$$l:(a_1:(T_{1,1}, \dots,T_{1,k_1}),\dots,a_n:(T_{n,1}, \dots,T_{n,k_1}))$$

For $l\in\mf{<maybe-statement-sign>}$ the judgment is
$$m:T_1\vdash a:T_2$$

For $l\in\mf{<list-statement>}$ the judgment is
$$\Gamma_1,\Delta_2,l\vdash \Gamma_2,\Delta_2$$

For $e\in\mf{<statement>}$ the judgment is
$$\Gamma_1,\Delta_2,e\vdash \Gamma_2,\Delta_2$$
It can be read as "the statement $e$ maps $\Gamma_1$ to $\Gamma_2$ and $\Delta_1$ to $\Delta_2$".

For $m\in\mf{<maybe-main-sign>}$ the judgment is
$$m:T_1\vdash \text{main}:T_2$$

For $e\in\mf{<program>}$ the judgment is
$$e:T$$

### Auxiliary Definitions

We will use $(e,T)\in\Gamma$ and $(e,T)\in\Delta$ to denote that a tuple $(e,T)$ exists in $\Gamma$ or $\Delta$. We will also sometimes use a wildcard $\_$ instead of a T if we are only interested in e.

We will use $T_1 \sqsubseteq T_2$ for given types $T_1,T_2$ to denote that $T_1$ is more general than $T_2$.

We will use "$T \text{ is a mono type}$", $T \text{ is a type variable}$ and type equivalence $T_1 = T_2$ for two given types $T_1$ and $T_2$.

We will use ${a_1,\dots,a_n}=\text{free}(T)$ to get all free variables of $T$.

### Inference Rules for type signitures

#### list-lower-var
Judgment: $l:(a_1,\dots,a_n)$

\logicRule
{}
{\mf{""}:()}
{}
For an empty list we return the empty tuple.

\logicRule
{l:(a_1,\dots,a_n)\quad (a_0,a_1,\dots,a_n)=T}
{a_0 \ l:T}
{}
For a nonempty list, we append the head $a$ to the type $T$ of the tail $l$.

#### list-type-fields

Judgment: $\Gamma\vdash l:\{a_1:T_1,\dots,a_n:T_n\}$

\logicRule
{}
{\Gamma\vdash \mf{""}:\{\}}
{}

\logicRule
{\Gamma\vdash t : T_0\quad
\Gamma\vdash l : \{a_1:T_1,\dots,a_n:T_n\}\quad
\{a_0:T_0,a_1:T_1,\dots,a_n:T_n\}=T
}
{\Gamma\vdash a_0 \ \mf{":"} \ t \ \mf{","} \ l:T}
{}

The type context $\Gamma$ is used in the judgment $\Gamma\vdash t:T_0$ that turns the type signature $t$ into a type $T_0$.

#### list-type

Judgment: $\Gamma\vdash l:(T_1,\dots,T_n)$

\logicRule
{}
{\Gamma\vdash \mf{""}:()}
{}

\logicRule
{\Gamma\vdash t:T_0\quad
\Gamma\vdash l:(T_1,\dots,T_n)\quad
(T_0,T_1,\dots,T_n)=T
}
{\Gamma\vdash t \ l:T}
{}

#### type

Judgment: $\Gamma\vdash t:T$

\logicRule
{}
{\Gamma\vdash \mf{"Bool"}:Bool}
{}

\logicRule
{}
{\Gamma\vdash\mf{"Int"}:Int}
{}

\logicRule
{\Gamma\vdash t:T}
{\Gamma\vdash\mf{"List" t}:(\forall a.\mu C. [ \ ] \ | \mathit{Cons} \ a \ C) \ T}
{}
The resulting type is a type application $\mathit{List} \ T$ for the type $\mathit{List} = \forall a.\mu C. [ \ ] \ | \mathit{Cons} \ a \ C$.

\logicRule
{\Gamma\vdash t_1:T_1\quad
\Gamma\vdash t_2:T_2
}
{\Gamma\vdash\mf{"("} \ t_1 \ \mf{","} \ t_2 \ \mf{")"}:(T_1,T_2)}
{}

\logicRule
{\Gamma\vdash l:T}
{\Gamma\vdash\mf{"\{"} l \mf{"\}"}:T}
{}

\logicRule
{\Gamma\vdash t_1:T_1\quad
\Gamma\vdash t_2:T_2
}
{\Gamma\vdash t_1 \to t_2:T_1 \to T_2}
{}

\logicRule
{(c,f)\in\Gamma\quad
\Gamma\vdash l:(T_1,\dots,T_n)\quad
f \ T_1 \dots T_n = T
}
{\Gamma\vdash c \ l:T}
{}
Note that $\Gamma$ maps variables to application constructors.

\logicRule
{(a,(T))\in\Gamma\quad
T \text{ is a type variable}
}
{\Gamma\vdash a:T}
{}
For a given type $T$ we write the application constructor as $(T)$.