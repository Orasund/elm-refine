### Syntax

Elm differenciates between variables depending on the capitalisation of the first letter. For the formal langauge we define `<upper-letter>`$:\mathcal{V}$ for variables with the first letter capitaliced and `<lower-var>`$:\mathcal{V}$ for variables without.

Syntactically we can build our types from booleans, intergers, lists, tuples, records, functions, custom types and type variables.

```{definition,name="Type Signiture Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$\mf{<list-lower-var>} \ ::= \ \mf{""} \ | \ \mf{<lower-var>} \ | \ \mf{<lower-var>} \ \mf{<list-lower-var>}$$
$$\mf{<type-fields>} \ ::= \ \mf{""} \ | \ \mf{<lower-var> ":" <type>} \ | \ \mf{<lower-var> ":" <type> "," <list-type-field>}$$
$$\mf{<list-type>} \ ::= \ \mf{""} \ | \ \mf{<type> <type>} \ \mf{<list-type>}$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{"Bool"}\\
               &| \mf{"Int"}\\
               &| \mf{"List" <type>}\\
               &| \mf{"(" <type> "," <type> ")"}\\
               &| \mf{"{" <type-fields> "}"}\\
               &| \mf{<type> "->" <type>}\\
               &| \mf{<upper-var> <list-type>}\\
               &| \mf{<lower-var>}\\
\end{aligned}
$$
```

For matching expressions we allow various pattern.

```{definition,name="Pattern Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$
\begin{aligned}
\mf{<list-pattern-list>} \ ::=& \ \mf{""} \ | \ \mf{<pattern>} \\
                             |& \ \mf{<pattern> "," <list-pattern-list>}
\end{aligned}
$$
$$\mf{<list-pattern-sort>} \ ::= \ \mf{""} \ | \ \mf{<pattern>} \ | \ \mf{<pattern> <list-pattern-list>}$$
$$
\begin{aligned}
\mf{<list-pattern-vars>} \ ::=& \ \mf{""} \ | \ \mf{<lower-var>} \\
                             |& \ \mf{<pattern> "," <list-pattern-vars>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<pattern>} \ ::=& \ \mf{<bool>}\\
                   |& \ \mf{<int>}\\
                   |& \ \mf{"[" <list-pattern-list> "]"}\\
                   |& \ \mf{"(" <pattern> , <pattern> ")"}\\
                   |& \ \mf{<upper-var> <list-pattern-sort>}\\
                   |& \ \mf{<lower-var>}\\
                   |& \ \mf{<pattern> "as" <lower-var>}\\
                   |& \ \mf{"\{" <list-pattern-vars> "\}"}\\
                   |& \ \mf{<pattern> "::" <pattern>}\\
                   |& \ \mf{"-"}
\end{aligned}
$$
```

Because Elm is a pure functional programming language, a programm contains a single expression.

\begin{figure}[htbp]
%\begin{mdframed}
\begin{center}
\begin{align*}
\mf{<exp>} \ ::=& \ \mf{"foldl"}\\
               |& \ \mf{"(::)"}\\
               |& \ \mf{"(+)"} \ | \ \mf{"(-)"} \ | \ \mf{"(*)"} \ | \ \mf{"(//)"}\\
               |& \ \mf{"(<)"} \ | \ \mf{"(==)"}\\
               |& \ \mf{"not"} \ | \ \mf{"(\&\&)"} \ | \ \mf{"(||)"}\\
               |& \ \mf{<exp> "|>" <exp>}\\
               |& \ \mf{<exp> ">>" <exp>}\\
               |& \ \mf{"if" <exp> "then" <exp> "else" <exp>}\\
               |& \ \mf{"{" <list-exp-field> "}"}\\
               |& \ \mf{"{}"}\\
               |& \ \mf{"{" <lower-var> "|" <list-exp-field> "}"}\\
               |& \ \mf{<lower-var> "." <lower-var>}\\
               |& \ \mf{"let" <maybe-signature> <lower-var> "=" <exp> "in" <exp>}\\
               |& \ \mf{"case" <exp> "of" "[" <list-case> "]"}\\
               |& \ \mf{<exp> <exp>}\\
               |& \ \mf{<bool>}\\
               |& \ \mf{<int>}\\
               |& \ \mf{"[" <list-exp> "]"}\\
               |& \ \mf{"(" <exp> "," <exp> ")"}\\
               |& \ \mf{"\textbackslash" <pattern> "->" <exp>}\\
               |& \ \mf{<upper-var>}\\
               |& \ \mf{<lower-var>}
\end{align*}
\end{center}
%\end{mdframed}
\caption{Syntax for Expressions}
\label{fig:exp-syntax}
\end{figure}

```{definition,name="Expression Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$
\begin{aligned}
\mf{<list-exp-field>} \ ::=& \ \mf{<lower-var> "=" <exp>} \\
                          |& \ \mf{<lower-var> "=" <exp> "," <list-exp-field>}
\end{aligned}
$$
$$\mf{<maybe-signature>} ::= \mf{""} \ | \ \mf{<lower-var> ":" <type> ";"}$$
$$
\begin{aligned}
\mf{<list-case>} \ ::=& \ \mf{<pattern> "->" <exp>}\\ 
                     |& \ \mf{<pattern> "->" <exp> ";" <list-case>}
\end{aligned}
$$
$$\mf{<bool>} \ ::= \ \mf{"True"} \ | \ \mf{"False"}$$
$$\mf{<int>} \ ::= \ \mf{"0"} \ | \ \mf{"-1"} \ | \ \mf{"1"} \ | \ \mf{"-2"} \ | \ \mf{"2"} \ | \ \dots$$
$$\mf{<list-exp>} ::= \mf{""} \ | \ \mf{<exp>} \ | \ \mf{<exp> "," <list-exp>}$$

The definition of `<exp>` can be found in figure \ref{fig:exp-syntax}.
```

Additionally Elm also allows global constants, type aliases and custom types.

```{definition,name="Statement Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$
\begin{aligned}
\mf{<list-sort>} ::=& \mf{<upper-var> <list-type>} \\
                   |& \ \mf{<upper-var> <list-type> | <list-sort>}
\end{aligned}
$$
$$
\begin{aligned}
  \mf{<list-statement>} \ ::=& \ \mf{""} \ | \ \mf{<statement> ";"} \\
                            |& \ \mf{<statement> ";" <list-statement>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<statement>} \ ::=& \ \mf{<maybe-signature> <lower-var> "=" <exp>}\\
                     |& \ \mf{"type" "alias" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <type>}\\
                     |& \ \mf{"type" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <upper-var> <list-sort>}\\
\end{aligned}
$$
$$\mf{<maybe-main-sign>} \ ::= \ \mf{""} | \mf{"main" ":" <type> ";"}$$
$$\mf{<program>} \ ::= \ \mf{<list-statement> <maybe-main-sign> "main" "=" <exp>}$$
```

```{block2, type="myexample",latex.options="_"}
\label{ex:reverse_list}
Using this syntax we can now write a function that reverses a list.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl
    (::)
    [];

main : Int
main =
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
```