### Syntax

Elm differentiates variables depending on the capitalization of the first letter. For the formal language we define `<upper-var>`$\in\mathcal{T}$ for variables with the first letter capitalized and `<lower-var>`$\in\mathcal{T}$ for variables without.

Syntactically we can build our types from booleans, integers, lists, tuples, records, functions, custom types and type variables.

We will define our syntax in a Backus-Naur-Form [@backus-naur-form].

```{definition,name="Type Signiture Syntax"}
We define the following types:
$$
  \mf{<upper-var>}\in\mathcal{T}
$$
$$
  \mf{<lower-var>}\in\mathcal{T}
$$
$$\mf{<list-lower-var>} \ ::= \ \mf{""} \ | \ \mf{<lower-var>} \ | \ \mf{<lower-var>} \ \mf{<list-lower-var>}$$
$$
\begin{aligned}
\mf{<list-type-fields>} \ ::=& \ \mf{""} \ | \ \mf{<lower-var> ":" <type>} \\
                       |& \mf{<lower-var> ":" <type> "," <list-type-fields>}
\end{aligned}
$$
$$\mf{<list-type>} \ ::= \ \mf{""} \ | \ \mf{<type> \ | \ <type>} \ \mf{<list-type>}$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{"Bool"}\\
              |& \mf{"Int"}\\
              |& \mf{"List" <type>}\\
              |& \mf{"(" <type> "," <type> ")"}\\
              |& \mf{"{" <list-type-fields> "}"}\\
              |& \mf{<type> "->" <type>}\\
              |& \mf{<upper-var> <list-type>}\\
              |& \mf{<lower-var>}\\
\end{aligned}
$$
```

For matching expressions we allow various pattern.

```{definition,name="Pattern Syntax"}
We define the following types:
$$
\begin{aligned}
\mf{<list-pattern-list>} \ ::=& \ \mf{""} \ | \ \mf{<pattern>} \\
                             |& \ \mf{<pattern> "," <list-pattern-list>}
\end{aligned}
$$
$$\mf{<list-pattern-sort>} \ ::= \ \mf{""} \ | \ \mf{<pattern>} \ | \ \mf{<pattern> <list-pattern-sort>}$$
$$
\begin{aligned}
\mf{<list-pattern-vars>} \ ::=& \ \mf{""} \ | \ \mf{<lower-var>} \\
                             |& \ \mf{<lower-var> "," <list-pattern-vars>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<pattern>} \ ::=& \ \mf{<bool>}\\
                   |& \ \mf{<int>}\\
                   |& \ \mf{"[" <list-pattern-list> "]"}\\
                   |& \ \mf{"(" <pattern> , <pattern> ")"}\\
                   |& \ \mf{<upper-var> <list-pattern-sort>}\\
                   |& \ \mf{<lower-var>}\\
                   |& \ \mf{<pattern> "as" <lower-var>}\\
                   |& \ \mf{"\{" <list-pattern-vars> "\}"}\\
                   |& \ \mf{<pattern> "::" <pattern>}\\
                   |& \ \mf{"-"}
\end{aligned}
$$
```

Because Elm is a pure functional programming language, a program contains just a single expression.

\begin{figure}[htbp]
\begin{mdframed}
\begin{center}
\begin{align*}
\mf{<exp>} \ ::=& \ \mf{"foldl"}\\
               |& \ \mf{"(::)"}\\
               |& \ \mf{"(+)"} \ | \ \mf{"(-)"} \ | \ \mf{"(*)"} \ | \ \mf{"(//)"}\\
               |& \ \mf{"(<)"} \ | \ \mf{"(==)"}\\
               |& \ \mf{"not"} \ | \ \mf{"(\&\&)"} \ | \ \mf{"(||)"}\\
               |& \ \mf{<exp> "|>" <exp>}\\
               |& \ \mf{<exp> ">>" <exp>}\\
               |& \ \mf{"if" <exp> "then" <exp> "else" <exp>}\\
               |& \ \mf{"\{" <list-exp-field> "\}"}\\
               |& \ \mf{"\{\}"}\\
               |& \ \mf{"\{" <lower-var> "|" <list-exp-field> "\}"}\\
               |& \ \mf{<lower-var> "." <lower-var>}\\
               |& \ \mf{"let" <maybe-signature> <lower-var> "=" <exp> "in" <exp>}\\
               |& \ \mf{"case" <exp> "of" "[" <list-case> "]"}\\
               |& \ \mf{<exp> <exp>}\\
               |& \ \mf{<bool>}\\
               |& \ \mf{<int>}\\
               |& \ \mf{"[" <list-exp> "]"}\\
               |& \ \mf{"(" <exp> "," <exp> ")"}\\
               |& \ \mf{"\textbackslash" <pattern> "->" <exp>}\\
               |& \ \mf{<upper-var>}\\
               |& \ \mf{<lower-var>}
\end{align*}
\end{center}
\end{mdframed}
\caption{Syntax for Expressions}
\label{fig:exp-syntax}
\end{figure}

```{definition,name="Expression Syntax"}
We define the following types:
$$
\begin{aligned}
\mf{<list-exp-field>} \ ::=& \ \mf{<lower-var> "=" <exp>} \\
                          |& \ \mf{<lower-var> "=" <exp> "," <list-exp-field>}
\end{aligned}
$$
$$\mf{<maybe-signature>} ::= \mf{""} \ | \ \mf{<lower-var> ":" <type> ";"}$$
$$
\begin{aligned}
\mf{<list-case>} \ ::=& \ \mf{<pattern> "->" <exp>}\\ 
                     |& \ \mf{<pattern> "->" <exp> ";" <list-case>}
\end{aligned}
$$
$$\mf{<bool>} \ ::= \ \mf{"True"} \ | \ \mf{"False"}$$
$$\mf{<int>} \ ::= \ \mf{"0"} \ | \ \mf{"-1"} \ | \ \mf{"1"} \ | \ \mf{"-2"} \ | \ \mf{"2"} \ | \ \dots$$
$$\mf{<list-exp>} ::= \mf{""} \ | \ \mf{<exp>} \ | \ \mf{<exp> "," <list-exp>}$$

The definition of `<exp>` can be found in figure \ref{fig:exp-syntax}.
```

Additionally, Elm also allows global constants, type aliases and custom types.

```{definition,name="Statement Syntax"}
We define the following types:
$$
\begin{aligned}
\mf{<list-sort>} ::=& \mf{<upper-var> <list-type>} \\
                   |& \ \mf{<upper-var> <list-type> | <list-sort>}
\end{aligned}
$$
$$
\begin{aligned}
  \mf{<list-statement>} \ ::=& \ \mf{""} \ | \ \mf{<statement> ";"} \\
                            |& \ \mf{<statement> ";" <list-statement>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<statement>} \ ::=& \ \mf{<maybe-signature> <lower-var> "=" <exp>}\\
                     |& \ \mf{"type" "alias" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <type>}\\
                     |& \ \mf{"type" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <upper-var> <list-sort>}\\
\end{aligned}
$$
$$\mf{<maybe-main-sign>} \ ::= \ \mf{""} | \mf{"main" ":" <type> ";"}$$
$$\mf{<program>} \ ::= \ \mf{<list-statement> <maybe-main-sign> "main" "=" <exp>}$$
```

```{block2, type="myexample",latex.options="_"}
\label{ex:reverse_list}
Using this syntax we can now write a function that reverses a list.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl
    (::)
    [];

main : Int
main =
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}

`foldl` iterates over the list from left to right.
It takes the function `(::)`, that appends an element to a list, and the empty list as the starting list. The `main` function reverses the list and returns the first element: $3$. Elm requires you also provide return values for other cases that may occur, like the empty list. In that case we just return $-1$. This will never happened, as long as the reverse function is correctly implemented.
```