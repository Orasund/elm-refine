### Types system

We have already defined Boolean and lists in example \cite{ex:bool_list}. Integers where defined in example \cite{ex:int}. For records we use unordered union types and for tuples we use ordered union types. Note that tuples in Elm only come as pairs $T_1\times T_2$. Custom types are type applications. Functions and type variables have the expected definition.

To reason about the syntax we need a interpretation of the most basic elements.
```{definition,name="partial Interpretation"}
\begin{letIn}
n\in\mathbb{N};\quad
t:mf{<type>};\quad
c:\mf{<upper-var>};\quad
\forall i\in\mathbb{N}_1^2.t_i:\mf{<type>};\\
\forall i\in\mathbb{N}_3^n.t_i:\mf{<type>};\quad
\forall i\in\mathbb{N}_1^n.v_i:\mf{<lower-var>};\quad
\syntax{.}:\mf{<lower-var>}\to\mathcal{V};\\
\syntax{.}:\mf{<upper-var>}\to\mathcal{V};\quad
\syntax{.}:\mf{<type>}\to\mathcal{T}.
\end{letIn}
We call $I$ a partial interpretation iff

$$
\begin{aligned}
  \syntax{\_":"Bool} : & \mathit{Bool}\\
  \syntax{\_":"Int} : & \mathit{Int}\\
  \syntax{\_":"List \ $t$} :& \mathit{List} \ \syntax{$t$})\\
  \syntax{\_":" "(" $t_1$ , $t_2$ ")"} :& \syntax{$t_1$} \times \syntax{$t_2$}\\
  \syntax{\_":" "\{\}"} :& \mathit{\{\}}\\
  \syntax{\_":" "\{" $v_1$ ":" $t_1$ "," \dots "," $v_1$ ":" $t_n$ "\}"} :& \{\syntax{\_":" $v_1$}_I:\syntax{$t_1$} , \dots , \syntax{$v_n$}:\syntax{$t_n$}\}\\
  \syntax{\_":" $t_1$ "->" $t_2$} :& \syntax{$t_1$} \to \syntax{$t_2$}\\
  \syntax{\_":" $c$ $t_1$ .. $t_n$} :& [\syntax{$c$}]_{a_1\mapsto t_1,\dots,a_n\mapsto t_n}
\end{aligned}
$$
```
The interpretation is only partial, as it does not say consider interprating patterns, expressions or statements. This will be done after we have ensured that the types are valid.

#### Type inference

Before we define the type inference, we first need to define the Context $\Gamma$. This context will then hold the conditions under which the type can be inferred.

```{definition,name="Context"}
We define $\Gamma\subseteq \mathcal{V} \times \mathcal{T}$ to be the _context_ of a type inference.
```

The first two universial inference rules for any Hindley-Milner type system are the instantiation and the generalization.

```{definition,name="Instantiation, Generalization"}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Gamma\vdash\syntax{e}:T'
}
{\Gamma\vdash \syntax{e}:T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Gamma\quad
\Gamma\vdash \syntax{e}:T
}
{\Gamma\vdash \syntax{e}:\mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be infered, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be infered, then the same holds for a poly type, binding the free variable.

#### type inferene for Expressions
```{definition,name="type inference for expressions"}
\begin{letIn}
n\in\mathbb{N};\quad
T:\mathcal{T};\quad
v:\mf{<lower-var>};\quad
a:\mathcal{V};\quad
e:\mf{<exp>};\quad
\forall i\in\mathbb{N}_0^3.T_i:\mathcal{T};\\
\forall i\in\mathbb{N}_4^n.T_i:\mathcal{T};\quad
\forall i\in\mathbb{N}_0^3.v_i:\mf{<lower-var>};\quad
\forall i\in\mathbb{N}_4^n.v_i:\mf{<lower-var>};\\
\forall i\in\mathbb{N}_0^3.a_i:\mathcal{V};\quad
\forall i\in\mathbb{N}_4^n.a_i:\mathcal{V};\quad
\forall i\in\mathbb{N}_0^3.e_i:\mf{<exp>};\quad
\forall i\in\mathbb{N}_4^n.e_i:\mf{<exp>};\\
p:\mf{<pattern>};\quad
\mathit{le}:\mf{<list.exp>};\quad
\mathit{lc}:\mf{<list-case>};\quad
c:\mf{<upper-var>};\\
t:\mf{<type>}.
\end{letIn}
\begin{center}
\begin{xtabular}{c l}

\logicRule
{\syntax{$v$}=a
(a,T)\in\Gamma
}
{\Gamma\vdash\syntax{$v$}:T}
{TVariable}

\logicRule
{\syntax{$c$}=a\quad
(a,T)\in\Gamma
}
{\Gamma\vdash\syntax{$c$}:T}
{TConstructor}

\logicRule
{\Gamma\vdash match_\Delta(T_1,\syntax{$p$})\quad
\Gamma\cup\Delta\vdash\syntax{$e$}:T_2
}
{\Gamma\vdash\syntax{"\" $p$ "->" $e$}:T_1\to T_2}
{TLambda}

\logicRule
{\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\syntax{$e_2$}:T_2
}
{\Gamma\vdash\syntax{"(" $e_1$ "," $e_2$ ")"}:T_1\times T_2}
{TTuple}

\logicRule
{}
{\vdash\syntax{"[]"}:\forall a.\mathit{List} \ a}
{TEmptyList}

\logicRule
{
\Gamma\vdash\syntax{$e$}:T\quad
\Gamma\vdash\syntax{$\mathit{le}$}:\mathit{List} \ T
}
{\Gamma\vdash\syntax{" $e$ "," $\mathit{le}$ "}: \mathit{List} \ T}
{TList}

\logicRule
{}
{\vdash\syntax{$\_$:<int>}:\mathit{Int}}
{TInt}

\logicRule
{}
{\vdash\syntax{$\_$:<bool>}:\mathit{Bool}}
{TBool}

\logicRule
{\Gamma\vdash\syntax{$e_1$}:T_1\to T_2\quad
\Gamma\vdash\syntax{$e_2$}:T_1
}
{\Gamma\vdash\syntax{$e_1$ $e_2$}:T_2}
{TCall}

\logicRule
{\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\text{match}_\Delta(T_1,\syntax{$p$})\quad
\Gamma\cup\Delta\vdash\syntax{$e_2$}:T_2
}
{\Gamma\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ "]"}:T_2}
{TSingleCaseOf}

\logicRule
{\begin{gathered}
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\text{match}_\Delta(T_1,\syntax{$p$})\quad
\Gamma\cup\Delta\vdash\syntax{$e_2$}:T_2\quad\\
\Gamma\vdash\syntax{"case" $e_1$ "of" "[" $\mathit{lc}$ "]"}:T_2
\end{gathered}
}
{\Gamma\vdash\syntax{"case" $e_1$ "of" "[" $p$ "->" $e_2$ ";" $\mathit{lc}$ "]"}:T_2}
{TCaseOf}

\logicRule
{\syntax{$v$}=a\quad
(a,_)\not\in\Gamma\quad
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\cup\{(a,T_1)\}\vdash\syntax{$e_2$}:T_2
}
{\Gamma\vdash\syntax{"let" $v$ "=" $e_1$ "in" $e_2$}:T_2}
{TLetIn}

\logicRule
{\syntax{$v$}=a\quad
(a,\_)\not\in\Gamma\quad
\syntax{$v$ ":" t}:T_1\\
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\cup\{(a,T_1)\}\vdash\syntax{$e_2$}:T_2
}
{\Gamma\vdash\syntax{"let" $v$ ":" $t$ ";" $v$ "=" $e_1$ "in" $e_2$}:T_2}
{TLetIn2}

\logicRule
{\syntax{$v_1$}=a_1\quad
\syntax{$v_2$}=a_2\quad
(a_1,\{a_2:T,..\})\in\Gamma
}
{\Gamma\vdash\syntax{$v_1$ "." $v_2$}:T}
{TGetter}

\logicRule
{(v,T)\in\Gamma
}
{\Gamma\vdash\syntax{"\{" $v$ "|" $\_$:<list-exp-field> "\}"}:T}
{TSetter}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{TEmptyRecord}

\logicRule
{\Gamma\vdash\forall i \in\mathbb{N}_1^n.\syntax{$v_i$}:T_i
}
{\Gamma\vdash\syntax{"\{" $v_1$ "=" $e_1$ "," \dots "," $v_n$ "=" $e_n$ "\}"}:\{v_1:T_1,\dots,v_n:T_n\}
}
{TRecord}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:\textit{Bool}\quad
\Gamma\vdash\syntax{$e_2$}:T\quad
\Gamma\vdash\syntax{$e_3$}:T
}
{\Gamma\vdash\syntax{"if" $e_1$ "then" $e_2$ "else" $e_3$}:T}
{TIfElse}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:T_1 \to T_2\quad
\Gamma\vdash\syntax{$e_2$}:T_2 \to T_3
}
{\Gamma\vdash\syntax{$e_1$ ">>" $e_2$}:T_1 \to T_3}
{TComposition}

\logicRule
{
\Gamma\vdash\syntax{$e_1$}:T_1\quad
\Gamma\vdash\syntax{$e_2$}:T_1 \to T_2
}
{\Gamma\vdash\syntax{$e_1$ "|>" $e_2$}:T_2}
{TPipe}

\logicRule
{}
{\vdash\syntax{"(||)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TOr}

\logicRule
{}
{\vdash\syntax{"(\&\&)"}:\mathit{Bool}\to \mathit{Bool}\to \mathit{Bool}}
{TAnd}

\logicRule
{}
{\vdash\syntax{"not"}:\mathit{Bool}\to \mathit{Bool}}
{Not}

\logicRule
{}
{\vdash\syntax{"(==)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TEqual}

\logicRule
{}
{\vdash\syntax{"(<)"}:\mathit{Int}\to \mathit{Int}\to\mathit{Bool}}
{TLess}

\logicRule
{}
{\vdash\syntax{"(//)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TDivide}

\logicRule
{}
{\vdash\syntax{"(*)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMultiply}

\logicRule
{}
{\vdash\syntax{"(-)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TMinus}

\logicRule
{}
{\vdash\syntax{"(+)"}:\mathit{Int}\to \mathit{Int}\to\mathit{int}}
{TPlus}

\logicRule
{}
{\vdash\syntax{"(::)"}:\forall a.a\to\mathit{List}\ a\to\mathit{List}\ a}
{TCons}

\logicRule
{}
{\vdash\syntax{"foldl"}:\forall a.\forall b.(a\to b)\to b\to\mathit{List}\ a\to b}
{TFoldl}

\end{xtabular}
\end{center}
```

\begin{description}
\item[TVariable,TConstructor] First interprete the syntacticall variable and find the type in the context.
\item[TLambda] Elm allows the parameters of a function to be pattern matched. Therefore we first need to find a patching type $T_1$ and can then infer the type of $e$ by including the additional bindings $\Delta$ to the context.
\item[TEmptyList] The empty list is a literal for every list, therefore we can infer the most general of all lists.
\item[TList] Recursively we check that every element has the same type.
\item[TInt,TBool] The type of Literals infered without any restrictions.
\item[TCall] The first expression needs to be a function that the the second type can be passed to.
\item[TSingleCaseOf,TCaseOf] First match the type of the expression $e_1$ to the pattern, then use the additional bindings $\Delta$ to obtain the type of $e_2$. As all patterns need to have the same type, we can then recursively check the other patterns as well.
\item[TLetIn,TLetIn2] the variable $a$ may not have a value assined in the conext $\Gamma$. If so, we can infer the type $T_1$ of $e_1$ and add $(a,T_1)$ to the context before we evaluate $e_2$. For $[TLetIn2]$ we already the type is already given as $t$. Note that $t$ can more specific as the type we would usually infer.
\end{description}

#### Patterns

For pattern matching we do not only want to infer a type that matches the pattern, but also find all substitutions for doing so. We will see that patterns also allow for variable declarations by using the `as` keyword.

```{definition,name="Type inference for pattern matching"}
\begin{letIn}\Delta\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
p:\mf{<pattern>};\quad
v:\mf{<lower-var>};\quad
T:\mathcal{T};\\
\forall i\in\mathbb{N}_0^2.p_i:\mf{<pattern>};\quad
\forall i\in\mathbb{N}_3^n.p_i:\mf{<pattern>};\\
\forall i\in\mathbb{N}_0^n.v_i:\mf{<lower-var>};\quad
\forall i\in\mathbb{N}_0^n.T_i:\mathcal{T};\\
\forall i\in\mathbb{N}_0^3.\Delta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\quad
\forall i\in\mathbb{N}_4^n.\Delta_i\subseteq \mf{<lower-var>}\times\mathcal{T};\\
lpl:\mf{<list-pattern-list>}
\end{letIn}

we say a pattern $p$ matches a type $T$ for the context $\Gamma$ using the bindings $\Delta$ if $\Gamma\vdash \text{match}_\Delta(T,p)$.

$\Delta$ contains the minimal substitutions and variable bindings needed to match the type to the pattern.

Instantiation and Generalization applies to pattern matching as well.

\begin{center}
\begin{tabular}{c l}
\logicRule
{
 T' \sqsubseteq T\quad
 \Gamma\vdash \text{match}_\Delta(T',\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Delta(T,\syntax{e})
}
{PInstantiation}

\logicRule
{(a,\_)\not\in\Gamma\quad
\Gamma\vdash \text{match}_\Delta(T,\syntax{e})
}
{
  \Gamma\vdash \text{match}_\Delta(\forall a.T,\syntax{e})
}
{PGeneralization}
\end{tabular}
\end{center}

The type inference rules for pattern matching are as follows

\begin{center}
\begin{xtabular}{c l}
\logicRule{}{\vdash \text{match}_\varnothing(\mathit{Bool},$\_$:\syntax{<bool>})}{PBool}

\logicRule{}{\vdash \text{match}_\varnothing(\mathit{Int},$\_$:\syntax{<int>})}{PInt}

\logicRule{}
{\vdash \text{match}_\varnothing(\forall a.\mathit{List} \ a,\syntax{"[]"})}
{PEmptyList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Delta_1}(T_1,\syntax{$p$})\quad
\Gamma\vdash \text{match}_{\Delta_2}(T_2,\syntax{"[" $lpl$ "]"})\quad\\
\Delta_1\cap\Delta_2=\varnothing\quad
\Delta_1\cup\Delta_2=\Delta_3\quad
T_2 = \textit{List} \ T_1
\end{gathered}
}
{\Gamma\vdash \text{match}_{\Delta_3}(T_2,\syntax{"[" $p$ "," $lpl$ "]"}
}
{PList}

\logicRule
{\begin{gathered}
\Gamma\vdash \text{match}_{\Delta_1}(T_1,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Delta_2}(T_2,\syntax{$p_2$})\quad\\
\Delta_1\cap\Delta_2=\varnothing\quad
\Delta_1\cup\Delta_2=\Delta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Delta_3}(T_1 \times T_2,\syntax{"(" $p_1$ "," $p_2$ ")"})
}
{PTuple}

\logicRule
{(v,\_)\not\in\Gamma\quad
\Delta = \{(v,T)\}
}
{\Gamma\vdash \text{match}_{\Delta}(T,\syntax{$v$})
}
{PVariable}

\logicRule
{(v,T)\in\Gamma}
{\Gamma\vdash \text{match}_\varnothing(T,\syntax{$v$})}
{PSingleAppication}

\logicRule
{
\begin{gathered}
\Gamma\vdash \forall i\in\mathbb{N}_1^n.\text{match}_{\Delta_i}(\syntax{$p_i$}:T_i)\quad\\
(p_0,T_1\to \dots \to T_n\to T_0)\in\Gamma\quad\\
\forall i\in\mathbb{N}_1^n.\forall j\in\mathbb{N}_1^n.i\neq j \Rightarrow\Delta_i\cap \Delta_j = \varnothing\quad
\Delta_0 = \bigcup_{i\in\mathbb{N}_1^n}\Delta_i
\end{gathered} 
}
{
\Gamma\vdash \text{match}_{\Delta_0}(T_0,\syntax{$p_0$ $p_1$ .. $p_n$})
}
{PApplication}

\logicRule
{(v,\_)\not\in\Gamma\quad
(v,T)\in\Delta\quad
\Gamma\vdash \text{match}_{\Delta\backslash\{(v,T)\}}(T,\syntax{$p$})\quad
}
{\Gamma\vdash \text{match}_\Delta(T,\syntax{$p$ "as" $v$})}
{PAs}

\logicRule
{}
{\vdash \text{match}_\varnothing(\{\},\syntax{"\{\}"})}
{PEmptyRecord}

\logicRule
{
\begin{gathered}
k:\mathbb{N}_1^m\to\mathbb{N}_1^n\quad
k \text{ is injective}\quad\quad
\forall i\in\mathcal{N}_1^n.(v_{k(i)},\_)\not\in\Gamma\\
\Gamma = \bigcup_{i\in\mathbb{N}_1^n} \{(v_{k(i)},T_{k(i))}\}\quad
T = \{v_1:T_1,\dots,v_n:T_n\}
\end{gathered}
}
{\Gamma\vdash \text{match}_\Delta(T,\syntax{"\{" $v_{k_1}$ "," $\dots$ "," $v_{k_m}$ "\}"})
}
{PRecord}

\logicRule
{
\begin{gathered}
\Gamma\vdash \text{match}_{\Delta_1}(T,\syntax{$p_1$})\quad
\Gamma\vdash \text{match}_{\Delta_2}(List \ T,\syntax{$p_2$})\quad\\
\Delta_1\cap\Delta_2=\varnothing\quad
\Delta_1\cup\Delta_2=\Delta_3
\end{gathered}
}
{
\Gamma\vdash \text{match}_{\Delta_3}(\textit{List} \ T,\syntax{$p_1$ "::" $p_2$})
}
{PHeadAndTail}

\logicRule
{}
{\Gamma\vdash \text{match}_\varnothing(\forall a. a,\syntax{"\_"})}
{PWildcard}

\end{xtabular}
\end{center}
```

```{block2, type="myexample",latex.options="_"}
Looking back at our list reversing example, we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$ and $\Gamma = \varnothing$.

We start by proving $\vdash \text{match}_\varnothing(\mathit{List} \ \mathit{Int},\syntax{"\_"})$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[PWildcard]}$}
  \UnaryInfC{$\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
\RightLabel{$\mathit{[PInstantiation]}$}
\UnaryInfC{$\vdash \text{match}_\varnothing(\textit{List} \ \text{Int},\syntax{"\_"})$}
\end{prooftree}
\end{center}

Next we prove $\vdash \text{match}_\Delta(\textit{List} \ \textit{Int},\syntax{\(a\):<lower-var> " :: \_"})$ for $\Delta=\{(a,\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\vdash \text{match}_\Delta(\textit{Int},\syntax{a})$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Delta\cap\varnothing=\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\forall a.a,\syntax{"\_"})$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash \text{match}_\varnothing(\textit{List} \ \textit{Int},\syntax{"\_"})$}
\RightLabel{$(1)$}
\TrinaryInfC{$\vdash \text{match}_\Delta(\textit{List} \ \textit{Int},\syntax{a:<lower-var> " :: \_"})$}
\end{prooftree}
\end{center}
$(1) \mathit{[PHeadAndTail]}, (2) \mathit{[PInstantiation]}, (3) \mathit{[PWildcard]},(4) \mathit{[PVariable]}$
```