### Inference Rules for patterns

#### list-pattern-list

Judgment: $\Gamma,\Delta\vdash:\text{match}_\Theta (\mathit{List} \ T,\mathit{lpl})$

\logicRule
{}
{\Gamma,\Delta\vdash:\text{match}_\varnothing (\forall a. List \ a,\mf{""})}
{}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash:\text{match}_{\Theta_1} (T,p)\\
\Gamma,\Delta\vdash:\text{match}_{\Theta_2} (\mathit{List} \ T,\mathit{lpl})\quad
\Theta_1\cap\Theta_2 = \varnothing\quad
\Theta_3 = \text{insert}_{\Theta_1}(\Theta_2)
\end{gathered}
}
{\Gamma,\Delta\vdash:\text{match}_{\Theta_3} (\mathit{List} \ T,p \ \mf{","} \ \mathit{lpl})}
{}
$\Theta_3$ is the set of all bindings in the list with head $p$ and tail $\mathit{lpl}$. Variables may only bound once, therefore we need to ensure that the binding $\Theta_1$ of $p$ and the binding $\Theta_2$ of $\mathit{lpl}$ are disjoint.

#### list-pattern-sort

Judgment: $\Gamma,\Delta\vdash\text{match}_\Theta ((T_1,\dots,T_n),\mathit{lps})$

\logicRule
{}
{\Gamma,\Delta\vdash:\text{match}_\Theta ((),\mf{""})}
{}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash:\text{match}_{\Theta_1} (T_0,p)\\
\Gamma,\Delta\vdash:\text{match}_{\Theta_2} ((T_1,\dots,T_n),\mathit{lps})\quad
\Theta_1\cap\Theta_2 = \varnothing\quad
\Theta_3 = \text{insert}_{\Theta_1}(\Theta_2)
\end{gathered}
}
{\Gamma,\Delta\vdash:\text{match}_{\Theta_3} ((T_0,T_1,\dots,T_n),p \ \mathit{lps})}
{}

#### list-pattern-vars

Judgment: $\mathit{lpv}:(a_1,\dots,a_n)$

\logicRule
{}
{\mf{""}:()}
{}

\logicRule
{\mathit{lpv}:(a_1,\dots,a_n)}
{a_0 \ \mf{""} \ \mathit{lpv}:(a_0,a_1,\dots,a_n)}
{}

#### pattern

\logicRule
{b:\mathit{Bool}}
{\Gamma,\Delta\vdash \text{match}_\varnothing(\mathit{Bool},b)}
{}

\logicRule
{i:\mathit{Int}}
{\Gamma,\Delta\vdash \text{match}_\varnothing(\mathit{Int},i)}
{}

\logicRule
{\Gamma,\Delta\vdash \text{match}_{\Theta}(\mathit{List} \ T,\mathit{lpl})
}
{\Gamma,\Delta\vdash \text{match}_{\Theta}(\mathit{List} \ T,\mf{"["} \mathit{lpl} \mf{"]"})}
{}

\logicRule
{\begin{gathered}
\Gamma,\Delta\vdash \text{match}_{\Theta_1}(T_1,p_1)\quad
\Gamma,\Delta\vdash \text{match}_{\Theta_2}(T_2,p_2)\quad\\
\Theta_1\cap\Theta_2=\varnothing\quad
\text{insert}_{\Theta_1}(\Theta_2)=\Theta_3
\end{gathered}
}
{
\Gamma,\Delta\vdash \text{match}_{\Theta_3}((T_1,T_2),\mf{"("} p_1 \mf{","} p_2 \mf{")"})
}
{}

\logicRule
{
c \sqsubseteq_\Delta T_1\to\dots\to T_n \to T_0\quad
\Gamma,\Delta\vdash\text{match}_{\Theta} ((T_1,\dots,T_n),\mathit{lps})
}
{
\Gamma,\Delta\vdash \text{match}_{\Theta}(T_0,c \ \mathit{lps})
}
{}

\logicRule
{(a,\_)\not\in\Delta\quad
\Theta = \{(a,T)\}
}
{\Gamma,\Delta\vdash \text{match}_\Theta(T,a)
}
{}

\logicRule
{(a,\_)\not\in\Delta\quad
(a,\_)\not\in\Theta_1\quad
\text{insert}_{\Theta_1}(\{(a,T)\})=\Theta_2\quad
\Gamma,\Delta\vdash \text{match}_{\Theta_1}(T,p)
}
{\Gamma,\Delta\vdash \text{match}_{\Theta_2}(T,p \mf{"as"} a)}
{}

\logicRule
{\begin{gathered}
\mathit{lpv} = (a_1,\dots,a_n)\quad
T = \{a_1:T_1,\dots,a_n:T_n\}\\
\Delta\cap\{(a_1,\_),\dots,(a_n,\_)\}=\varnothing\quad
\Theta = \{(a_1,T_1),\dots,(a_n,T_n)\}
\end{gathered}
}
{\Gamma,\Delta\vdash \text{match}_\Theta(T,\mf{"\{"} \mathit{lpv} \mf{"\}"})
}
{}

\logicRule
{
\begin{gathered}
\Gamma,\Delta\vdash\text{match}_{\Theta_1}(T,p_1)\quad
\Gamma,\Delta\vdash\text{match}_{\Theta_2}(\textit{List} \ T,p_2)\\
\Theta_1\cap\Theta_2=\varnothing\quad
\text{insert}_{\Theta_1}(\Theta_2)=\Theta_3
\end{gathered}
}
{
\Gamma,\Delta\vdash\text{match}_{\Theta_3}(\textit{List} \ T,p_1 \ \mf{"::"} \ p_2)
}
{}

\logicRule
{}
{\Gamma,\Delta\vdash \text{match}_\varnothing(\forall a. a,\mf{"\_"})}
{}

```{block2, type="myexample",latex.options="_"}
In example \ref{ex:reverse_list} we have looked at the syntax for list reversing function. We will now find the bindings $\Theta_0$ for the following pattern used in the reversing function.

\begin{lstlisting}[language=elm]
  a :: _
\end{lstlisting}
  
We assume that the type of the expression being matched is $\mathit{List} \ \mathit{Int}$ and $\Gamma =\Delta = \varnothing$.

\begin{center}
\tiny
\begin{prooftree}
      \AxiomC{}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
      \AxiomC{}
    \UnaryInfC{$\Theta_1 = \{(a,\textit{Int})\}$}
  \BinaryInfC{$\Gamma,\Delta\vdash\text{match}_{\Theta_1}(\textit{Int},a)$}
        \AxiomC{}
      \UnaryInfC{$\Theta_2=\varnothing$}
    \UnaryInfC{$\Gamma,\Delta\vdash\text{match}_{\Theta_2}(\forall a.a,\mf{\_})$}
  \UnaryInfC{$\Gamma,\Delta\vdash\text{match}_{\Theta_2}(\textit{List} \ \textit{Int},\mf{\_})$}
    \AxiomC{}
  \UnaryInfC{$\text{insert}_{\Theta_1}(\Theta_2)=\Theta_0$}
  \AxiomC{$\Theta_1\cap\Theta_2=\varnothing$}
\QuaternaryInfC{$\varnothing,\varnothing\vdash \text{match}_{\Theta_0}(\textit{List} \ \textit{Int},\mf{a " :: \_"})$}
\end{prooftree}
\end{center}

After ensuring $\Theta_1\cap\Theta_2=\{(a,\textit{Int})\}\cap\varnothing=\varnothing$ we can conclude $$\Theta_0=\text{insert}_{\{(a,Int)\}}(\varnothing)=\{(a,\textit{Int})\}.$$
```
