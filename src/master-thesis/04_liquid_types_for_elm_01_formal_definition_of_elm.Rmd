\setcounter{section}{3}

# Liquid types for Elm

## Formal definition of Elm

### Syntax

Elm differenciates between variables depending on the capitalisation of the first letter. For the formal langauge we define `<upper-letter>`$:\mathcal{V}$ for variables with the first letter capitaliced and `<lower-var>`$:\mathcal{V}$ for variables without.

Syntactically we can build our types from booleans, intergers, lists, tuples, records, functions, custom types and type variables.

```{definition,name="Type Signiture Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$\mf{<list-lower-var>} \ ::= \ \mf{""} \ | \ \mf{<lower-var>} \ | \ \mf{<lower-var>} \ \mf{<list-lower-var>}$$
$$\mf{<list-type>} \ ::= \ \mf{""} \ | \ \mf{<type> <type>} \ \mf{<list-type>}$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{"Bool"}\\
               &| \mf{"Int"}\\
               &| \mf{"List" <type>}\\
               &| \mf{"(" <type> "," <type> ")"}\\
               &| \mf{"{" <type-fields> "}"}\\
               &| \mf{<type> "->" <type>}\\
               &| \mf{<upper-var> <list-type>}\\
               &| \mf{<lower-var>}\\
\end{aligned}
$$
```

For matching expressions we allow various pattern.

```{definition,name="Pattern Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$
\begin{aligned}
\mf{<list-pattern-list>} \ ::=& \ \mf{""} \ | \ \mf{<pattern>} \\
                             |& \ \mf{<pattern> "," <list-pattern-list>}
\end{aligned}
$$
$$\mf{<list-pattern-sort>} \ ::= \ \mf{""} \ | \ \mf{<pattern>} \ | \ \mf{<pattern> <list-pattern-list>}$$
$$
\begin{aligned}
\mf{<list-pattern-vars>} \ ::=& \ \mf{""} \ | \ \mf{<lower-var>} \\
                             |& \ \mf{<pattern> "," <list-pattern-vars>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<pattern>} \ ::=& \ \mf{<bool>}\\
                   |& \ \mf{<int>}\\
                   |& \ \mf{"[" <list-pattern-list> "]"}\\
                   |& \ \mf{"(" <pattern> , <pattern> ")"}\\
                   |& \ \mf{<upper-var> <list-pattern-sort>}\\
                   |& \ \mf{<lower-var>}\\
                   |& \ \mf{<pattern> "as" <lower-var>}\\
                   |& \ \mf{"{" <list-pattern-vars> "}"}\\
                   |& \ \mf{<pattern> "::" <pattern>}\\
                   |& \ \mf{"-"}
\end{aligned}
$$
```

Because Elm is a pure functional programming language, a programm contains a single expression.

\begin{figure}[htbp]
\begin{mdframed}
\begin{center}
\begin{align*}
\mf{<exp>} \ ::=& \ \mf{"foldl"}\\
               |& \ \mf{"(::)"}\\
               |& \ \mf{"(+)"} \ | \ \mf{"(-)"} \ | \ \mf{"(*)"} \ | \ \mf{"(//)"}\\
               |& \ \mf{"(<)"} \ | \ \mf{"(==)"}\\
               |& \ \mf{"not"} \ | \ \mf{"(\&\&)"} \ | \ \mf{"(||)"}\\
               |& \ \mf{<exp> "|>" <exp>}\\
               |& \ \mf{<exp> ">>" <exp>}\\
               |& \ \mf{"if" <exp> "then" <exp> "else" <exp>}\\
               |& \ \mf{"{" <list-exp-field> "}"}\\
               |& \ \mf{"{}"}\\
               |& \ \mf{"{" <lower-var> "|" <list-exp-field> "}"}\\
               |& \ \mf{<lower-var> "." <lower-var>}\\
               |& \ \mf{"let" <maybe-signature> <lower-var> "=" <exp> "in" <exp>}\\
               |& \ \mf{"case" <exp> "of" "[" <list-case> "]"}\\
               |& \ \mf{<exp> <exp>}\\
               |& \ \mf{<bool>}\\
               |& \ \mf{<int>}\\
               |& \ \mf{"[" <list-exp> "]"}\\
               |& \ \mf{"(" <exp> "," <exp> ")"}\\
               |& \ \mf{"\textbackslash" <pattern> "->" <exp>}\\
               |& \ \mf{<upper-var>}\\
               |& \ \mf{<lower-var>}
\end{align*}
\end{center}
\end{mdframed}
\caption{Syntax for Expressions}
\label{fig:exp-syntax}
\end{figure}

```{definition,name="Expression Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$
\begin{aligned}
\mf{<list-exp-field>} \ ::=& \ \mf{<lower-var> "=" <exp>} \\
                          |& \ \mf{<lower-var> "=" <exp> "," <list-exp-field>}
\end{aligned}
$$
$$\mf{<maybe-signature>} ::= \mf{""} \ | \ \mf{<lower-var> ":" <type> ";"}$$
$$
\begin{aligned}
\mf{<list-case>} \ ::=& \ \mf{<pattern> "->" <exp>}\\ 
                     |& \ \mf{<pattern> "->" <exp> ";" <list-case>}
\end{aligned}
$$
$$\mf{<bool>} \ ::= \ \mf{"True"} \ | \ \mf{"False"}$$
$$\mf{<int>} \ ::= \ \mf{"0"} \ | \ \mf{"-1"} \ | \ \mf{"1"} \ | \ \mf{"-2"} \ | \ \mf{"2"} \ | \ \dots$$
$$\mf{<list-exp>} ::= \mf{""} \ | \ \mf{<exp>} \ | \ \mf{<exp> "," <list-exp>}$$

The definition of `<exp>` can be found in figure \ref{fig:exp-syntax}.
```

Additionally Elm also allows global constants, type aliases and custom types.

```{definition,name="Statement Syntax"}
\begin{letIn}
  \mf{<upper-letter>}:\mathcal{V};\quad
  \mf{<lower-var>}:\mathcal{V}.
\end{letIn}
We define the following types:
$$\mf{<list-sort>} ::= \mf{<upper-letter>}$$
$$
\begin{aligned}
  \mf{<list-statement>} \ ::=& \ \mf{""} \ | \ \mf{<statement> ";"} \\
                            |& \ \mf{<statement> ";" <list-statement>}\\
\end{aligned}
$$
$$
\begin{aligned}
\mf{<statement>} \ ::=& \ \mf{<maybe-signature> <lower-var> "=" <exp>}\\
                     |& \ \mf{"type" "alias" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <type>}\\
                     |& \ \mf{"type" <upper-var> <list-lower-var>}\\
                      &\quad\mf{"=" <upper-var> <list-type>}\\
\end{aligned}
$$
$$\mf{<maybe-main-sign>} \ ::= \ \mf{""} | \mf{"main" ":" <type> ";"}$$
$$\mf{<program>} \ ::= \ \mf{<list-statement> <maybe-main-sign> "main" "=" <exp>}$$
```

```{block2, type="myexample",latex.options="_"}
Using this syntax we can now write a function that reverses a list.

\begin{lstlisting}[language=elm]
reverse : List a -> List a
reverse =
  foldl
    (::)
    [];

main : Int
main =
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
```

### Type System

We have already defined Boolean and lists in example \cite{ex:bool_list}. Integers where defined in example \cite{ex:int}. For records we use unordered union types and for tuples we use ordered union types. Note that tuples in Elm only come as pairs $T_1\times T_2$. Custom types are type applications. Functions and type variables have the expected definition.

Before we define the type inference, we first need to define the Context $\Gamma$. This context will then hold the conditions under which the type can be inferred.

```{definition,name="Context"}
We define $\Gamma\subseteq \mathcal{V} \times \mathcal{T}$ to be the _context_ of a type inference.
```

The first two universial inference rules for any Hindley-Milner type system are the instantiation and the generalization.

```{definition,name="Instantiation, Generalization"}
\begin{center}
\begin{tabular}{c l}
\logicRule
{
T' \sqsubseteq T\quad
\Gamma\vdash\syntax{e}:T'
}
{\Gamma\vdash \syntax{e}:T}
{Instantiation}

\logicRule
{(a,\_)\not\in\Gamma\quad
\Gamma\vdash \syntax{e}:T
}
{\Gamma\vdash \syntax{e}:\mathit{\forall a.T}}
{Generalization}
\end{tabular}
\end{center}
```

The $[\mathit{Instantiation}]$ rule says that if a type can be infered, the same holds for a more specific type.
The $[\mathit{Generalization}]$ rule states the opposite: if a type with a free variable can be infered, then the same holds for a poly type, binding the free variable.

#### Patterns

\begin{figure}
\begin{mdframed}
\begin{center}
\begin{tabular}{c l}
\logicRule{}{\vdash \syntax{<bool>}:\mathit{Bool}}{P-Bool}

\logicRule{}{\vdash \syntax{<int>}:\mathit{Int}}{P-Int}

\logicRule{}{\vdash \syntax{"[]"}:\forall a.\mathit{List} \ \mathit{a}}{P-EmptyList}

\logicRule
{
\begin{gathered}
\Gamma_1\vdash\syntax{$p$}:T_1\quad
\Gamma_2\vdash\syntax{"[" $l$ "]"}:T_2\quad\\
T_1\sqsubseteq T_3\quad
T_2\sqsubseteq \textit{List} \ T_3\quad
T_1 \cap T_2 = \varnothing
\Gamma_3 = \Gamma_1\cup\Gamma_2
\end{gathered}
}
{
\Gamma_3\vdash \syntax{"[" $p$:<pattern> "," $l$:<list-pattern-list> "]"}:\textit{List} \ T_3
}
{P-List}

\logicRule
{\Gamma_1\vdash \syntax{$p_1$}:T_1\quad
\Gamma_2\vdash \syntax{$p_1$}:T_2\quad
T_1 \cap T_2 = \varnothing
}
{\Gamma_1\cup\Gamma_2\vdash \syntax{"(" $p_1$:<pattern> "," $p_2$:<pattern> ")"}:T_1 \times T_2}
{P-Tuple}

\logicRule
{I(\syntax{$v$}):a}
{\vdash\syntax{$v$:<lower-var>}:\forall a.a}
{P-Variable}

\logicRule
{C(\syntax{$v$}):T}
{\vdash\syntax{$v$:<upper-var>}:T}
{P-Terminal}

\logicRule
{\Gamma\vdash\syntax{$p_1$}:T_1 \to T_2\quad
\Gamma\vdash\syntax{$p_2$}:T_3\quad
T_2\sqsubseteq T_3
}
{\Gamma\vdash\syntax{$p_1$:<pattern> $p_2$:<pattern>}:T_1}
{P-Application}

\logicRule
{\Gamma\vdash\syntax{$p$}:T\quad
I(\syntax{$v$}):a\quad
\Gamma\cap \{a:T\} = \varnothing
}
{\Gamma\cup \{a:T\}\vdash\syntax{$p$:<pattern> "as" $v$:<lower-var>}:T}
{P-As}

\logicRule
{}
{\vdash\syntax{"\{\}"}:\{\}}
{P-EmptyRecord}

\logicRule
{\begin{gathered}
k:\mathbb{N}_1^m\to\mathcal{N}_1^n\quad
k \text{ is injective}\quad\\
\forall i\in\mathcal{N}_1^n.I(v_i)=l_(k(i))\quad
\Gamma = \bigcup_{i\in\mathcal{N}_1^n} \{(l_{k(i)},T_{k(i))}\}
\end{gathered}}
{\Gamma\vdash\syntax{"{" $v_1$:<lower-var> "," $\dots$ "," $v_m$:<lower-var> "}"}}
{P-Record}

\logicRule
{
\begin{gathered}
\Gamma_1\vdash\syntax{$p_1$}:T_1\quad
\Gamma_2\vdash\syntax{$p_2$}:T_2\quad\\
T_1\sqsubseteq T_3\quad
T_2\sqsubseteq \textit{List} \ T_3\quad
T_1 \cap T_2 = \varnothing
\end{gathered}
}
{
\Gamma_1\cup\Gamma_2\vdash \syntax{$p_1$:<pattern> "::" $p_2$:<pattern>}:\textit{List} \ T_3
}
{P-List}

\logicRule
{}
{\vdash\syntax{"\_"}:\forall a. a}
{P-Wildcard}
\end{tabular}
\end{center}
\end{mdframed}
\caption{Type checking for patterns.}
\label{fig:type_inference}
\end{figure}

For pattern matching we are not interested in finding a type, instead we have given a type want are interested whether a pattern matches that type and if so under what context. This is called type checking and is the reverse of type inference.

The type checking rules for pattern matching can be found in figure \ref{fig:type_inference}.

```{block2, type="myexample",latex.options="_"}
Looking back at our list reversing example, we can check the type of the following pattern matching code.

\begin{lstlisting}[language=elm]
  case [1,2,3] |> reverse of
  [
    a :: _ ->
      a;
    _ ->
      -1
  ]
\end{lstlisting}
  
Lets say we know `[1,2,3] |> reverse` is of type $\mathit{List} \ \mathit{Int}$. We can now check if the pattern has the same type. If so, then there exists a smallest context under which the types are the same. 

We need to find a type $T:\mathcal{T}$ with $T \sqsubseteq \mathit{List} \ \mathit{Int}$ for which $$\Gamma_1\vdash\syntax{\(a\):<lower-var> " :: \_"}:T \text{ and }\Gamma_2\vdash\syntax{"\_"}:T$$ holds. 

We start with $\Gamma_2 \vdash \syntax{"\_"}:T$. We will prove it for $T=\textit{List} \ \textit{Int}$ and $\Gamma_2 = \varnothing$.
\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
  \RightLabel{$\mathit{[P-Wildcard]}$}
  \UnaryInfC{$\vdash \syntax{"\_"}:\forall a.a$}
\RightLabel{$\mathit{[Instantiation]}$}
\UnaryInfC{$\vdash \syntax{"\_"}:\textit{List} \ \text{Int}$}
\end{prooftree}
\end{center}

Next we prove $\Gamma_1 \vdash \syntax{\(a\):<lower-var> " :: \_"}:T$ for $T=\textit{List} \ \textit{Int}$ and $\Gamma_1 = \{(a:\mf{<lower-var>},\textit{Int})\}$.

\begin{center}
\begin{prooftree}
    \AxiomC{$\top$}
    \UnaryInfC{$(a,\_)\not\in\varnothing$}
    \LeftLabel{$(4)$}
  \UnaryInfC{$\Gamma_1 \vdash\syntax{a}:\textit{Int} $}
    \AxiomC{$\top$}
  \UnaryInfC{$\Gamma_1\cap\varnothing=\varnothing$}
    \AxiomC{$\top$}
  \UnaryInfC{$\Gamma_1=\Gamma_1\cup\varnothing$}
      \AxiomC{$\top$}
    \RightLabel{$(3)$}
    \UnaryInfC{$\varnothing\vdash\syntax{"\_"}:\forall a.a$}
  \RightLabel{$(2)$}
  \UnaryInfC{$\varnothing\vdash\syntax{"\_"}:\textit{List} \ \textit{Int}$}
\RightLabel{$(1)$}
\QuaternaryInfC{$\Gamma_1 \vdash \syntax{a:<lower-var> " :: \_"}:\textit{List} \ \textit{Int}$}
\end{prooftree}
\end{center}
$(1) \mathit{[P-HeadAndTail]}, (2) \mathit{[Instantiation]}, (3) \mathit{[P-Wildcard]},(4) \mathit{[P-Variable]}$
```