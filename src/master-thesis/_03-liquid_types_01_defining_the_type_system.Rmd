\setcounter{section}{2}

# Liquid Types

## Defining the Type System

First, we define some notations:

* $\mathbb{N}$ are the natural numbers starting from $1$.
* $\mathbb{N}_0$ are the natural numbers starting from $0$.
* $\mathbb{N}_a^b:=\{i\in \mathbb{N}_0 | a \leq i \land i \leq b\}$ are the natural numbers between $a$ and $b$.
* We'll use "$.$" to separate a quantifier from a statement: $\forall a . b$ and $\exists a . b$.
* Functions will be written as $a_1 \to \dots \to a_n \to b$ instead of $a_1 \times \dots \times a_n \to b$.

For this thesis we will use a Hindley-Milner type system [@Principal_Type-Schemes_for_Functional_Programs].

```{block2, type="axiom" ,latex.options="[Types]_"}
\begin{letIn}
n\in\mathbb{N};\quad \forall i\in\mathbb{N}_a^b.k_i\in\mathbb{N}_0;\quad \forall i\in\mathbb{N}_a^b.C_i\text{ be a unique symbol}.
\end{letIn}

$T$ is a _type_ if either

* (_Type variable_) $T$ is a symbol.

* (_Type application_) $T$ has the form
    $T ::= C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}$
    
    where $\forall i\in\mathbb{N}_1^n \forall j\in\mathbb{N}_0^{k_i}. T_{i,j}$ is a type application or type variable.

* (_Quantified type_) $T$ has the form $T ::= \forall a_1 \dots \forall a_n.T'$

    where $T'$ is a type application or a type variable and $\forall i\in\mathbb{N}_1^n.a_i$ is a type variable.
    
    For applied quantified types, the quantifier moves to the upper most level.

We write $v:T$ to declare that $v$ has the type $T$.
```

```{block2, type="myexample",latex.options="_"}
\begin{letIn}T ::= C \ a \text{ be a type application or a type variable.}\end{letIn}
We will later see that $a$ may be substituted by the quantified type $\forall a.a$.
This would lead to $T::= C \ (\forall a.a)$, but as quantifiers always move to the upper most level, it results in $\forall a.T::= C \ a$ instead.
```

```{block2, type="myexample",latex.options="_"}
The symbol `string` is a valid type. It can be though of as a type, whose implementation is unknown. For real programming languages this is not allowed.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:bool_list}
$\mathit{Bool} ::= \mathit{True} \ | \ \mathit{False}$ is a valid type application.

$\forall a.\mathit{List} \ a ::= \mathit{Empty} \ | \ \mathit{Cons} \ a \ (\mathit{List} \ a)$ is a valid quantified type.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:int}
The natural numbers and the integers can be defined as types using the peano axioms&nbsp;[@peano]:

* $1$ is a natural number.
* Every natural number has a successor.

These axioms can be used for the definition of the type application.

$$\mathit{Nat} ::= 1 \ | \ \mathit{Succ} \ Nat$$

For integers, we can use the property that they contain $0$ as well as all positive and negative numbers.
  
$$\mathit{Int} ::= 0 \ | \ \mathit{Pos} \ \mathit{Nat} \ | \ \mathit{Neg} \ \mathit{Nat}$$
```

```{definition,name="Sets of Types"}
We define

  * $\mathcal{V}$ as the set of all values of type variables.
  * $\mathcal{A}$ as the set of all values of type applications.
  * $\mathcal{Q}$ as the set of all values of quantified types.
  * $\mathcal{T}::= \mathcal{V} \cup \mathcal{A} \cup \mathcal{Q}$ as the set of all values of all types.

&nbsp;
```

Instead of writing "let $a$ be a type application or a type variable" we can now just write $a\in\mathcal{M}$.

```{definition,name="partial function"}
\begin{letIn}
T_1\in\mathcal{T};\quad
T_2\in\mathcal{T}.
\end{letIn}
We define $f \subseteq T_1\times T_2$ as a partial function from $T_1$ to $T_2$.
```

When ever we write $f \subseteq T_1\times T_2$, we assume that f is univariant: $$(x,y_1)\in f \land (x,y_2)\in f \Rightarrow y_1 = y_2$$.

```{definition,name="Sort, Value, Constructor"}
\begin{letIn}
n\in\mathbb{N};\quad
\forall j\in\mathbb{N}_1^n k_j\in\mathbb{N};\quad
{i\in\mathbb{N}_1^n};\quad
\forall j:\mathbb{N}_0^{k_i}.t_j: T_{i,j};\quad
T\in\mathcal{M}\\
T ::= C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}.
\end{letIn}
We call

* $C_i \ T_{i,1} \dots T_{i,k_1}$ a _sort_ of $T$,
* $C_i \ t_0 \dots t_{k_i}$ a _value_ of $T$,
* $C_i$ a _terminal_ of $T$,
* the function
    $$
      \begin{aligned}
      C_i&: T_{i,1} \to\dots \to T_{i,k_1} \to T\\
      C_i&(t_1,\dots,t_n) := C_i \ t_1 \dots \ t_n
      \end{aligned}
    $$
    a _constructor_ of $T$.

&nbsp;
```

```{definition,name="Bounded, Free, Set of free variables"}
\begin{letIn}
n\in\mathbb{N};\quad
a\in\mathcal{V};\quad
k\in\mathbb{N}_1^n\to\mathbb{N}_0;\quad
\forall i\in\mathbb{N}_1^n\forall j\in\mathbb{N}_1^n.T_{i,k(j)}\in\mathcal{T};\\
A::= C_1 \ T_{1,1} \dots \ T_{1,k(1)}  \dots C_n \ T_{n,1} \dots \ T_{n,k(n)}\in\mathcal{A};\quad
T\in \mathcal{T};\\
P=\forall a.T\in\mathcal{Q}.
\end{letIn}
$a\in\mathcal{V}$ is called _bounded_. Unbounded type variables are called _free_. 

The set of all free type variables of a type is defined as follows:

$$
  \begin{aligned}
    \text{free}(a) :=& {a}\\
    \text{free}(A) :=& \bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}\text{free}(T_{i,j}:\mathcal{V})\\
    \text{free}(P) :=& \text{free}(T)\backslash\{a\}
  \end{aligned}
$$
```

A type can be substituted by replacing a bounded type variable with a mono type:

```{definition,name="Type substitution"}
\begin{letIn}
n\in\mathbb{N};\quad
\Theta\subseteq\mathcal{V}\times\mathcal{T};\quad
a\in\mathcal{V};\quad
k\in\mathbb{N}_1^n\to\mathbb{N}_0;\quad
\forall i\in\mathbb{N}_1^n\forall j\in\mathbb{N}_1^n.T_{i,k(j)}\in\mathcal{T};\\
A::= C_1 \ T_{1,1} \dots \ T_{1,k(1)}  \dots C_n \ T_{n,1} \dots \ T_{n,k(n)}\in\mathcal{A};\quad
T\in \mathcal{T};\quad
P=\forall b.T\in\mathcal{Q};\\
S\in\mathcal{T}.
\end{letIn}
We define the substitute of a type $[.]_\Theta:\mathcal{T}\to\mathcal{T}$ as
$$
  \begin{aligned}[]
    [a]_\Theta :=& \begin{cases} S & \text{if } (a,S) \in \Theta\\ a &\text{else} \end{cases}\\
    [A]_\Theta:=&C_1 \ [T_{1,1}]_\Theta \dots [T_{1,k_1}]_\Theta \\
    &| \dots \\
    &| \ C_n \ [T_{n,1}]_\Theta \dots [T_{n,k_n}]_\Theta\\
    [P]_\Theta :=& \begin{cases} [T]_\Theta & \text{if } \exists (b,\_)\in \Theta\\
    \forall b. [T]_\Theta & \text{else.}\end{cases}
  \end{aligned}
$$
$\Theta$ is called the set of substitutions.
```

The type substitution gives raise to a partial order $\sqsubseteq$:

```{block2, type="axiom" ,latex.options="[Type Order]_"}
\begin{letIn}
T_1\in\mathcal{T};\quad
T_2\in\mathcal{T};\quad
\forall i\in\mathbb{N}_0^n.a_i\in\mathcal{V};\quad
\forall i\in\mathbb{N}_0^n.S_i\in\mathcal{T};\quad
\Theta = \bigcup\{(a_i,S_i)\}
\quad
\end{letIn}
We define the partial order $\sqsubseteq$ such that
$$
\dfrac
{T_2=[T_1]_\Theta\quad
\forall i\in\mathbb{N}_0^m.b_i\not\in \text{free}(\forall a_1 \dots \forall a_n.T)\quad
m \leq n
}
{\forall a_1 \dots \forall a_n.T_1 \sqsubseteq \forall b_1 \dots \forall b_m.T_2}
$$
```

The rule can be read as follows:

* First replace all bounded variables with types.
* Next rebound any new variables (variables that were previously not free).

```{block2, type="axiom" ,latex.options="[Product Type]_"}
\begin{letIn}
n \in \mathbb{N};\quad
\forall i\in\mathbb{N}_1^n.T_i:\mathbb{T}, l_i \text{ be a unique symbol}.
\end{letIn}

We call $T = \{l_1:T_1,..,l_n:T_n\}$ a _product type_. We say that $T\in\mathcal{A}$.

* We call $\forall i\in\mathbb{N}_1^n.l_i$ the _labels_ of the product type.
* The values of a product type have the form $\{l_1=t_1,\dots,l_n=t_n\}$ where $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
* The types $T_i$ are unordered: $\{a:T_1,b:T_2\} = \{b:T_2,a:T_1\}$.

For ordered product types we write

$T_1 \times \dots \times T_n := \{1:T_1,\dots,n:T_n\}.$

Values of a ordered product type have the form $(t_1,\dots,t_n)$, where $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
```

We most general example of a product type is a record. Tuples can be represented as ordered product types.

```{block2, type="axiom" ,latex.options="[Functions]_"}
\begin{letIn}
T_1\in\mathcal{T};\quad
T_2\in\mathcal{T}.
\end{letIn}
Functions from one type $T_1$ to another $T_2$ are mono types. We use the notation $T_1 \rightarrow T_2$ to describe function types.
```

```{block2, type="myexample",latex.options="_"}
\begin{letIn}
T_1\in\mathcal{T};\quad
T_2\in\mathcal{T};\quad
T_3\in\mathcal{T}.
\end{letIn}
Then $(T_1 \times T_2 \rightarrow T_3)$ is isomorphic to $T_1 \rightarrow (T_2 \rightarrow T_3)$. This was originally proven by Gottlob Frege [@Sch√∂nfinkel]. This method for translating multivariable functions into single variable functions is nowadays called _currying_ and named after Haskell Curry who further developed the theory [@curry]. 
```