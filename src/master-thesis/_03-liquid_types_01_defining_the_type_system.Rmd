\setcounter{section}{2}

# Liquid Types

## Definiting the Type System

First, we define some notations:

* $\mathbb{N}$ are the natural numbers starting from $1$.
* $\mathbb{N}_0$ are the natural numbers starting from $0$.
* $\mathbb{N}_a^b:=\{i\in \mathbb{N}_0 | a \leq i \land i \leq b\}$.
* We'll use "$.$" to seperate a quantifer from a statement: $\forall a . b$ and $\exists a . b$.
* Functions will be written as $a_1 \to .. \to a_n \to b$ instead of $a_1 \times .. \times a_n \to b$.

For this thesis we will use a Hindley-Milner type system.

```{block2, type="axiom" ,latex.options="[Types]_"}
\begin{letIn}
n\in\mathbb{N};\quad \forall i\in\mathbb{N}_a^b.k_i\in\mathbb{N}_0;\quad \forall i\in\mathbb{N}_a^b.C_i\text{ be a unique symbol}
\end{letIn}

$T$ is a _type_ if either

* (_Type variable_) $T$ is a symbol.

* (_Type application_) $T$ has the form
    $T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n}$
    
    where $\forall i\in\mathbb{N}_1^n \forall j\in\mathbb{N}_0^{k_i}. T_{i,j}$ is a type application or type variable.

* (_Quantified type_) $T$ has the form $T = \forall a_1 .. \forall a_n.T'$

    where $T'$ is a type application or a type variable and $\forall i\in\mathbb{N}_1^n.a_i$ is a type variable.
    
    For applied quanitifed types, the quantifer moves to the upper most level.

We write $v:T$ to declare that $v$ has the type $T$.
```

```{block2, type="myexample",latex.options="_"}
\begin{letIn}T ::= C a \text{ be a type application or a type variable.}\end{letIn}
We will later see that $a$ may be substituted by the quantified type $\forall a.a$.
This would lead to $T::= C (\forall a.a)$, but as quantifiers always move to the upper most level, it results in $\forall a.T::= C a$ instead.
```

```{block2, type="myexample",latex.options="_"}
The symbol `string` is a valid type. It can be though of as a type, whos implementation is unknown. For real programming languages this is not allowed.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:bool_list}
$\mathit{Bool} ::= \mathit{True} \ | \ \mathit{False}$ is a valid type application.

$\forall a.\mathit{List} \ a ::= \mathit{Empty} \ | \ \mathit{Cons} \ a \ (\mathit{List} \ a)$ is a valid quantified type.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:int}
The natural numbers and the integers can be defined as types using the piano axioms&nbsp;[@peano]:

* 1 is a natural number
* Every natural number has a successor.

These axioms can be used for the definiton of the type application.

$$\mathit{Nat} ::= 1 \ | \ \mathit{Succ} \ Nat$$

For integers we can use the property that they contain 0 as well as all positive and negative numbers.
  
$$\mathit{Int} ::= 0 \ | \ \mathit{Pos} \ \mathit{Nat} \ | \ \mathit{Neg} \ \mathit{Nat}$$
```

Types are usually grouped into so called Mono-types and Poly-types.

```{definition,name="Meta-level types"}
We define

  * $\mathcal{V}$ as the (meta-level) type of all type variables.
  * $\mathcal{A}$ as the (meta-level) type of all type applications.
  * _Mono types_ $\mathcal{M}::= \mathcal{V} \ | \mathcal{A}$.
  * _Poly types_ $\mathcal{P}$ as the (meta-level) type of all quantified types.
  * _Type of types_ $\mathcal{T}::= \mathcal{V} \ | \mathcal{A} \ | \ \mathcal{P}$.

&nbsp;
```

Instead of writing "let $a$ be a type application or a type variable" we can now just write $a:\mathcal{M}$.

```{definition,name="Sort, Value, Constructor"}
\begin{letIn}
n\in\mathbb{N};\quad
\forall j\in\mathbb{N}_1^n k_j\in\mathbb{N};\quad
{i\in\mathbb{N}_1^n};\quad
\forall j:\mathbb{N}_0^{k_i}.t_j: T_{i,j};\\
T:\mathcal{A}.\quad
T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n}
\end{letIn}
We call

* $C_i \ T_{i,1} \ .. \ T_{i,k_1}$ a _sort_ of $T$,
* $C_i \ t_0 \ .. \ t_{k_i}$ a _value_ of $T$,
* $C_i$ a _terminal_ of $T$,
* the function
    $$
      \begin{aligned}
      C_i&: T_{i,1} \to .. \to T_{i,k_1} \to T\\
      C_i&(t_1,..,t_n) := C_i \ t_1 \ .. \ t_n
      \end{aligned}
    $$
    a _constructor_ of $T$.

&nbsp;
```

```{definition,name="Bounded, Free, Set of free variables"}
\begin{letIn}
T:\mathcal{P};\quad
T=\forall a.T'.
\end{letIn}
$a:\mathcal{V}$ is called _bounded_. Unbounded type variables are called _free_. 

The set of all free type variables of a type is denoted as $\text{free}$:

$$
  \begin{aligned}
    \text{free}(a:\mathcal{V}) :=& {a}\\
    \text{free}(T:\mathcal{A}) :=& \text{let } T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n} \text{ in }\\
    &\bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}\text{free}(T_{i,j}:\mathcal{V})\\
    \text{free}(T:\mathcal{P}) :=& \text{let } T=\forall a_1 .. \forall a_n.T' \text{ in }\\
    &\text{free}(T':\mathcal{M})\backslash\{a_1,..,a_n\}
  \end{aligned}
$$
```

A type can be substituted by replacing a bounded type variable with a mono type:

```{definition,name="Type substitution"}
$$
  \begin{aligned}[]
    [a:\mathcal{V}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}} :=& \begin{cases} S & \text{if } a = a_i\\ a &\text{else} \end{cases}\\
    [T:\mathcal{A}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}}:=& \text{let } C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n} \text{ in }\\
    &C_1 \ [T_{1,1}]_{a_i \mapsto S} \ ..\ [T_{1,k_1}]_{a_i \mapsto S} \\
    &| \ .. \\
    &| \ C_n \ [T_{n,1}]_{a_i \mapsto S} \ .. \ [T_{n,k_n}]_{a_i \mapsto S}\\
    [T:\mathcal{P}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}} :=& \text{let } T = \forall a_1 .. \forall a_n.T' \text{ in }\\
    & \forall a_1 .. \forall a_{i-1} \forall a_{i+1} .. \forall a_n[T']_{a_i \mapsto S}
  \end{aligned}
$$
```

The type substitution gives raise to a partical order $\sqsubseteq$:

```{block2, type="axiom" ,latex.options="[Type Order]_"}
$$
\dfrac
{T'=[T]_{\forall i\in\mathbb{N}_0^n.a_i \mapsto T_i:\mathcal{M}} 
\quad \forall i\in\mathbb{N}_0^m.b_i\not\in \text{free}(\forall a_1 .. \forall a_n.T)
\quad m \leq n
}
{\forall a_1 .. \forall a_n.T \sqsubseteq \forall b_1 .. \forall b_m.T'}
$$
```

The rule can be read as follows:

* First replace all bounded variables with mono types.
* Next rebound any new variables (variables that where previously not free).

```{block2, type="axiom" ,latex.options="[Product Type]_"}
\begin{letIn}
n \in \mathbb{N};\quad
\forall i\in\mathbb{N}_1^n.T_i:\mathbb{T}, l_i \text{ be a unique symbol}.
\end{letIn}

We call $T = \{l_1:T_1,..,l_n:T_n\}$ a _product type_. We say that $T:\mathcal{A}$.

* We call $\forall i\in\mathbb{N}_1^n.l_i$ the _labels_ of the product type.
* The values of a product type have the form $\{l_1=t_1,..,l_n=t_n\}$ where $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
* The types $T_i$ are unordered: $\{a:T_1,b:T_2\} = \{b:T_2,a:T_1\}$.

For ordered product types we write

$T_1 \times .. \times T_n := \{1:T_1,..,n:T_n\}.$

Values of a ordered product type have the form $(t_1,..,t_n)$ $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
```

We most general example of a product type is a record. Tuples can be be represented as ordered product types.

```{block2, type="axiom" ,latex.options="[Functions]_"}

Functions from one type $T_1:\mathcal{T}$ to another $T_2:\mathcal{T}$ are mono types. We use the notation $T_1 \rightarrow T_2$ to decribe function types.
```

```{block2, type="myexample",latex.options="_"}
\begin{letIn}
T_1:\mathcal{T},T_2:\mathcal{T},T_3:\mathcal{T}
\end{letIn}
Then $(T_1 \times T_2 \rightarrow T_3)$ is isomorphic to $T_1 \rightarrow (T_2 \rightarrow T_3$. This was originally proven by Gottlob Frege.[@Sch√∂nfinkel] This method for translating multivariable functions into single variable functions is nowadays called currying and named after Haskell Curry who further developed the theory.[@curry] 
```

```{definition,name="partial function"}

We define $f \subseteq T_1\times T_2$ as a partial function from $T_1$ to $T_2$.
```

When ever we write $f \subseteq T_1\times T_2$, we assume that f is univariant: $(x,y_1)\in f \land (x,y_2)\in f \Rightarrow y_1 = y_2$.