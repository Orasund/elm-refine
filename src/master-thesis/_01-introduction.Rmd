# Introduction

On 21. September 1997 the onboard computer of the USS Yorktown aircraft carrier threw an uncaught division by zero exception. This resulted in the board computer shutting down and the ship becoming unable to control until an engineer could restart the computer. Fortunately this happened during a training maneuver [@humblePi].

Typically, such errors can only be found by extensive testing. Instead one might try to use a more expressive type system that can ensure at compile time that division by zero and similar bugs are impossible to occur.

These more expressive types are called *Refinement Types* [@refinement_types_for_ML]. Some authors also call them *Dependent Types*&nbsp;[@little_typer], though dependent types are typically more general: They are used to prove specific properties by letting the type definition depend on a quantified predicate, whereas a refinement type takes an existing type and excludes certain values that do not ensure a specific property. To avoid confusion, we will use the term "refinement types" for types that depend on a predicate written in propositional logic. We will call such a predicate the *refinement* of the refinement type.

Refinement types were first introduced by Tim Freeman and Frank Pfenning in 1991 [@refinement_types_for_ML]. In 2008 Patrick M. Rondon, Ming Kawaguchi and Ranjit Jhala from the university of California came up with the notion of Logically Quantified Data Types, or *Liquid Types* for short. Liquid Types limit themself to refinements on Integers and Booleans written in propositional logic together with order relations and addition.

Most work on Liquid Types was done in the UCSD Programming System research group, from which the original paper originated. The group has presented different implementations of Liquid types:

* **DSolve** for OCaml/ML&nbsp;[@DSolve]. This type checker originated from the original paper. In the original paper liquid types could only be ensured for a calculus called $\lambda_L$. It first translates OCaml to $\lambda_L$ and then checks for type safety.
* **CSolve** for C&nbsp;[@CSolve]. As a follow-up to DSolve, this checker implements Low-Level Liquid Type (LTLL) [@LTLL] for a formal language called *NanoC* that extends $\lambda_L$ with pointer arithmetics.
* **LiquidHaskell** for Haskell [@RT_for_Haskell]. Extending $\lambda_L$, this type checker uses a new calculus called $\lambda_P$, a polymorphic $\lambda$-calculus [@abstract_refinement_types]. Newer versions can also reason about termination, totalness (of functions) and basic theorems.
* **RefScript** for TypeScript [@Refined_TypeScript]. In a two phase process, the dynamic typed language gets translated into a static typed abstract language [@trust_but_verify]. This language can then be type checked using $\lambda_P$.

Outside of that research group, refinement types have also been implemented for Racket&nbsp;[@Racket], Ruby&nbsp;[@Ruby] and F#&nbsp;[@F_sharp].

## Goals of the thesis

The goal of this thesis is to define Liquid Types for the pure functional language called _Elm_&nbsp;[@elm]. This includes a formal semantics of Elm, the extended type system, a proof that the type-system is sound with respect to the semantics, and the type inference together with a subset of the language on which the inference can be applied. To validate the results the rewriting framework _K Framework_&nbsp;[@K_framework] will be used and the finished result will be implemented as a proper type checker for Elm.

Elm was invented in 2012 by Evan Czaplicki as his master thesis&nbsp;[@elm]. It uses functional reactive programming to handle side effects, essentially modelling side effects as an infinite sequence. It is aimed at web development and for that, it invented _The Elm Architecture_ (TEA). This architecture later got adopted by the JavaScript Framework _React_ as the Library _Redux_.

Compared to the well-known functional programming language Haskell, Elm is simpler and has a lot of unique interpretations of Haskell concepts. Mainly the lacking of type classes and monads. The biggest difference to Haskell is that it does not allow runtime exceptions. That said, in theory Elm still has three types of runtime errors: out of memory, function equivalence and non-terminating functions. These errors can be completely avoided if the Elm guidelines are followed, thus its claim of having "no runtime errors".

From a non-technical stand point, Elm focuses heavily on learning. It designs its features to always be beginner friendly. This represents a unique position, as a proper implementation of Liquid Types in Elm would evidently need to be usable for academia and beginners alike.

Currently, the most advanced implementation of liquid types is Liquid Haskell[@RT_for_Haskell]. It allows any Haskell code even though its type inference is only sound for a subset. If one does write unsound code, there is no indication for it from the type checker. The resulting behaviour is very situation based: They are sometimes very cryptic ("Float is not numeric, because Float is not numeric" when comparing a Float with a constant) or even wrong. For example, the code fragment

```
{-@ ax1 :: {x:Int | x*x <= 4} -> {x:Int | x*x <= x+x} @-}
ax1 :: Int -> Int
ax1 x = x
```

returns the error

```
Error: Liquid Type Mismatch
Inferred type
{v:Int | v * v <= 4 && v == x}

not a subtype of Required type
{VV:Int | VV * VV <= VV + VV}

In Context
x:{v:Int | v * v <= 4}
```

Without knowledge of liquid types, this message is hard to understand; It also indicates the wrong type of error. The types do match, its just that the type checker has trouble figuring that out. So instead an error message like "_could not prove_" or "_polynomial expressions are not allowed_" would be better.

Additionally, the syntax of Liquid Haskell is not suitable for Elm. A small example written in Liquid Haskell would be the following:

```
{- Positive Integers -}
{-@ type Nat = {x:Int | x > 0} @-}

{- Increases the value by one -}
{-@ increase :: in:Nat -> {out:Nat | out == in + 1} -@}
increase = (+) 1
```

There are two problems with that design.

* Elm uses so called Extendible Records, for example `{s|num:Int}`. For someone who's not familiar with Liquid Haskell or programming in general, Extendible Records and Liquid Types look very similar.
* Elm uses an auto formatter that automatically inserts an empty line after a comment. Additionally, Documentation comments (written `{-| something -}`) have no following empty line, but instead but be followed by the type signature.

An alternative Syntax that would work for Elm is the following:
```
{-| Positive Integers

@refinedBy `\x -> x > 0`
-}
type alias Nat =
    Int

{-| Increases the value by one

@refinedBy `\in out -> out == in + 1`
-}
increase : Nat -> Nat
increase = (+) 1
```

Here the last line of the documentation contains the type definition. The keyword `@refinedBy` would fit right in with other documentation keywords. `\.->.` is the syntax for a lambda function.

## Expected results

The result will consist of three parts: A language with a formal syntax and semantics, a type checker and a case study.

### The language

First a mathematically specified subset of Elm will be extended to include liquid types. In detail this includes:

1. A formal syntax written as Backus-Naur form (BNF).
2. A subset of the language that is equivalent to $\lambda_L$. This includes `Int`, `Bool`, `Tuple` and Lambda functions using constants `c`, variables, expressions (`+, * c, -`), relations (`<=, <, ==, /=`), predicates (`not, &&, ||`) and truth values (`True, False`).
3. A formal type system using Hindley Milner type inference. The liquid types will only be inferred for parts of the program that are written in said subset. 
4. A high level denotational semantic.
5. A proof, using the denotational semantics, that the type system rules out runtime errors.
6. A low level small step semantic suitable to be used with K Framework. The implementation in K Framework will be using for development and rapid prototyping of the language as well as the type system.

### The type checker

The second step will be to implement the type checker as part of a real Elm implementation. It will be done in Elm using the GitHub project _stil4m/elm-analyse_ as a foundation. Elm-analyse is a refactoring tool that enforces coding rules and good practices. It exposes the Abstract Syntax Tree (AST) using _stil4m/elm-syntax_ and has a finished interface that can display error messages together with automatic scripts that can fix the bugs.

The type checker will also work for `Char` and include the relations `>, >=`.

The final result will be published on the GitHub repository _Orasund/elm-refine_.

### The case study

For the third step, parts of the core elm package will be adopted to various refinement types and checked using the type checker. The goal of the case study is to improve the type checker with useful error messages and present a set of refinement types that can be used by the elm community without knowing anything about refinement types. For the error messages, the type checker will link to documentation, also located in the GitHub repository. This style of error messages matches the way Elm uses its error messages:

Elm allows for debugger-guided learning, where the debugger will reveal new features when necessary and references the specific pages of the documentation.

Here is an example error message:

```
This `case` does not have branches for all possibilities:

22|>    case list of
23|>        a :: _ ->
24|>            a

Missing possibilities include:

    []

I would have to crash if I saw one of those. Add branches for them!

Hint: If you want to write the code for each branch later, use `Debug.todo` as a
placeholder. Read <https://elm-lang.org/0.19.0/missing-patterns> for more
guidance on this workflow.
```