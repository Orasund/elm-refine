\setcounter{section}{4}
\setcounter{subsection}{1}

## Liquid Types for Elm

We will now extend the type system of Elm with liquid types.

### Syntax

We will take over the syntax described in the last section.

```{definition,name="Extendes Type Signiture Syntax"}
Given two variable domains `<upper-var>` and `<lower-var>`, we define the following syntax:

$$
  \begin{aligned}
    \mf{<int-exp-type>} =& \mathit{Int}\\
      | \ & \mf{<int-exp-type> + <int-exp-type>}\\
      | \ & \mf{<int-exp-type> * }\mathit{Int}\\
      | \ & \mathcal{V}
  \end{aligned}
$$
$$
  \begin{aligned}
    \mf{<qualifier-type>} =& \mf{True}\\
      | \ & \mf{False}\\
      | \ & \mf{<int-exp-type> <= v}\\
      | \ & \mf{v < <int-exp-type>}\\
      | \ & \mf{<qualifier-type> \&\& <qualifier-type>}\\
      | \ & \mf{<qualifier-type> || <qualifier-type>}\\
      | \ & \mf{not <qualifier-type>}
  \end{aligned}
$$
$$
\begin{aligned}
\mf{<liquid-type>} ::=&\mf{"\{v:Int|"}\mf{<qualifier-type>}\mf{"\}"} \\
                     |& \mf{<lower-var> ":" <liquid-type> "->" <liquid-type>}
\end{aligned}
$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{<liquid-type>}\\
              |& \mf{"Bool"}\\
              |& \mf{"Int"}\\
              |& \mf{"List" <type>}\\
              |& \mf{"(" <type> "," <type> ")"}\\
              |& \mf{"\{" <list-type-fields> "\}"}\\
              |& \mf{<type> "->" <type>}\\
              |& \mf{<upper-var> <list-type>}\\
              |& \mf{<lower-var>}
\end{aligned}
$$
```

### Type Inferece

We start by defining a template. This template will later be rewritten into a valid liquid type.

```{definition,name="Template, Liquid type Variable"}
\begin{letIn}
$T\in\mathcal{T}$.
\end{letIn}
We call $\{v:T|\kappa_j\}$ a _template_ of $T$ for $v\in\mathcal{V}$ and $j\in\mathbb{N}$. Note that the symbol $\kappa$ is called a _Liquid Type Variable_ within that context.
```

The type inference for liquid types goes in three phases:

1. Let the base types be derived and replaced by template liquid types
2. Generate constraints by using predicate abstraction
Refine the templates to make them as sharp as possible. (Find the strongest constraints for each liquid type variable)
3. Change templates into liquid types using a divide and conqure approach.

#### Type Signature Judgments

For type singature judgments, let $\mathit{exp}\in\mathit{IntExp}$ and $q\in\mathcal{Q}$.

For $\mathit{iet}\in\mf{"<int-exp-type>"}$, the judgment has the form

$$
\mathit{iet}:\mathit{exp}
$$

which can be read as "$\mathit{iet}$ correspondings $\mathit{exp}$".

For $\mathit{qt}\in\mf{"<qualifier-type>"}$, the judgment has the form

$$
\mathit{qt}:q
$$

which can be read as "$\mathit{qt}$ correspondings to $q$"

For $\mathit{lt}\in\mf{"<liquid-type>"}$, the judgment has the form

$$
\mathit{lt}:\hat{T}
$$

which can be read as "$\mathit{lt}$ correspondings to the liquid type $\hat{T}$".

As previously already stated, for $t\in\mf{<type>}$ the judgment has the form

$$
\Gamma\vdash t:T
$$

which can be read as "given $\Gamma$, $t$ has the type $T$".

### Auxiliary Definitions

We have already defined well-formed logical qualifers expressions. We will now extend the notion to well-formed liquid types.

```{definition,name="Well-formed liquid type"}
\begin{letIn}
$\Gamma$ be a type context.
\end{letIn}
\[\begin{aligned}
\text{wellFormed}\subset&\{t\in\mathcal{T}| t \text{ is a liquid type}\}\times(\mathcal{V}\nrightarrow\mathbb{N})\\
\text{wellFormed}(\{\nu:\mathit{Int}| r \},\Theta) :\Leftrightarrow& r\text{ is well defined with respect to } \Gamma\\
\text{wellFormed}(a:\hat{T}_1\to\hat{T}_2,\Theta) :\Leftrightarrow& \forall t\in\text{value}(\hat{T}_1).\text{wellFormed}(\hat{T}_2,\Theta\cup\{a,t\})
\end{aligned}\]
```

### Inference Rules for Type Signatures

#### int-exp-type

Judgment: $\mathit{iet}:\mathit{exp}$

\logicRule
{i:\mathit{Int}}
{i:i}
{}

\logicRule
{\mathit{iet}_1 = \mathit{exp}_1\quad
\mathit{iet}_2 = \mathit{exp}_2\quad
\mathit{exp}_1 + \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{+} \ \mathit{iet}_2 = \mathit{exp}_3}
{}

\logicRule
{i:\mathit{Int}\quad
\mathit{iet} = \mathit{exp}_0\quad
\mathit{exp}_0 * i = \mathit{exp}_1
}
{\mathit{iet} \ \mf{*} \ \mathit{i} = \mathit{exp}_1}
{}

\logicRule
{a = \mathit{exp}
}
{\mathit{a}:\mathit{exp}}
{}

#### qualifier-type

Judgment: $\mathit{qt}:q$

\logicRule
{
}
{\mf{True}:\mathit{True}}
{}

\logicRule
{
}
{\mf{False}:\mathit{False}}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\mathit{exp}_0 \leq \nu = \mathit{exp}_1
}
{\mathit{iet} \ \mf{<= v}:\mathit{exp}_1}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\nu < \mathit{exp}_0 = \mathit{exp}_1
}
{\mf{v <} \ \mathit{iet}:\mathit{exp}_1}
{}

\logicRule
{\mathit{iet}_1:\mathit{exp}_1\quad
\mathit{iet}_2:\mathit{exp}_2\quad
\mathit{exp}_1 \land \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{\&\&} \ \mathit{iet}_2:\mathit{exp}_3}
{}


\logicRule
{\mathit{iet}_1:\mathit{exp}_1\quad
\mathit{iet}_2:\mathit{exp}_2\quad
\mathit{exp}_1 \lor \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{||} \ \mathit{iet}_2:\mathit{exp}_3}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_1\quad
\neg\mathit{exp}_1 = \mathit{exp}_2
}
{\mf{not} \ \mathit{iet}:\mathit{exp}_2}
{}

#### liquid-type

Judgment: $\mathit{lt}:T$

\logicRule
{\mathit{iet}:\mathit{exp}\quad
\{v:Int|\mathit{exp}\}=\mathit{T}
}
{\mf{"\{v:Int|"}\ \mathit{iet} \ \mf{"\}"}:\mathit{T}}
{}

\logicRule
{\mathit{iet}_1:\mathit{T}_1\quad
\mathit{iet}_2:\mathit{T}_2\quad
(a:\mathit{T}_1\rightarrow\mathit{T}_2) = \mathit{T}_3
}
{a \ \mf{":"} \ \mathit{iet}_1 \ \mf{"->"} \ \mathit{iet}_2:\mathit{T}_3}
{}

#### type

Judgment: $\Gamma\vdash t:T$

\logicRule
{\mathit{lt}:T
}
{\Gamma\vdash \mathit{lt}:T}
{}

All other inference rules for types have allready been described.

### Inference Rules for Expressions

#### Exp

\logicRule
{
\Gamma,\Delta\vdash e_1:\textit{Bool}\quad
\Gamma,\Delta\vdash e_2: \hat{T}\quad
\Gamma,\Delta\vdash e_3: \hat{T}\quad
\hat{T} \ \text{is well-formed with respect to } \Delta
}
{\Gamma,\Delta\vdash\mf{"if"} \ e_1  \ \mf{"then"} \ e_2 \ \mf{"else"} \ e_3:\hat{T}}
{}