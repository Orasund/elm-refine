\setcounter{section}{4}
\setcounter{subsection}{1}

## Liquid Types for Elm

We will now extend the type system of Elm with liquid types.

### Syntax

We will use the syntax described in the last section.

```{definition,name="Extended Type Signature Syntax"}
Given two variable domains `<upper-var>` and `<lower-var>`, we define the following syntax:

$$
  \begin{aligned}
    \mf{<int-exp-type>} ::=& \mathit{Int}\\
      | \ & \mf{<int-exp-type> + <int-exp-type>}\\
      | \ & \mf{<int-exp-type> * }\mathit{Int}\\
      | \ & \mathcal{V}
  \end{aligned}
$$
$$
  \begin{aligned}
    \mf{<qualifier-type>} ::=& \mf{True}\\
      | \ & \mf{False}\\
      | \ & \mf{(<) <int-exp-type> v}\\
      | \ & \mf{(<) v <int-exp-type>}\\
      | \ & \mf{(==) <int-exp-type> v}\\
      | \ & \mf{(\&\&) <qualifier-type> <qualifier-type>}\\
      | \ & \mf{(||) <qualifier-type> <qualifier-type>}\\
      | \ & \mf{not <qualifier-type>}
  \end{aligned}
$$
$$
\begin{aligned}
\mf{<liquid-type>} ::=& \mf{"\{v:Int|"} \ \mf{<qualifier-type>} \ \mf{"\}"} \\
                  | \ & \mf{<lower-var> ":" <liquid-type> "->" <liquid-type>}
\end{aligned}
$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{<liquid-type>}\\
           | \ & \mf{"Bool"}\\
           | \ & \mf{"List" <type>}\\
           | \ & \mf{"(" <type> "," <type> ")"}\\
           | \ & \mf{"\{" <list-type-fields> "\}"}\\
           | \ & \mf{<type> "->" <type>}\\
           | \ & \mf{<upper-var> <list-type>}\\
           | \ & \mf{<lower-var>}
\end{aligned}
$$
```


### Type Inference

We will also extend the inference rules. The interesting part is the new judgment for \mf{<exp>}: We introduce two new sets: $\Theta$ and $\Lambda$.
As before, $\Theta$ will contain the type of a variable (similarly to the previous section where  in $\Theta$ we stored the value of a variable). The set $\Lambda$ contains boolean expressions that get collected while traversing if-then-else branches. We will use these expressions to allow path sensitive subtyping.

#### Type Signature Judgments

For type signature judgments, let $\mathit{exp}\in\mathit{IntExp}$, $q\in\mathcal{Q}$. Let $\Gamma,\Delta$ be type contexts. Let $\Lambda\subset\mathcal{Q}$ and $\Theta:\mathcal{V}\nrightarrow\mathcal{T}$.

For $\mathit{iet}\in\mf{"<int-exp-type>"}$, the judgment has the form

$$
\mathit{iet}:\mathit{exp}
$$

which can be read as "$\mathit{iet}$ corresponds to $\mathit{exp}$".

For $\mathit{qt}\in\mf{"<qualifier-type>"}$, the judgment has the form

$$
\mathit{qt}:q
$$

which can be read as "$\mathit{qt}$ corresponds to $q$"

For $\mathit{lt}\in\mf{"<liquid-type>"}$, the judgment has the form

$$
\mathit{lt}:\hat{T}
$$

which can be read as "$\mathit{lt}$ corresponds to the liquid type $\hat{T}$".

As previously already stated, for $t\in\mf{<type>}$ the judgment has the form

$$
\Gamma\vdash t:T
$$

which can be read as "given $\Gamma$, $t$ has the type $T$".

For $e\in\mf{<exp>}$ the judgment has the form

$$
\Gamma,\Delta,\Theta,\Lambda\vdash e:T
$$

which can be read as "given $\Gamma$, $\Delta$, $\Theta$ and $\Lambda$, $e$ has the type $T$".

### Auxiliary Definitions

#### Substitution

```{definition,name="Refinement Substitution"}
\begin{letIn}
$a$ be a variable, $e\in\mathit{IntExp}$
\end{letIn}
For a given liquid type we define the Refinement substitution as follows:

$$
\begin{aligned}
[\{b:\mathit{Int}| r \}]_{a\leftarrow e} :=& \{b:\mathit{Int}| [r]_{a\leftarrow e} \}\\
[b:\hat{T}_1\to\hat{T}_2]_{a\leftarrow e} :=& b:[\hat{T}_1]_{a\leftarrow e}\to[\hat{T}_2]_{a\leftarrow e}
\end{aligned}
$$
```

Note that $[r]_{a\leftarrow e}$ is substitution on expressions for $r\in\mathcal{Q}$. This requires that $[r]_{a\leftarrow e}$ must again life in $\mathcal{Q}$. We can enforce this requirement by the inference rules for \mf{<qualifier-type>}.

#### Well-formed Liquid Type

We have already defined well-formed logical qualifiers expressions. We will now extend the notion to well-formed liquid types.

```{definition,name="Well-formed Liquid Type"}
\begin{letIn}
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$.
\end{letIn}
We define following.
\[
\text{wellFormed}\subseteq\{t\in\mathcal{T}| t \text{ is a liquid type}\}\times(\mathcal{V}\nrightarrow\mathbb{N})
\]\[
\begin{aligned}
\text{wellFormed}(\{b:\mathit{Int}| r \},\{(a_1,T_1),\dots,(a_n,T_n)\}) :\Leftrightarrow\\
\forall k_1\in\text{value}_\Gamma(T_1).\dots \forall k_n\in\text{value}_\Gamma(T_n).\\
r\text{ is well defined with respect to }& \{(a_1,k_1),\dots,(a_n,k_n)\}
\end{aligned}
\]\[
\text{wellFormed}(a:\hat{T}_1\to\hat{T}_2,\Theta) :\Leftrightarrow \text{wellFormed}(\hat{T}_1,\Theta)\ \land\ \text{wellFormed}(\hat{T}_2,\Theta\cup\{(a,\hat{T}_1)\})
\]
```

#### Subtyping

```{definition,name="Subtyping"}
\begin{letIn}
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$. Let $\Lambda\subset\mathcal{Q}$, $r_1,r_2\in\mathcal{Q}$
\end{letIn}
We define the following.
$$
\begin{aligned}
\{a_1:\mathit{Int}| r_1 \} <:_{\Theta,\Lambda} \{ a_2 : \mathit{Int}| r_2\} \ :\Leftrightarrow \ & \text{Let} \ \{(b_1,T_1),\dots,(b_n,T_n)\}=\Theta \ \text{in}\\
&\forall k_1\in\text{value}_\Gamma(T_1).\dots \forall k_n\in\text{value}_\Gamma(T_n).\\
&\forall n\in\mathbb{N}.\forall e \in\Lambda.\\
                                                                                  &\quad \semantic{$e$}_{\{(a_1,n),(b_1,k_1),\dots,(b_n,k_n)\}}\\
   &\quad\land \semantic{$r_1$}_{\{(a_1,n),(b_1,k_1),\dots,(b_n,k_n)\}}\\
                                                                                  &\Rightarrow\semantic{$r_2$}_{\{(a_2,n),(b_1,k_1),\dots,(b_n,k_n)\}}\\
a_1:\hat{T}_1\to\hat{T}_2 <:_{\Theta,\Lambda} a_2:\hat{T}_3\to\hat{T}_4 \ :\Leftrightarrow \ 
&\hat{T}_3<:_{\Theta,\Lambda}\hat{T}_1 \land \hat{T}_2<:_{\Theta\cup\{(a_1,\hat{T}_3)\},\Lambda}\hat{T}_4
\end{aligned}
$$
For two liquid types $\hat{T}_1,\hat{T}_2$, we say $\hat{T}_1$ is a subtype of $\hat{T}_2$ with respect to $\Theta$ and $\Lambda$ if and only if $\hat{T}_1<:_{\Theta,\Lambda}\hat{T}_2$ is valid. 
```

Subtyping comes with an additional inference rule for $\mf{<exp>}$. The sharpness of the inferred subtype depends on the capabilities of the SMT-Solver. Using this optional inference rule, the SMT-Solver will need to find the sharpest subtype, or at least sharp enough: In the case of type checking, it might be that the subtype is too sharp and therefore the SMT-Solver can't check the type successfully.

\logicRule
{\Gamma,\Delta,\Theta,\Lambda\vdash e:\hat{T}_1\quad
\hat{T}_1<:_{\Theta,\Lambda}\hat{T}_2\quad
\text{wellFormed}(\hat{T}_2,\Theta)
}
{\Gamma,\Delta,\Theta,\Lambda\vdash e:\hat{T}_2}
{}

Note that we include $\Lambda$ in our definition. This way we require that the SMT-Solver will allow path sensitive subtyping.

### Inference Rules for Type Signatures

#### int-exp-type

Judgment: $\mathit{iet}:\mathit{exp}$

\logicRule
{i:\mathit{Int}}
{i:i}
{}

\logicRule
{\mathit{iet}_1 : \mathit{exp}_1\quad
\mathit{iet}_2 : \mathit{exp}_2\quad
\mathit{exp}_1 + \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{+} \ \mathit{iet}_2 : \mathit{exp}_3}
{}

\logicRule
{i:\mathit{Int}\quad
\mathit{iet} : \mathit{exp}_0\quad
\mathit{exp}_0 * i = \mathit{exp}_1
}
{\mathit{iet} \ \mf{*} \ \mathit{i} : \mathit{exp}_1}
{}

\logicRule
{a = \mathit{exp}
}
{\mathit{a}:\mathit{exp}}
{}

#### qualifier-type

Judgment: $\mathit{qt}:q$

\logicRule
{
}
{\mf{True}:\mathit{True}}
{}

\logicRule
{
}
{\mf{False}:\mathit{False}}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\mathit{exp}_0 < \nu = \mathit{exp}_1
}
{\mf{(<)} \ \mathit{iet} \ \mf{v}:\mathit{exp}_1}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\nu < \mathit{exp}_0 = \mathit{exp}_1
}
{\mf{(<) v} \ \mathit{iet}:\mathit{exp}_1}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
(\nu = \mathit{exp}_0) = \mathit{exp}_1
}
{\mf{(=) v} \ \mathit{iet}:\mathit{exp}_1}
{}

\logicRule
{\mathit{iet}_1:\mathit{exp}_1\quad
\mathit{iet}_2:\mathit{exp}_2\quad
\mathit{exp}_1 \land \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{\&\&} \ \mathit{iet}_2:\mathit{exp}_3}
{}


\logicRule
{\mathit{iet}_1:\mathit{exp}_1\quad
\mathit{iet}_2:\mathit{exp}_2\quad
\mathit{exp}_1 \lor \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{||} \ \mathit{iet}_2:\mathit{exp}_3}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_1\quad
\neg\mathit{exp}_1 = \mathit{exp}_2
}
{\mf{not} \ \mathit{iet}:\mathit{exp}_2}
{}

#### liquid-type

Judgment: $\mathit{lt}:T$

\logicRule
{\mathit{qt}:q\quad
\{v:Int| \ q \ \}=\mathit{T}
}
{\mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"}:\mathit{T}}
{}

\logicRule
{\mathit{lt}_1:\mathit{T}_1\quad
\mathit{lt}_2:\mathit{T}_2\quad
(a:\mathit{T}_1\rightarrow\mathit{T}_2) = \mathit{T}_3
}
{a \ \mf{":"} \ \mathit{lt}_1 \ \mf{"->"} \ \mathit{lt}_2:\mathit{T}_3}
{}

#### type

Judgment: $\Gamma\vdash t:T$

\logicRule
{\mathit{lt}:T
}
{\Gamma\vdash \mathit{lt}:T}
{}

All other inference rules for types have already been described.

### Inference Rules for Expressions

#### Exp

\logicRule
{}
{\Gamma,\Delta\vdash\mf{"(//)"}:\mathit{Int}\to\{v:\mathit{Int}| \neg (v = 0)\}\to\mathit{Int}}
{}

\logicRule
{
\begin{gathered}
\Gamma,\Delta,\Theta,\Lambda\vdash e_1:\textit{Bool}\quad
\text{wellFormed}(\hat{T},\Theta)\quad
e_1:e_1'\\
\Gamma,\Delta,\Theta,\Lambda\cup\{e_1'\}\vdash e_2: \hat{T}\quad
\Gamma,\Delta,\Theta,\Lambda\cup\{\neg e_1'\}\vdash e_3: \hat{T}
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"if"} \ e_1  \ \mf{"then"} \ e_2 \ \mf{"else"} \ e_3:\hat{T}}
{}

Note that we assume that $e_1\in\mf{<qualifier-type>}$. If this is not the case, then the judgment can not be derived.

\logicRule
{\begin{gathered}
(a,\_)\not\in\Delta\quad
\Gamma,\Delta,\Theta,\Lambda\vdash e_1:\hat{T}\quad
mes:\hat{T}\vdash a:\hat{T}\\
\Gamma,\Delta\cup\{(a,\overline{\Gamma}(\hat{T}))\},\Theta\cup\{(a,\overline{\Gamma}(\hat{T}))\}\vdash e_2:\hat{T}\quad
\text{wellFormed}(\hat{T},\Theta)
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"let"} \ \mathit{mes} \ a \mf{"="} \ e_1 \ \mf{"in"} \ e_2: \hat{T}
}
{}

\logicRule
{\Gamma,\Delta,\Theta,\Lambda\vdash e_1: (a:T\to \hat{T}_1)\quad
\Gamma,\Delta,\Theta,\Lambda\vdash e_2: T\quad
e_2:e_2'\quad
[\hat{T}_1]_{a\leftarrow e_2'} =\hat{T}_2
}
{\Gamma,\Delta,\Theta,\Lambda\vdash e_1 \ e_2: \hat{T}_2}
{}

Note that we assume that $e_2\in\mf{<qualifier-type>}$. If this is not the case, then the judgment can not be derived.

\logicRule
{\begin{gathered}
\text{wellFormed}(b:\hat{T}_1\to \hat{T}_2,\Theta)\quad
b:\hat{T}_1\to \hat{T}_2 = \hat{T}_3\\
\Gamma,\Delta\cup\{(b,\overline{\Gamma}(\hat{T}_1))\},\Theta\cup\{(b,\overline{\Gamma}(\hat{T}_1))\},\Lambda\vdash e: \hat{T}_2
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"\textbackslash"} \ a \ \mf{"->"} \ e: \hat{T}_3}
{}

\logicRule
{a\sqsubseteq_\Delta \{\nu:\hat{T}| \ r\}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash a: \{\nu:\hat{T}| \ \nu = a\}}
{}

All other inference rules for expressions have not changed.