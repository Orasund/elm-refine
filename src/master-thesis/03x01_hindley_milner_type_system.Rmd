## Hindley-Milner Type System

For this thesis we will use a Hindley-Milner type system [@Principal_Type-Schemes_for_Functional_Programs].
The main idea of the Hindley-Milner type system is to have a type system that implies an order among the types. The ordering will then allow us to infer the type of any expression.

### Notion of Types

We will first introduce types, afterwards we will define how types relate to sets by defining the values of types as explicit finite sets. Types are split in _mono types_ and _poly types_. Mono types can contain so called _type variables_ that can then be bound with a quantifier as a poly type. Note that quantifiers can only occur in the outermost position, thus poly types are more general types than mono types.

```{definition,name="Mono types, poly types, types"}
We say
$$
\begin{aligned}
  T \text{ is a }\mathit{mono} \ \mathit{type}:\Leftrightarrow
       \ & T \text{ is a type variable}\\
  \lor \ & T \text{ is a type application}\\
  \lor \ & T \text{ is a algebraic type}\\
  \lor \ & T \text{ is a product type}\\
  \lor \ & T \text{ is a function type}\\
  T \text{ is a }\mathit{poly} \ \mathit{type} :\Leftrightarrow
       \ & T = \forall a.T'\\
         & \text{ where } T' \text{ is a mono type or poly type and } a \text{ is a symbol}\\
  T \text{ is a }\mathit{type} :\Leftrightarrow 
       \ & T \text{ is a mono type} \ \lor \ T \text{ is a poly type}.
\end{aligned}
$$  
by using the following predicates.
$$
\begin{aligned}
T \text{ is a } \mathit{type} \ \mathit{variable}:\Leftrightarrow \
         & T \text{ is a symbol.}\\
T \text{ is a } \mathit{type} \ \mathit{application}:\Leftrightarrow \
         & \text{Let }n\in\mathbb{N}, C \text{ be a symbol}. \text{ Let } T_i \text{ be mono types for all }\\
         & i\in\mathbb{N}_1^n \text{ in}\\
         & C \ T_1 \dots T_n\\
T \text{ is a } \mathit{algebraic} \ \mathit{type}:\Leftrightarrow \
         & \text{Let } n\in\mathbb{N},k\in\mathbb{N}_1^n\to\mathbb{N}_0, C \text{ be a symbol}. \text{ Let } T_{i,k(j)} \text{ be a}\\
         & \text{mono type or } C \text{ for all } i\in\mathbb{N}_1^n \text{ and } j\in\mathbb{N}_1^{k(i)} \text{ in}\\ 
         & \mu C. C_1 \ T_{1,1} \dots T_{1,k(1)} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k(n)}\\
         & \text{such that }\exists i\in\mathbb{N}.\forall j\in\mathbb{N}_1^{k(i)}.T_{i,j}\neq C.\\
T \text{ is a } \mathit{product} \ \mathit{type}:\Leftrightarrow \
         & \text{Let }n\in\mathbb{N}_0.\text{ Let } l_i \text{ symbols and } T_i \text{ be a mono types for}\\
         & \text{all } i\in\mathbb{N}_1^n \text{ in}\\
         & T = \{l_1:T_1,\dots,l_n:T_n\}\\
T \text{ is a } \mathit{function} \ \mathit{type}:\Leftrightarrow \
         & T_1 \text{ and } T_2 \text{ be mono types in}\\
         & T = T_1 \to T_2.
\end{aligned}
$$
```

```{block2, type="axiom",latex.options="_"}
The types $T_i$ for $i\in\mathbb{N}$ in a product type are unordered: 

$$\{a:T_1,b:T_2,\dots\} = \{b:T_2,a:T_1,\dots\}$$

for any symbols $a,b$ and mono types $T_1,T_2$.
```

```{block2, type="myexample",latex.options="_"}
The symbol `Char` is a type variable. $\mf{Sequence} \ \mf{Char}$ is a type application. They can be thought of as types, whose implementation is unknown. The interpretation of a type variable or a type application depends on its context.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:bool_list}
$\mathit{Bool} = \mu \_.\mathit{True} \ | \ \mathit{False}$ is an algebraic type.
```

```{block2, type="myexample",latex.options="_"}
$List = \forall a.\mu C. \mathit{Empty} \ | \ \mathit{Cons} \ a \ C$ is a poly type.
```

```{block2, type="myexample",latex.options="_"}
the empty product type $\{\}$ is a mono type.
```

```{definition,name="Sort, Terminal"}
\begin{letIn}
$n\in\mathbb{N}$,
$k_j\in\mathbb{N}$,
$T_{i,j}$ be a mono type,
$C,C_i$ be symbols,
$t_j: T_{i,j}$ for all $j\in\mathbb{N}_1^n$,
$i\in\mathbb{N}_1^n.$ and
$T = \mu C.C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}$ be a algebraic type.
\end{letIn}

We call

* $C_i \ T_{i,1} \dots T_{i,k_1}$ a _sort_ of $T$,
* $C_i$ a _terminal_ of $T$.

&nbsp;
```

```{block2, type="myexample",latex.options="_"}
\label{ex:int}
The natural numbers and the integers can be defined as algebraic types using the peano axioms&nbsp;[@peano]:

* $1$ is a natural number.
* Every natural number has a successor.

These axioms can be used for the definition of the type application.

$$\mathit{Nat} ::= \mu C.1 \ | \ \mathit{Succ} \ C$$

For integers, we can use the property that they contain $0$ as well as all positive and negative numbers.
  
$$\mathit{Int} ::= \mu C.0 \ | \ \mathit{Pos} \ C \ | \ \mathit{Neg} \ C$$

In this case numbers like $1, \mathit{Succ} \ 1$ for $\mathit{Nat}$ or $\mathit{Neg} \ \mathit{Succ} \ 1$ for $\mathit{Int}$ are sorts, where as $1$ and $\mathit{Succ}$ for $\mathit{Nat}$ and $\mathit{Neg},\mathit{Pos}$ and $0$ for $\mathit{Int}$ are terminals.
```

```{definition,name="Label"}
\begin{letIn}
$n \in \mathbb{N}$.
Let $T_i$ be a type,
$l_i$ be a unique symbol for all $i\in\mathbb{N}_1^n$.
\end{letIn}

We say $l_i$ are the _labels_ of the product type $\{l_1:T_1,..,l_n:T_n\}$ for all $i\in\mathbb{N}_1^n$.

We define 

$$T_1 \times \dots \times T_n := \{1:T_1,\dots,n:T_n\}$$

as the _ordered product type_ with $n$ components.
```

The most general example of a product type is a record. Tuples can be represented as ordered product types.

```{definition,name="Bound, Free, Set of free variables"}
\begin{letIn}
$n\in\mathbb{N}_0$,
$a$ be a type variable,
$T$ be a type,
$C$ be a symbol,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$,
$T_i$ be a type,
$T_{i,k(j)}$ be a type or a symbol and $C_i$ be a symbol for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}

We say

* $a$ is _free_ in $T :\Leftrightarrow a \in \mathit{free}(T)$
* $a$ is _bound_ in $T :\Leftrightarrow a \not\in \mathit{free}$ and $a$ occurs in $T$.

where

$$
  \begin{aligned}
    \mathrm{free}(a) :=& \{a\}\\
    \mathrm{free}(C. T_1 \dots T_n) :=& \bigcup_{i\in\mathbb{N}_1^n}\mathrm{free}(T_i)\\
   \mathrm{free}\begin{pmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} :=& \bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}\mathrm{free}(T_{i,j})\\
    \mathrm{free}(\{\_:T_1,\dots,\_:T_n\}) :=&\bigcup_{i\in\mathbb{N}_1^n}\mathrm{free}(T_i)\\
    \mathrm{free}(T_1 \to T_2) :=& \mathrm{free}(T_1)\cup\mathrm{free}(T_2)\\
    \mathrm{free}(\forall a.T) :=& \mathrm{free}(T)\backslash\{a\}
  \end{aligned}
$$
```

```{definition,name="Partial function"}
\begin{letIn}
$T_1$ and $T_2$ be types.
$f \subseteq T_1 \times T_2$ 
\end{letIn}
We say $f$ is a _partial function_ (Notation: $f : T_1 \nrightarrow T_2$) $:\Leftrightarrow$
$$\forall x\in T_1,y\in T_2.(x,y_1)\in f \land (x,y_2)\in f \Rightarrow y_1 = y_2.$$
```

```{definition,name="Sets of Types"}
We define

* $\mathcal{V} := \{a| a \text{ is a symbol} \}$ as the set of all type variables(symbols).
* $\mathcal{T} := \{T| T \text{ is a type}\}$ as the set of all types.

&nbsp;
```

A type can be substituted by replacing a bounded type variable with a mono type:

```{definition,name="Type substitution"}
\begin{letIn}
$n\in\mathbb{N}$,
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$,
$a\in\mathcal{V}$.
Let $T,T_1,T_2,S\in\mathcal{T}$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}
We define the substitute of a type $[.]_\Theta:\mathcal{T}\to\mathcal{T}$ as
$$
  \begin{aligned}[]
    [a]_\Theta :=& \begin{cases} S & \text{if } (a,S) \in \Theta\\ a &\text{else} \end{cases}\\
    \begin{bmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{bmatrix*}_\Theta:=&
    \begin{matrix*}[l]
    \mu C.\\
    C_1 \ [T_{1,1}]_\Theta \dots [T_{1,k_1}]_\Theta \\
    | \dots \\
    | \ C_n \ [T_{n,1}]_\Theta \dots [T_{n,k_n}]_\Theta
    \end{matrix*}\\
    [\{l_1:T_1,\dots,l_n:T_n\}]_\Theta:=&\{l_1:[T_1]_\Theta,\dots,l_n:[T_n]_\Theta\}\\
    [T_1\to T_2]_\Theta :=& [T_1]_\Theta\to [T_2]_\Theta\\
    [\forall b.T]_\Theta :=& \begin{cases} [T]_\Theta & \text{if } \exists (b,\_)\in \Theta\\
    \forall b. [T]_\Theta & \text{else.}\end{cases}
  \end{aligned}
$$
$\Theta$ is called the set of substitutions.
```

The type substitution gives raise to a partial order $\sqsubseteq$:

```{definition,name="Type Order"}
\begin{letIn}
$n,m\in\mathbb{N}$,
$T_1,T_2\in\mathcal{T}$,
$a_i$
for all $i\in\mathbb{N}_0^n$ and $b_i\in\mathcal{V}$ for all $i\in\mathbb{N}_0^m$
.
\end{letIn}
We define the partial order $\sqsubseteq$ as
$$
\begin{aligned}
\forall a_1 \dots \forall a_n.T_1 \sqsubseteq \forall b_1 \dots \forall b_m.T_2:\Leftrightarrow 
  & \exists \Theta = \{(a_i,S_i)|i\in\mathbb{N}_1^n\land a_i\in\mathcal{V}\land
S_i\in\mathcal{T}\}.\\
  & T_2=[T_1]_\Theta \land \forall i\in\mathbb{N}_0^m.b_i\not\in\mathrm{free}(\forall a_1 \dots \forall a_n.T)
\end{aligned}
$$
```

The rule can be read as follows:

* First replace all bounded variables with types.
* Next rebound any new variables (variables that were previously not free).

```{block2, type="myexample",latex.options="_"}
$\forall a.a$ is the smallest type in the type system.
The partial order forms a tree structure with $\forall a.a$ at the root and different branches for $\forall a.\forall b. (a,b)$, $\forall a. C \ a$, $\forall a.\forall b. a \to b$ and so on. The leaves of the tree are all possible mono types.
```

### Interpretation of types

Before we interprete a type, we will first introduce a set of labeled elements as a record.

```{definition,name="Record"}
\begin{letIn}
$n$ in $\mathbb{N}$, $l_i$ be a symbol, $t_i$ arbitary for all $i$ in $\mathbb{N}_1^n$.
\end{letIn}
We define
$$
\begin{aligned}
\{l_1=t_1,\dots,l_n=t_n\}:&\{l_1,\dots,l_n\}\to\{t_1,\dots,t_n\}\\
\{l_1=t_1,\dots,l_n=t_n\}(l):=&\ t\text{ such that } \exists i \in \mathbb{N}_1^n. l = l_i \land t = t_i
\end{aligned}
$$

Note that values of a ordered product type are equivant to tuples:

$$\forall i\in \mathbb{N}_1^n.\{1=t_1,\dots,n=t_n\}(i) = (t_1,\dots,t_n).i$$

Thus we will use the notation of tuples for values of a ordered product type.
```

```{definition,name="Application Constructor"}
\begin{letIn}
$n\in\mathbb{N}_0$.
Let $a_i$ be a symbol for all $i\in\mathbb{N}_1^n$. 
\end{letIn}
We call
$$
\begin{aligned}
f :& \underbrace{\mathcal{T} \to \dots \to \mathcal{T}}_{n \text{ times}} \to \mathcal{T}\\
f(T_1,\dots,T_n) :=& [ \forall a_1 \dots a_n. T]_{\{(a_1,T_1),\dots,(a_n,T_n)\}} \text{ for a mono type } T.
\end{aligned}
$$
an _application constructor_.

We define $\mathcal{C}=\{f| f \text{ is a application constructor}\}$ as the set of all application constructors. 
```

```{definition,name="Context"}
$\Gamma : \mathcal{V}\nrightarrow\mathcal{C}$ is a _context_ $:\Leftrightarrow$
$$
\begin{aligned}
  &\Gamma = \{\}\\
  \lor& \ \Gamma = \Delta \cup \{(a,T)\} \text{ where } T \text{ is a mono type, } \Delta \text{ is a context and } a \text{ is a type variable}\\
  \lor& \ \Gamma = \Delta \cup \{(C,f)\} \text{ where } T = C \ T_1 \dots T_n \text{ is a type application and } T_i \text{ is a}\\
      & \text{mono type for } i\in\mathbb{N}_1^n\text{ and }f\text{ is a application constructor such that } f(T_1,\dots,T_n)\\
      &\text{ is a mono type}.
\end{aligned}
$$

```

```{definition,name="Values"}
\begin{letIn}
$\mathcal{S}$ the class of all finite sets,
$n\in\mathbb{N}$,
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$,
$a\in\mathcal{V}$,
$T,T_1,T_2,S\in\mathcal{T}$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
Let $\Gamma$ be a context.
\end{letIn}

We define
$$
\begin{aligned}
\mathrm{values}_\Gamma :& \mathcal{V} \to \mathcal{S}\\
\mathrm{values}_\Gamma(a) :=& \mathrm{values}_\Gamma(\Gamma(a))\\
\mathrm{values}_\Gamma(C \ T_1 \ \dots \ T_n) :=& \mathrm{values}_\Gamma(\Gamma(C)(T_1,\dots,T_n))\\
\mathrm{values}_\Gamma\small\begin{pmatrix*}[l]
    \mu C.\\
    | C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} :=&\bigcup_{i\in\mathbb{N}_0} \mathrm{rvalues}_\Gamma
  \begin{pmatrix*}[l]
  i,&
  \small\begin{matrix*}[l]
    \mu C.\\
    | \ C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
  \end{matrix*}
  \end{pmatrix*}\\
\mathrm{values}_\Gamma(\{l_1:T_1,\dots,l_n:T_n\}) :=\\
  \big\{\{l_1=t_1,&\dots,l_n=t_n\} \ | \ \forall i\in\mathbb{N}_1^n.t_i \in\mathrm{values}_\Gamma(T_i)\big\}\\
\mathrm{values}_\Gamma(T_1 \to T_2) :=&\{f \ | \ f:\mathrm{values}_\Gamma(T_1)\to\mathrm{values}_\Gamma(T_2)\}\\
\mathrm{values}_\Gamma(\forall a.T) :=& \lambda b.\mathrm{values}_{\{(a,b)\}\cup\Gamma}(T) \text{ where the symbol } b \text{ does}\\
  &\text{ not occur in } T.
\end{aligned}
$$
using the following helper function.
  
Let $l\in\mathbb{N},T := \mu C.\ | \ C_1 \ T_{1,1} \dots \ T_{1,k(1)}\ | \dots \ | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}$ in
$$
\begin{aligned}
\mathrm{rvalues}_\Gamma(0,T):=&
  \begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. T_{i,j} \neq C \land v_j \in \mathrm{values}_\Gamma(T_{i,j})
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
\mathrm{rvalues}_\Gamma({l+1},T):=&
  \small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(l,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}
\end{aligned} 
$$
```
The base case of this recursive function is in $\mathrm{rvalues}(0,T)$ for a given T.

```{theorem,name="rvalue is nested"}
\begin{letIn}
$n\in\mathbb{N}_0$. Let $T := \mu C.\ | \ C_1 \ T_{1,1} \dots \ T_{1,k(1)}\ | \dots \ | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}$.
\end{letIn}
$$\bigcup_{i\in\mathbb{N}_0^n} \mathrm{rvalues}_\Gamma(i,T)=\mathrm{rvalues}_\Gamma(n,T)
$$
```
```{proof}
Its sufficient to prove by induction over $n$ that $$\forall n\in\mathbb{N}_0.\mathrm{rvalues}_\Gamma(n,T)\subseteq\mathrm{rvalues}_\Gamma(n+1,T).$$
\textbf{Base case}: We'll show $\mathrm{rvalues}_\Gamma(0,T)\subseteq\mathrm{rvalues}_\Gamma(1,T)$.
$$
\begin{aligned}
&\mathrm{rvalues}_\Gamma(1,T)\\
&=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(0,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&\supseteq\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. T_{i,j} \neq C \land
        v_j \in
        \mathrm{values}_\Gamma(T_{i,j})
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&=\mathrm{rvalues}_\Gamma(0,T).
\end{aligned}
$$
\textbf{Inductive step}: Assuming $\mathrm{rvalues}_\Gamma(n,T)\subseteq\mathrm{rvalues}_\Gamma(n+1,T)$, we'll prove
$$\mathrm{rvalues}_\Gamma(n+1,T)\subseteq\mathrm{rvalues}_\Gamma(n+2,T).$$
$$
  \begin{aligned}
  &\mathrm{rvalues}_\Gamma(n+2,T)\\
  &=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(n+1,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
  &\supseteq\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(n,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
  &=\mathrm{rvalues}_\Gamma(n+1,T)
  \end{aligned}
$$
```

As an example we can now prove that the values of $Nat$ from example \label{ex:int} are isomorphic to the natural numbers.
```{theorem}
\begin{letIn}
$Nat:=\mu C.1| \mathit{Succ} \ C$
\end{letIn}
$$\mathrm{values}(\mathit{Nat})\cong\mathbb{N}$$
```
```{proof}
$$
\begin{aligned}
\textrm{values}(\mu C.1| Succ \ C)&=\bigcup_{i\in\mathbb{N}_0}\mathrm{rvalues}(i,\mu C.1| Succ \ C)\\
&=\lim_{n\to\infty}\bigcup_{i\in\mathbb{N}_0^n}\mathrm{rvalues}(i,\mu C.1| Succ \ C)\\
&=\lim_{n\to\infty}\mathrm{rvalues}(n,\mu C.1| \mathit{Succ} \ C).
\end{aligned}$$

We'll now show by induction over $n\in\mathbb{N}_0$ that
$$\textrm{rvalues}(n,\mu C.1| \mathit{Succ} \ C)
=\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n \text{ times}}\}.$$

\begin{addmargin}[1cm]{0cm}
\textbf{Base case}: $\mathrm{rvalues}(0,\mu C.1| Succ \ C) = \{1\}$\newline
\textbf{Inductive step}:\newline
Assuming $\textrm{rvalues}(n,\mu C.1| \mathit{Succ} \ C)
=\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n \text{ times}}\},$
we'll prove $\textrm{rvalues}(n+1,\mu C.1| \mathit{Succ} \ C)
=\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n+1 \text{ times}}\}.$
  
$$
\begin{aligned}
&\mathrm{rvalues}(n+1,\mu C.1| \mathit{Succ} \ C)\\
&=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(n,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n \text{ times}}\}&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&=\{1\}\cup\big\{\mathit{Succ} \ v,v\in\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n \text{ times}}\}\big\}\\
&=\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n+1 \text{ times}}\}
\end{aligned}
$$
\end{addmargin}
We define a order on $$\mathrm{values}(\mathit{Nat})=\lim_{n\to\infty}\{1,\underbrace{\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \dots \ \mathit{Succ} \ 1}_{n \text{ times}}\}=\{1,\mathit{Succ} \ 1,\dots,\mathit{Succ} \ \mathit{Succ} \ 1,\dots\}$$
by $v_1 < v_2 :\Leftrightarrow v_2 = \mathit{Succ} \dots \mathit{Succ} \ v_1$ for $v_1,v_2\in\mathrm{values}(\mathit{Nat})$.
This is a well-ordering, thus the set is isomorphic to $\mathbb{N}$.
```