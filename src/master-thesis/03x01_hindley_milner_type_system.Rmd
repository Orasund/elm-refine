## Hindley-Milner type system

For this thesis we will use a Hindley-Milner type system [@Principal_Type-Schemes_for_Functional_Programs].
The main idea of the Hindley-Milner type system is to have a type system that implies an order among the types. The ordering will then allow us to infer the type of any expression.

### Notion of Types

We will first introduce types, afterwards we will define how types relate to sets by defining the values of types as explicit finite sets. Types are split in _mono types_ and _poly types_. Mono types can contain so called _type variables_ that can then be bound with a quantifier as a poly type. Note that quantifiers can only occur in the outermost position, thus poly types are more general types than mono types.

```{definition,name="Mono types, poly types, types"}
We say
$$
\begin{aligned}
  T \text{ is a }\mathit{mono} \ \mathit{type}:\Leftrightarrow
       \ & T \text{ is a type variable}\\
  \lor \ & T \text{ is a type application}\\
  \lor \ & T \text{ is a algebraic type}\\
  \lor \ & T \text{ is a product type}\\
  \lor \ & T \text{ is a function type}\\
  T \text{ is a }\mathit{poly} \ \mathit{type} :\Leftrightarrow
       \ & T = \forall a.T'\\
         & \text{ where } T' \text{ is a mono type or poly type and } a \text{ is a symbol}\\
  T \text{ is a }\mathit{type} :\Leftrightarrow 
       \ & T \text{ is a mono type} \ \lor \ T \text{ is a poly type}.
\end{aligned}
$$  
by using the following predicates.
$$
\begin{aligned}
T \text{ is a } \mathit{type} \ \mathit{variable}:\Leftrightarrow \
         & T \text{ is a symbol.}\\
T \text{ is a } \mathit{type} \ \mathit{application}:\Leftrightarrow \
         & \text{Let }n\in\mathbb{N}, C \text{ be a symbol}. \text{ Let } T_i \text{be mono types for all }\\
         & i\in\mathbb{N}_1^n \text{ in}\\
         & C \ T_1 \dots T_n\\
T \text{ is a } \mathit{algebraic} \ \mathit{type}:\Leftrightarrow \
         & \text{Let } n\in\mathbb{N},k\in\mathbb{N}_1^n\to\mathbb{N}_0, C \text{ be a symbol}. \text{ Let } T_{i,k(j)} \text{ be a}\\
         & \text{mono type or } C \text{ for all } i\in\mathbb{N}_1^n \text{ and } j\in\mathbb{N}_1^{k(i)} \text{ in}\\ 
         & \mu C. C_1 \ T_{1,1} \dots T_{1,k(1)} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k(n)}\\
T \text{ is a } \mathit{product} \ \mathit{type}:\Leftrightarrow \
         & \text{Let }n\in\mathbb{N}_0.\text{ Let } l_i \text{ symbols and } T_i \text{ be a mono types for}\\
         & \text{all } i\in\mathbb{N}_1^n \text{ in}\\
         & T = \{l_1:T_1,\dots,l_n:T_n\}\\
T \text{ is a } \mathit{function} \ \mathit{type}:\Leftrightarrow \
         & T_1 \text{ and } T_2 \text{ be mono types in}\\
         & T = T_1 \to T_2.
\end{aligned}
$$
```

```{block2, type="axiom",latex.options="_"}
The types $T_i$ for $i\in\mathbb{N}$ in a product type are unordered: 

$$\{a:T_1,b:T_2,\dots\} = \{b:T_2,a:T_1,\dots\}$$

for any symbols $a,b$ and mono types $T_1,T_2$.
```

```{block2, type="myexample",latex.options="_"}
The symbol `Char` is a type variable. $Sequence Char$ is a type application. They can be thought of as types, whose implementation is unknown. The interpretation of a type variable or a type application depends on its context.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:bool_list}
$\mathit{Bool} = \mu _.\mathit{True} \ | \ \mathit{False}$ is an algebraic type.
```

```{block2, type="myexample",latex.options="_"}
$List = \forall a.\mu C. \mathit{Empty} \ | \ \mathit{Cons} \ a \ C$ is a poly type.
```

```{block2, type="myexample",latex.options="_"}
the empty product type $\{\}$ is a mono type.
```

```{definition,name="Sort, Terminal"}
\begin{letIn}
$n\in\mathbb{N}$,
$k_j\in\mathbb{N}$,
$T_{i,j}$ be a mono type,
$C,C_i$ be symbols,
$t_j: T_{i,j}$ for all $j\in\mathbb{N}_1^n$,
$i\in\mathbb{N}_1^n.$ and
$T = \mu C.C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}$ be a algebraic type.
\end{letIn}

We call

* $C_i \ T_{i,1} \dots T_{i,k_1}$ a _sort_ of $T$,
* $C_i$ a _terminal_ of $T$.

&nbsp;
```

```{block2, type="myexample",latex.options="_"}
\label{ex:int}
The natural numbers and the integers can be defined as algebraic types using the peano axioms&nbsp;[@peano]:

* $1$ is a natural number.
* Every natural number has a successor.

These axioms can be used for the definition of the type application.

$$\mathit{Nat} ::= \mu C.1 \ | \ \mathit{Succ} \ C$$

For integers, we can use the property that they contain $0$ as well as all positive and negative numbers.
  
$$\mathit{Int} ::= \mu C.0 \ | \ \mathit{Pos} \ C \ | \ \mathit{Neg} \ C$$

In this case numbers like $1, \mathit{Succ} \ 1$ for $\mathit{Nat}$ or $\mathit{Neg} \ \mathit{Succ} \ 1$ for $\mathit{Int}$ are sorts, where as $1$ and $\mathit{Succ}$ for $\mathit{Nat}$ and $\mathit{Neg},\mathit{Pos}$ and $0$ for $\mathit{Int}$ are terminals.
```

```{definition,name="Label"}
\begin{letIn}
$n \in \mathbb{N}$.
Let $T_i$ be a type,
$l_i$ be a unique symbol for all $i\in\mathbb{N}_1^n$.
\end{letIn}

We say $l_i$ are the _labels_ of the product type $\{l_1:T_1,..,l_n:T_n\}$ for all $i\in\mathbb{N}_1^n$.

We define 

$$T_1 \times \dots \times T_n := \{1:T_1,\dots,n:T_n\}$$

as the _ordered product type_ with $n$ components.
```

The most general example of a product type is a record. Tuples can be represented as ordered product types.

```{definition,name="Bound, Free, Set of free variables"}
\begin{letIn}
$n\in\mathbb{N}_0$,
$a$ be a type variable,
$T$ be a type,
$C$ be a symbol,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$,
$T_i$ be a type,
$T_{i,k(j)}$ be a type or a symbol and $C_i$ be a symbol for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}

We say

* $a$ is _free_ in $T :\Leftrightarrow a \in \mathit{free}(T)$
* $a$ is _bound_ in $T :\Leftrightarrow a \not\in \mathit{free}$ and $a$ occurs in $T$.

where

$$
  \begin{aligned}
    \text{free}(a) :=& \{a\}\\
    \text{free}(C. T_1 \dots T_n) :=& \bigcup_{i\in\mathbb{N}_1^n}\text{free}(T_i)\\
    \text{free}\begin{pmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} :=& \bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}\text{free}(T_{i,j})\\
    \text{free}(\{\_:T_1,\dots,\_:T_n\}) :=&\bigcup_{i\in\mathbb{N}_1^n}\text{free}(T_i)\\
    \text{free}(T_1 \to T_2) :=& \text{free}(T_1)\cup\text{free}(T_2)\\
    \text{free}(\forall a.T) :=& \text{free}(T)\backslash\{a\}
  \end{aligned}
$$
```

```{definition,name="Partial function"}
\begin{letIn}
$T_1$ and $T_2$ be types.
$f \subseteq T_1 \times T_2$ 
\end{letIn}
We say $f$ is a _partial function_ (Notation: $f : T_1 \nrightarrow T_2$) $:\Leftrightarrow$
$$\forall x\in T_1,y\in T_2.(x,y_1)\in f \land (x,y_2)\in f \Rightarrow y_1 = y_2.$$
```

```{definition,name="Sets of Types"}
We define

* $\mathcal{V} := \{a| a \text{ is a symobol} \}$ as the set of all type variables(symobls).
* $\mathcal{T} := \{T| T \text{ is a type}\}$ as the set of all types.

&nbsp;
```

A type can be substituted by replacing a bounded type variable with a mono type:

```{definition,name="Type substitution"}
\begin{letIn}
$n\in\mathbb{N}$,
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$,
$a\in\mathcal{V}$.
Let $T,T_1,T_2,S\in\mathcal{T}$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}
We define the substitute of a type $[.]_\Theta:\mathcal{T}\to\mathcal{T}$ as
$$
  \begin{aligned}[]
    [a]_\Theta :=& \begin{cases} S & \text{if } (a,S) \in \Theta\\ a &\text{else} \end{cases}\\
    \begin{bmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{bmatrix*}_\Theta:=&
    \begin{matrix*}[l]
    \mu C.\\
    C_1 \ [T_{1,1}]_\Theta \dots [T_{1,k_1}]_\Theta \\
    | \dots \\
    | \ C_n \ [T_{n,1}]_\Theta \dots [T_{n,k_n}]_\Theta
    \end{matrix*}\\
    [\{l_1:T_1,\dots,l_n:T_n\}]_\Theta:=&\{l_1:[T_1]_\Theta,\dots,l_n:[T_n]_\Theta\}\\
    [T_1\to T_2]_\Theta :=& [T_1]_\Theta\to [T_2]_\Theta\\
    [\forall b.T]_\Theta :=& \begin{cases} [T]_\Theta & \text{if } \exists (b,\_)\in \Theta\\
    \forall b. [T]_\Theta & \text{else.}\end{cases}
  \end{aligned}
$$
$\Theta$ is called the set of substitutions.
```

The type substitution gives raise to a partial order $\sqsubseteq$:

```{definition,name="Type Order"}
\begin{letIn}
$n,m\in\mathbb{N}$ with $m\leq n$,
$T_1,T_2\in\mathcal{T}$,
$a_i,b_i\in\mathcal{V}$,
$S_i\in\mathcal{T}$,
for all $i\in\mathbb{N}_0^n$ and 
.
\end{letIn}
We define the partial order $\sqsubseteq$ as
$$
\begin{aligned}
\forall a_1 \dots \forall a_n.T_1 \sqsubseteq \forall b_1 \dots \forall b_m.T_2:\Leftrightarrow 
  & \exists \Theta = \{(a_i,S_i)|i\in\mathcal{T}\}.\\
  & T_2=[T_1]_\Theta \land \forall i\in\mathbb{N}_0^m.b_i\not\in \text{free}(\forall a_1 \dots \forall a_n.T)
\end{aligned}
$$
```

```{block2, type="myexample",latex.options="_"}
$\forall a.a$ is the smallest type in the type system.
the partial order forms a tree strcture with $\forall a.a$ at the root and branches for $\forall a.\forall b. (a,b)$, $\forall a. C a$, $\forall a.\forall b. a \to b$ and so on. The leaves of the tree are all possible mono types.
```

The rule can be read as follows:

* First replace all bounded variables with types.
* Next rebound any new variables (variables that were previously not free).

### Interpretation of types

```{definition,name="Record"}
\begin{letIn}
$n$ in $\mathbb{N}$, $l_i$ be a symbol, $t_i$ arbitary for all $i$ in $\mathbb{N}_1^n$.
\end{letIn}
We define
$$
\begin{aligned}
\{l_1=t_1,\dots,l_n=t_n\}:&\{l_1,\dots,l_n\}\to\{t_1,\dots,t_n\}\\
\{l_1=t_1,\dots,l_n=t_n\}(l):=&t\text{ such that } \exists i \in \mathbb{N}_1^n. l = l_i \land t = t_i
\end{aligned}
$$

Note that values of a ordered product type are equivant to tuples:

$$\forall i\in \mathbb{N}_1^n.\{1=t_1,\dots,n=t_n\}(i) = (t_1,\dots,t_n).i$$

Thus we will use the notation of tuples for values of a ordered product type.
```

```{definition,name="Constructor"}
For any terminal $C_i$ we also define the function
$$
  \begin{aligned}
  \text{cons}_{C_i}&: T_{i,1} \to\dots \to T_{i,k_1} \to T\\
  \text{cons}_{C_i}&(t_1,\dots,t_n) := C_i \ t_1 \dots \ t_n
  \end{aligned}
$$
called a _constructor_ of $T$.
```

```{definition,name="Declaration"}
$$
D \text{ is a } \textit{declaraction} :\Leftrightarrow \mu c_1\dots c_n.  C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}
$$
We define $\mathcal{D} := \{D|D \text{ is a declaraction}\}$.

$$declare : \mathcal{D} \to \text{Construtor Eren}
$$
```

```{definition,name="Value"}
\begin{letIn}
$\mathcal{S}$ the class of all finite sets,
$n\in\mathbb{N}$,
$\Theta\subseteq\mathcal{V}\times\mathcal{T}$,
$a\in\mathcal{V}$,
$T,T_1,T_2,S\in\mathcal{T}$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}
We define
$$
\begin{aligned}
\text{value} &: \mathcal{V} \to \mathcal{S}\\
\text{value}(a) &:= \{a\}\\
\text{value}\small\begin{pmatrix*}[l]
C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} &:=\\
  \{C_i \ t_{i,1}& \dots \ t_{i,k(1)} \ | \ \forall i\in\mathbb{N}_1^n,j\in\mathbb{N}_1^{k(i)}. t_{i,j}\in\text{value}(T_{i,j})\}\\
\text{value}(\{l_1:T_1,\dots,l_n:T_n\}) &:=\big\{\{l_1=t_1,\dots,l_n=t_n\} \ | \ \forall i\in\mathbb{N}_1^n.t_i \in\text{value}(T_i)\big\}\\
\text{value}(T_1 \to T_2) &:=\{f \ | \ f:\text{value}(T_1)\to\text{value}(T_2)\}\\
\text{value}(\forall a.T) &:= \{\forall a. x | x \in \text{value}(T)\}
\end{aligned}
$$
```

For free type variables the corresponding set of values may change.