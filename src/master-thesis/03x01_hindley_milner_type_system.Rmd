## Hindley-Milner Type System

For functional languages considered in this thesis we will use a Hindley-Milner type system [@Principal_Type-Schemes_for_Functional_Programs].
The main idea is to have a type system that implies an order among the types. The ordering will then allow us to infer the type of any expression. In the following, we give a formal definition of this type system.

### Notion of Types

We will first introduce types, afterwards we will define how types relate to sets by explicitly defining the values of types as finite sets. Types are split in _mono types_ and _poly types_. Mono types can contain so called _type variables_ that can then be bound by a quantifier within a poly type. Note that quantifiers can only occur in the outermost position, thus poly types are more general types than mono types.

```{definition,name="Mono types, poly types, types"}
We define
$$
\begin{aligned}
  T \text{ is a }\mathit{mono} \ \mathit{type}:\Leftrightarrow
       \ & T \text{ is a type variable}\\
  \lor \ & T \text{ is a type application}\\
  \lor \ & T \text{ is a algebraic type}\\
  \lor \ & T \text{ is a product type}\\
  \lor \ & T \text{ is a function type}\\
  T \text{ is a }\mathit{poly} \ \mathit{type} :\Leftrightarrow
       \ & T = \forall a.T'\\
         & \text{where } T' \text{ is a mono type or poly type and } a \text{ is a symbol}\\
  T \text{ is a }\mathit{type} :\Leftrightarrow 
       \ & T \text{ is a mono type} \ \lor \ T \text{ is a poly type}.
\end{aligned}
$$  
by using the following predicates:
$$
\begin{aligned}
T \text{ is a } \mathit{type} \ \mathit{variable}:\Leftrightarrow \
         & T \text{ is a symbol.}\\
T \text{ is a } \mathit{type} \ \mathit{application}:\Leftrightarrow \
         & T \text{ is of form } C \ T_1 \dots T_n\\
         & \text{ where } n\in\mathbb{N}, C \text{ is a symbol and the } T_i \text{ are mono types}\\
         & \text{ for all } i\in\mathbb{N}_1^n.\\
T \text{ is a } \mathit{algebraic} \ \mathit{type}:\Leftrightarrow \
         & T \text{ is of form } \mu C. C_1 \ T_{1,1} \dots T_{1,k(1)} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k(n)}\\
         & \text{such that }\exists i\in\mathbb{N}.\forall j\in\mathbb{N}_1^{k(i)}.T_{i,j}\neq C\\
         & \text{where } n\in\mathbb{N},k\in\mathbb{N}_1^n\to\mathbb{N}_0, C \text{ is a symbol and } T_{i,k(j)}\\
         & \text{ is a mono type or } C \text{ for all } i\in\mathbb{N}_1^n \text{ and } j\in\mathbb{N}_1^{k(i)}.\\ 
T \text{ is a } \mathit{product} \ \mathit{type}:\Leftrightarrow \
         & T \text{ is of form } \{l_1:T_1,\dots,l_n:T_n\}\\
         & \text{where }n\in\mathbb{N}_0\text{ and } l_i \text{ are symbols and } T_i \text{ are mono types}\\
         & \text{ for all } i\in\mathbb{N}_1^n.\\
T \text{ is a } \mathit{function} \ \mathit{type}:\Leftrightarrow \
         & T \text{ is of form } T_1 \to T_2\\
         & \text{where } T_1 \text{ and } T_2 \text{ are mono types}.
\end{aligned}
$$
```

Note that the quantifier $\mu C$ is called a _recursive quantifier_. By using the symbol $C$ we can describe a recursive structure in a non recursive way. That said we need to ensure that every algebraic type has a non-recursive case (called a base case). That's why we require $\exists i\in\mathbb{N}.\forall j\in\mathbb{N}_1^{k(i)}.T_{i,j}\neq C$.

```{block2, type="axiom",latex.options="_"}
We consider the types $T_i$ for $i\in\mathbb{N}$ in a product type as unordered, i.e., 

$$\{a:T_1,b:T_2,\dots\} = \{b:T_2,a:T_1,\dots\}$$

for all symbols $a,b,\dots$ and mono types $T_1,T_2,\dots$.
```

```{block2, type="myexample",latex.options="_"}
The symbol `Char` is a type variable. The expression $\mf{Sequence} \ \mf{Char}$ is a type application. These expressions can be thought of as types whose implementation is unknown. The interpretation of a type variable or a type application depends on its context.
```

```{block2, type="myexample",latex.options="_"}
\label{ex:bool_list}
$\mathit{Bool} = \mu \_.\mathit{True} \ | \ \mathit{False}$ is an algebraic type.

Note that we use the symbol $\_$ to specify a symbol that i only used once in the definition. Multiple occurrences of $\_$ would be seen as multiple difference symbols. We call $\_$ a _wild card_.
```

```{block2, type="myexample",latex.options="_"}
$List = \forall a.\mu C. \mathit{Empty} \ | \ \mathit{Cons} \ a \ C$ is a poly type whose body $\mu C. \mathit{Empty} \ | \ \mathit{Cons} \ a \ C$ is an algebraic type.
```

```{block2, type="myexample",latex.options="_"}
The empty product type $\{\}$ is a mono type.
```

```{definition,name="Sort, Terminal"}
\begin{letIn}
$n\in\mathbb{N}$,
$k_j\in\mathbb{N}$,
$T_{i,j}$ be a mono type,
$C,C_i$ be symbols,
$t_j: T_{i,j}$ for all $j\in\mathbb{N}_1^n$,
$i\in\mathbb{N}_1^n$ and
$T = \mu C.C_1 \ T_{1,1} \dots T_{1,k_1} \ | \dots | \ C_n \ T_{n,1} \dots T_{n,k_n}$ be a algebraic type.
\end{letIn}

We call

* $C_i$ a _terminal_ of $T$ and
* $C_i \ T_{i,1} \dots T_{i,k_i}$ a _sort_ of $T$ for all instantiation of  all type-variables in $T_{i,j}$ by mono types that do not contain type variables.

&nbsp;
```

```{block2, type="myexample",latex.options="_"}
\label{ex:int}
The natural numbers and the integers can be defined as algebraic types using the peano axioms&nbsp;[@peano]:

* $1$ is a natural number.
* Every natural number has a successor.

These axioms can be used for the definition of the type application.

$$\mathit{Nat} ::= \mu C.1 \ | \ \mathit{Succ} \ C$$

For integers, we can use the property that they contain $0$ as well as all positive and negative numbers.
  
$$\mathit{Int} ::= \mu \_.0 \ | \ \mathit{Pos} \ \mathit{Nat} \ | \ \mathit{Neg} \ \mathit{Nat}$$

In this case numbers like $1, \mathit{Succ} \ 1$ for $\mathit{Nat}$ or $\mathit{Neg} \ (\mathit{Succ} \ 1)$ for $\mathit{Int}$ are sorts, whereas $1$ and $\mathit{Succ}$ for $\mathit{Nat}$ and $\mathit{Neg},\mathit{Pos}$ and $0$ for $\mathit{Int}$ are terminals.
```

```{definition,name="Label"}
\begin{letIn}
$n \in \mathbb{N}$.
Let $T_i$ be a type,
$l_i$ be a unique symbol for all $i\in\mathbb{N}_1^n$.
\end{letIn}

We say $l_i$ is a _label_ of the product type $\{l_1:T_1,..,l_n:T_n\}$ for all $i\in\mathbb{N}_1^n$.

We define 

$$T_1 \times \dots \times T_n := \{1:T_1,\dots,n:T_n\}$$

as the _ordered product type_ with $n$ components.
```

The most general example of a product type is a record. Tuples can be represented as ordered product types.

```{definition,name="Bound, Free, Set of free variables"}
\begin{letIn}
$n\in\mathbb{N}_0$,
$a$ be a type variable,
$T$ be a type,
$C$ be a symbol,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$,
$T_i$ be a type,
$T_{i,k(j)}$ be a type or a symbol and $C_i$ be a symbol for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}

We say

* $a$ is _free_ in $T :\Leftrightarrow a \in \mathit{free}(T)$
* $a$ is _bound_ in $T :\Leftrightarrow a \not\in \mathit{free}(T)$ and $a$ occurs in $T$.

where

$$
  \begin{aligned}
    \mathrm{free}(a) :=& \{a\}\\
    \mathrm{free}(C \ T_1 \dots T_n) :=& \bigcup_{i\in\mathbb{N}_1^n}\mathrm{free}(T_i)\\
   \mathrm{free}\begin{pmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} :=& \bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}
      \begin{cases}
        \varnothing& \text{ if } T_{i,j} = C\\
        \mathrm{free}(T_{i,j})& \text{ else}
      \end{cases}\\
    \mathrm{free}(\{\_:T_1,\dots,\_:T_n\}) :=&\bigcup_{i\in\mathbb{N}_1^n}\mathrm{free}(T_i)\\
    \mathrm{free}(T_1 \to T_2) :=& \mathrm{free}(T_1)\cup\mathrm{free}(T_2)\\
    \mathrm{free}(\forall a.T) :=& \mathrm{free}(T)\backslash\{a\}
  \end{aligned}
$$
```

```{definition,name="Partial function"}
\begin{letIn}
$T_1$ and $T_2$ be sets and
$f \subseteq T_1 \times T_2$. 
\end{letIn}
We say $f$ is a _partial function_ (Notation: $f : T_1 \nrightarrow T_2$) $:\Leftrightarrow$
$$\forall x\in T_1,y\in T_2.(x,y_1)\in f \land (x,y_2)\in f \Rightarrow y_1 = y_2.$$
```

```{definition,name="Sets of Types"}
We define

* $\mathcal{V} := \{a \ | \ a \text{ is a symbol} \}$ as the set of all type variables (symbols).
* $\mathcal{T} := \{T \ | \ T \text{ is a type}\}$ as the set of all types.

&nbsp;
```

A type can be substituted by replacing a bound type variable with a mono type:

```{definition,name="Type substitution"}
\begin{letIn}
$n\in\mathbb{N}$,
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$,
$a\in\mathcal{V}$.
Let $T,T_1,T_2$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
\end{letIn}
We define the substitute of a type $[.]_\Theta:\mathcal{T}\to\mathcal{T}$ as
$$
  \begin{aligned}[]
    [a]_\Theta :=& \begin{cases} S & \text{if } (a,S) \in \Theta\\ a &\text{else} \end{cases}\\
    \begin{bmatrix*}[l]
    \mu C.\\
    C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{bmatrix*}_\Theta:=&
    \begin{matrix*}[l]
    \mu C.\\
    C_1 \ [T_{1,1}]_{\Theta\setminus\{C,\_\}} \dots [T_{1,k_1}]_{\Theta\setminus\{C,\_\}} \\
    | \dots \\
    | \ C_n \ [T_{n,1}]_{\Theta\setminus\{C,\_\}} \dots [T_{n,k_n}]_{\Theta\setminus\{C,\_\}}
    \end{matrix*}\\
    [\{l_1:T_1,\dots,l_n:T_n\}]_\Theta:=&\{l_1:[T_1]_\Theta,\dots,l_n:[T_n]_\Theta\}\\
    [T_1\to T_2]_\Theta :=& [T_1]_\Theta\to [T_2]_\Theta\\
    [\forall b.T]_\Theta :=& \begin{cases} [T]_\Theta & \text{if } \exists (b,\_)\in \Theta\\
    \forall b. [T]_\Theta & \text{else.}\end{cases}
  \end{aligned}
$$
$\Theta$ is called the set of substitutions.
```

The type substitution gives raise to a partial order $\sqsubseteq$:

```{definition,name="Type Order"}
\begin{letIn}
$n,m\in\mathbb{N}$,
$T_1,T_2\in\mathcal{T}$,
$a_i$
for all $i\in\mathbb{N}_0^n$ and $b_i\in\mathcal{V}$ for all $i\in\mathbb{N}_0^m$
.
\end{letIn}
We define the partial order $\sqsubseteq$ on poly types as
$$
\begin{aligned}
\forall a_1 \dots \forall a_n.T_1 \sqsubseteq \forall b_1 \dots \forall b_m.T_2:\Leftrightarrow \
  & \exists \Theta = \{(a_i,S_i) \ | \ i\in\mathbb{N}_1^n\land a_i\in\mathcal{V}\land
S_i\in\mathcal{T}\}.\\
  & T_2=[T_1]_\Theta \land \forall i\in\mathbb{N}_0^m.b_i\not\in\mathrm{free}(\forall a_1 \dots \forall a_n.T_1)
\end{aligned}
$$
```

From a given type $T_1$ we can construct a more specialized type $T_2$ such that $T_1\sqsubseteq T_2$ by the following steps

1. First replace all bounded variables $a_i$ with types $S_i$.
2. Next rebound any new variables $b_i$ that were previously not free.

```{block2, type="myexample",latex.options="_"}
$\forall a.a$ is the smallest type in the type system.
The partial order forms a tree structure with $\forall a.a$ at the root and different branches for $\forall a. C \ a$, $\forall a.\forall b. a \to b$ and so on. The leaves of the tree are all possible mono types.
```

### Interpretation of Types

Before we interpret a type, we will first introduce a set of labelled elements as a record.

```{definition,name="Record"}
\begin{letIn}
$n$ in $\mathbb{N}$, $l_i$ be a symbol, $t_i$ arbitary for all $i$ in $\mathbb{N}_1^n$.
\end{letIn}
We define
$$
\begin{aligned}
\{l_1=t_1,\dots,l_n=t_n\}:&\{l_1,\dots,l_n\}\to\{t_1,\dots,t_n\}\\
\{l_1=t_1,\dots,l_n=t_n\}(l):=&\ t\text{ such that } \exists i \in \mathbb{N}_1^n. l = l_i \land t = t_i
\end{aligned}
$$

Note that values of an ordered product type are equivalent to tuples:

$$\forall i\in \mathbb{N}_1^n.\{1=t_1,\dots,n=t_n\}(i) = (t_1,\dots,t_n).i$$

Thus, we will use the notation of tuples for values of an ordered product type.
```

```{definition,name="Application Constructor"}
\begin{letIn}
$n\in\mathbb{N}_0$.
Let $T$ be a mono type. Let $\{a_1,\dots,a_n\}:=\text{free}(T)$.
\end{letIn}
We call the function
$$
\begin{aligned}
(\forall a_1 \dots a_n. T) :& \underbrace{\mathcal{T} \to \dots \to \mathcal{T}}_{n \text{ times}} \to \mathcal{T}\\
(\forall a_1 \dots a_n. T)(T_1,\dots,T_n) :=& [ \forall a_1 \dots a_n. T]_{\{(a_1,T_1),\dots,(a_n,T_n)\}}.
\end{aligned}
$$
the _application constructor_ of $T$.

We define $\mathcal{C}=\{f| f \text{ is an application constructor}\}$ as the set of all application constructors. 
```

```{definition,name="Context"}
$\Gamma : \mathcal{V}\nrightarrow\mathcal{C}$ is called a _context_.
```

Note that mono types with no free variables are considered to be application constructors with no arguments.

```{definition,name="Values"}
\begin{letIn}
$\mathcal{S}$ the class of all finite sets,
$n\in\mathbb{N}$,
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$,
$a\in\mathcal{V}$,
$T,T_1,T_2,S\in\mathcal{T}$,
$k\in\mathbb{N}_1^n\to\mathbb{N}_0$ and
$T_{i,k(j)}\in\mathcal{T}$ for all $i\in\mathbb{N}_1^n$ and $j\in\mathbb{N}_1^n$.
Let $\Gamma$ be a context.
\end{letIn}

We define
$$
\begin{aligned}
\mathrm{values}_\Gamma :& \ \mathcal{V} \to \mathcal{S}\\
\mathrm{values}_\Gamma(a) :=& \mathrm{values}_\Gamma(\Gamma(a))\\
\mathrm{values}_\Gamma(C \ T_1 \ \dots \ T_n) :=& \mathrm{values}_\Gamma(\Gamma(C)(T_1,\dots,T_n))\\
\mathrm{values}_\Gamma\small\begin{pmatrix*}[l]
    \mu C.\\
    | C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
    \end{pmatrix*} :=&\bigcup_{i\in\mathbb{N}_0} \mathrm{rvalues}_\Gamma
  \begin{pmatrix*}[l]
  i,&
  \small\begin{matrix*}[l]
    \mu C.\\
    | \ C_1 \ T_{1,1} \dots \ T_{1,k(1)}\\
    | \dots \\
    | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}
  \end{matrix*}
  \end{pmatrix*}\\
\mathrm{values}_\Gamma(\{l_1:T_1,\dots,l_n:T_n\}) :=\\
  \big\{\{l_1=t_1,&\dots,l_n=t_n\} \ | \ \forall i\in\mathbb{N}_1^n.t_i \in\mathrm{values}_\Gamma(T_i)\big\}\\
\mathrm{values}_\Gamma(T_1 \to T_2) :=&\{f \ | \ f:\mathrm{values}_\Gamma(T_1)\to\mathrm{values}_\Gamma(T_2)\}\\
\mathrm{values}_\Gamma(\forall a.T) :=& \lambda b.\mathrm{values}_{\{(a,b)\}\cup\Gamma}(T) \text{ where the symbol } b \text{ does}\\
  &\text{ not occur in } T.
\end{aligned}
$$
using the following helper function.
  
Let $l\in\mathbb{N},T := \mu C.\ | \ C_1 \ T_{1,1} \dots \ T_{1,k(1)}\ | \dots \ | \ C_n \ T_{n,1} \dots \ T_{n,k(n)}$. We define:
$$
\begin{aligned}
\mathrm{rvalues}_\Gamma(0,T):=&
  \begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. T_{i,j} \neq C \land v_j \in \mathrm{values}_\Gamma(T_{i,j})
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
\mathrm{rvalues}_\Gamma({l+1},T):=&
  \small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(l,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}
\end{aligned} 
$$
```
The base case of this recursive function is in $\mathrm{rvalues}_\Gamma(0,T)$ for a given $T$.

As an example we will prove that the values of $\mathit{Nat}$ from example \ref{ex:int} are isomorphic to the natural numbers.
```{theorem}
\begin{letIn}
the algebraic type $\mathit{Nat}$ defined as $\mathit{Nat}:=\mu C.1| \mathit{Succ} \ C$. Let $<_\mathbb{N}:\mathbb{N}\times\mathbb{N}$ be the Well-order such that $a<_\mathbb{N}b :\Leftrightarrow \exists c\in\mathbb{N}. a = b + c$. Let $<_\mathit{Nat}:\mathit{Nat}\times\mathit{Nat}$ be a order such that $\mathit{Succ}^a \ 1<_\mathit{Nat}\mathit{Succ}^b \ 1:\Leftrightarrow a+1 <_\mathbb{N} b+1$.
\end{letIn}
Then we have:
$$(\mathrm{values}(\mathit{Nat}),<_\mathit{Nat})\cong(\mathbb{N},<_\mathbb{N})$$
```
```{proof}
First we will introduce a new notation in order to simplify the proof:
For any $n\in\mathbb{N}_0$ We define $\mathit{Succ}^n \ 1 := \underbrace{\mathit{Succ} \ \dots \ \mathit{Succ}}_{n \text{ times}} \ 1$. Note that $\mathit{Succ}^0 \ 1 = 1$.

Next we show by induction over $n\in\mathbb{N}_0$ that
\begin{equation}\label{proof:natProof1}
\textrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)=\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}.
\end{equation}

\begin{addmargin}[1cm]{0cm}
\textbf{Base case}: $\mathrm{rvalues}_\Gamma(0,\mu C.1| Succ \ C) =\{1\}= \{\mathit{Succ}^0\}$. This is true.\newline
\textbf{Inductive step}:\newline
Assuming $\textrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C) =\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\},$
we will prove $\textrm{rvalues}_\Gamma(n+1,\mu C.1| \mathit{Succ} \ C)
=\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^{n+1}_0\}.$
  
$$
\begin{aligned}
&\mathrm{rvalues}_\Gamma(n+1,\mu C.1| \mathit{Succ} \ C)\\
&=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \mathrm{rvalues}_\Gamma(n,T)&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&=\small\begin{Bmatrix*}[l]
    \begin{array}{l|l}
      C_i \ v_1 \dots v_n
      & \begin{matrix*}[l]
        i\in\mathbb{N}_1^n\\
        \land \forall j\in\mathbb{N}_1^{k(i)}. v_j \in
        \begin{cases}
          \{\mathit{Succ}^k \ 1|k\in\mathbb{N}^n_0\}&\text{if } T_{i,j} = C\\
          \mathrm{values}_\Gamma(T_{i,j})&\text{else}
        \end{cases}
        \end{matrix*}
    \end{array}
  \end{Bmatrix*}\\
&=\{1\}\cup\{\mathit{Succ} v | v \in \{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}\}\\
&=\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^{n+1}_0\}
\end{aligned}
$$
\end{addmargin}

Now we will prove 
\begin{equation}\label{proof:natProof2}
\textrm{values}(\mu C.1| \mathit{Succ} \ C)=\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}.
\end{equation}

\begin{addmargin}[1cm]{0cm}
"$\subseteq$":
Let $x\in\textrm{values}(\mu C.1| \mathit{Succ} \ C)$.
We show
$$
x\in\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}.
$$
We know
$$
\textrm{values}(\mu C.1| \mathit{Succ} \ C)=\bigcup_{i\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(i,\mu C.1| \mathit{Succ} \ C)
$$
and
$$
\mathrm{rvalues}_\Gamma(i,\mu C.1| \mathit{Succ} \ C)\overset{(\ref{proof:natProof1})}{=}\{\mathit{Succ}^k \ 1|k\in\mathbb{N}^i_0\}
$$
This means, there exists an $i\in\mathbb{N}_0$ such that
$$
x\in\{\mathit{Succ}^k \ 1|k\in\mathbb{N}^i_0\}
$$
Therefore there exists a $k\in\mathbb{N}^i_0$, such that
$$x = \mathit{Succ}^k \ 1.$$
Thus, in conclusion,
$$x\in\{Succ^n \ 1|n\in\mathbb{N}_0\}.$$

"$\supseteq$":
Let $x \in\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}$. We show 
$$
x \in \textrm{values}(\mu C.1| \mathit{Succ} \ C)
$$
We know
$$
\textrm{values}(\mu C.1| \mathit{Succ} \ C)=\bigcup_{n\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C).
$$
Thus, it is suffice to show
$$
x \in \bigcup_{n\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)
$$
From $x \in\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}$ we know that there exists a $n\in\mathbb{N}_0$ such that 
$$x = \mathit{Succ}^n \ 1.$$
Using said $n$, we now construct $\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}$.
We know
$$
\begin{aligned}
\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}&\overset{(\ref{proof:natProof1})}{=} \mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)\\
&\subseteq\bigcup_{n\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)
\end{aligned}
$$
As $x \in\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}$ and $\{\mathit{Succ}^i \ 1|i\in\mathbb{N}^n_0\}\subseteq\bigcup_{n\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)$ we conclude
$$
x \in \bigcup_{n\in\mathbb{N}_0}\mathrm{rvalues}_\Gamma(n,\mu C.1| \mathit{Succ} \ C)
$$
\end{addmargin}

To summarize, we have just shown that $$\mathrm{values}(\mathit{Nat})=\textrm{values}(\mu C.1| \mathit{Succ} \ C)\overset{(\ref{proof:natProof2})}{=}\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}.$$

For the last step, we define a bijection
$$
\begin{aligned}
&h:\{\mathit{Succ}^n \ 1|n\in\mathbb{N}_0\}\to\mathbb{N}\\
&h(\mathit{Succ}^n \ 1) = n+1\\
&h^{-1}(n) = \mathit{Succ}^{n-1} \ 1
\end{aligned}
$$
Thus $$|\{Succ^n \ 1|n\in\mathbb{N}_0\}|=|\mathbb{N}|.$$
For all $n,m\in\mathbb{N}_0$ we see that
$$
\begin{aligned}
\mathit{Succ}^n \ 1<_\mathit{Nat}\mathit{Succ}^m \ 1&\Leftrightarrow n+1<_\mathbb{N}m+1\\
&\Leftrightarrow h(\mathit{Succ}^n \ 1)<_\mathbb{N}h(\mathit{Succ}^m \ 1)
\end{aligned}
$$
And therefore h is a isomorphism, thus
$$(\mathrm{values}(\mathit{Nat}),<_\mathit{Nat})\cong(\mathbb{N},<_\mathbb{N})$$
```