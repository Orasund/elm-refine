\setcounter{section}{4}
\setcounter{subsection}{1}

## Liquid Types for Elm

We will now extend the type system of Elm with liquid types.

### Syntax

We will use the syntax described in the last section.

```{definition,name="Extended Type Signature Syntax"}
Given two variable domains `<upper-var>` and `<lower-var>`, we define the following syntax:

$$
  \begin{aligned}
    \mf{<int-exp-type>} ::=& \mathit{Int}\\
      | \ & \mf{<int-exp-type> + <int-exp-type>}\\
      | \ & \mf{<int-exp-type> * }\mathit{Int}\\
      | \ & \mathcal{V}
  \end{aligned}
$$
$$
  \begin{aligned}
    \mf{<qualifier-type>} ::=& \mf{"True""}\\
      | \ & \mf{"False"}\\
      | \ & \mf{"(<)" <int-exp-type> v}\\
      | \ & \mf{"(<)" v <int-exp-type>}\\
      | \ & \mf{"(==)" v <int-exp-type>}\\
      | \ & \mf{"(\&\&)" <qualifier-type> <qualifier-type>}\\
      | \ & \mf{"(||)" <qualifier-type> <qualifier-type>}\\
      | \ & \mf{"not" <qualifier-type>}
  \end{aligned}
$$
$$
\begin{aligned}
\mf{<liquid}&\mf{-type>} ::=\\
  & \mf{"\{v:Int|"} \ \mf{<qualifier-type>} \ \mf{"\}"} \\
  &| \ \mf{<lower-var> ":\{v:Int|" <qualifier-type> "->" <liquid-type>}
\end{aligned}
$$
$$
\begin{aligned}
\mf{<type>} ::=& \mf{<liquid-type>}\\
           | \ & \mf{"Bool"}\\
           | \ & \mf{"List" <type>}\\
           | \ & \mf{"(" <type> "," <type> ")"}\\
           | \ & \mf{"\{" <list-type-fields> "\}"}\\
           | \ & \mf{<type> "->" <type>}\\
           | \ & \mf{<upper-var> <list-type>}\\
           | \ & \mf{<lower-var>}
\end{aligned}
$$
```

### Type Inference

We will also extend the inference rules. The interesting part is the new judgment for \mf{<exp>}: We introduce two new sets: $\Theta$ and $\Lambda$.
As before, $\Theta$ will contain the type of a variable (similarly to the previous section where  in $\Theta$ we stored the value of a variable). The set $\Lambda$ contains boolean expressions that get collected while traversing if-then-else branches. We will use these expressions to allow path sensitive subtyping.

#### Type Signature Judgments

For type signature judgments, let $\mathit{exp}\in\mathit{IntExp}$, $q\in\mathcal{Q}$. Let $\Gamma,\Delta$ be type contexts. Let $\Lambda\subset\mathcal{Q}$ and $\Theta:\mathcal{V}\nrightarrow\mathcal{T}$.

For $\mathit{iet}\in\mf{"<int-exp-type>"}$, the judgment has the form

$$
\mathit{iet}:\mathit{exp}
$$

which can be read as "$\mathit{iet}$ corresponds to $\mathit{exp}$".

For $\mathit{qt}\in\mf{"<qualifier-type>"}$, the judgment has the form

$$
\mathit{qt}:q
$$

which can be read as "$\mathit{qt}$ corresponds to $q$"

For $\mathit{lt}\in\mf{"<liquid-type>"}$, the judgment has the form

$$
\mathit{lt}:_\Theta\hat{T}
$$

which can be read as "$\mathit{lt}$ corresponds to the liquid type $\hat{T}$ with respect to $\Theta$".

As previously already stated, for $t\in\mf{<type>}$ the judgment has the form

$$
\Gamma\vdash t:T
$$

which can be read as "given $\Gamma$, $t$ has the type $T$".

For $e\in\mf{<exp>}$ the judgment has the form

$$
\Gamma,\Delta,\Theta,\Lambda\vdash e:T
$$

which can be read as "given $\Gamma$, $\Delta$, $\Theta$ and $\Lambda$, $e$ has the type $T$".

### Auxiliary Definitions

#### Substitution

```{definition,name="Refinement Substitution"}
\begin{letIn}
$a$ be a variable, $e\in\mathit{IntExp}$. For $r\in\mathcal{Q}$ let $[r]_{a\leftarrow e}$ denote the substitution on expressions.
\end{letIn}

For a given liquid type we define the _refinement substitution_ as follows:

$$
\begin{aligned}
[\{b:\mathit{Int}| r \}]_{a\leftarrow e} :=& \{b:\mathit{Int}| [r]_{a\leftarrow e} \}\\
[b:\{c:\mathit{Int}| r \}\to\hat{T}]_{a\leftarrow e} :=& b:\{c:\mathit{Int}| [r]_{a\leftarrow e} \}\to[\hat{T}]_{a\leftarrow e}
\end{aligned}
$$
```

Note that we assume for $r\in\mathcal{Q}$ that $[r]_{a\leftarrow e}$ is well formed. In particular, that $[r]_{a\leftarrow e}$ must again life in $\mathcal{Q}$. We can enforce this requirement by the inference rules for \mf{<qualifier-type>}.

#### Well-formed Liquid Type

We have already defined well-formed logical qualifiers expressions. We will now extend the notion to well-formed liquid types.

```{definition,name="Well-formed Liquid Type"}
\begin{letIn}
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$.
\end{letIn}
We define following.
\[
\text{wellFormed}\subseteq\{t\in\mathcal{T}| t \text{ is a liquid type}\}\times(\mathcal{V}\nrightarrow\mathbb{N})
\]\[
\begin{aligned}
\text{wellFormed}(\{b:\mathit{Int}| r \},\{(a_1,T_1),\dots,(a_n,T_n)\}) :\Leftrightarrow\\
\forall k_1\in\text{value}_\Gamma(T_1).\dots \forall k_n\in\text{value}_\Gamma(T_n).\\
r\text{ is well defined with respect to }& \{(a_1,k_1),\dots,(a_n,k_n),(b,\mathit{Int})\}
\end{aligned}
\]\[
  \begin{aligned}
\text{wellFormed}(a:\{b:\mathit{Int}| r \}\to\hat{T},\Theta) :\Leftrightarrow\\
(a,\_)\not\in \Theta\ \land \ \text{wellFormed}(\{b:\mathit{Int}| r \},\Theta)&\ \land\ \text{wellFormed}(\hat{T},\Theta\cup\{(a,\{b:\mathit{Int}| r \})\})
\end{aligned}
\]
```

#### Subtyping

```{definition,name="Subtyping"}
\begin{letIn}
$\Theta:\mathcal{V}\nrightarrow\mathcal{T}$. Let $\Lambda\subset\mathcal{Q}$, $r_1,r_2\in\mathcal{Q}$
\end{letIn}
We define the following.
$$
\begin{aligned}
\{a_1:\mathit{Int}| r_1 \} <:_{\Theta,\Lambda} \{ a_2 : \mathit{Int}| r_2\} \ :\Leftrightarrow \ & \text{Let} \ \{(b_1,T_1),\dots,(b_n,T_n)\}=\Theta \ \text{in}\\
&\forall k_1\in\text{value}_\Gamma(T_1).\dots \forall k_n\in\text{value}_\Gamma(T_n).\\
&\forall n\in\mathbb{N}.\forall e \in\Lambda.\\
                                                                                  &\quad \semantic{$e$}_{\{(a_1,n),(b_1,k_1),\dots,(b_n,k_n)\}}\\
   &\quad\land \semantic{$r_1$}_{\{(a_1,n),(b_1,k_1),\dots,(b_n,k_n)\}}\\
                                                                                  &\Rightarrow\semantic{$r_2$}_{\{(a_2,n),(b_1,k_1),\dots,(b_n,k_n)\}}
\end{aligned}
$$
$$
\begin{aligned}
a_1:\{b_1:\mathit{Int}| r_1 \}\to\hat{T}_2 <:_{\Theta,\Lambda}& a_1:\{ b_2 : \mathit{Int}| r_2\}\to\hat{T}_4 \ :\Leftrightarrow\\ 
&\{ b_2 : \mathit{Int}| r_2\}<:_{\Theta,\Lambda}\{b_1:\mathit{Int}| r_1 \}\\
&\land\hat{T}_2<:_{\Theta\cup\{(a_1,\{ b_2 : \mathit{Int}| r_2\})\},\Lambda}\hat{T}_4
\end{aligned}
$$
For two liquid types $\hat{T}_1,\hat{T}_2$, we say $\hat{T}_1$ is a subtype of $\hat{T}_2$ with respect to $\Theta$ and $\Lambda$ if and only if $\hat{T}_1<:_{\Theta,\Lambda}\hat{T}_2$ is valid. 
```

Subtyping comes with an additional inference rule for $\mf{<exp>}$. The sharpness of the inferred subtype depends on the capabilities of the SMT-Solver. Using this optional inference rule, the SMT-Solver will need to find the sharpest subtype, or at least sharp enough: In the case of type checking, it might be that the subtype is too sharp and therefore the SMT-Solver can't check the type successfully.

\logicRule
{\Gamma,\Delta,\Theta,\Lambda\vdash e:\hat{T}_1\quad
\hat{T}_1<:_{\Theta,\Lambda}\hat{T}_2\quad
\text{wellFormed}(\hat{T}_2,\Theta)
}
{\Gamma,\Delta,\Theta,\Lambda\vdash e:\hat{T}_2}
{}

Note that we include $\Lambda$ in our definition. This way we require that the SMT-Solver will allow path sensitive subtyping.

### Inference Rules for Type Signatures

#### int-exp-type

Judgment: $\mathit{iet}:\mathit{exp}$

\logicRule
{i:\mathit{Int}}
{i:i}
{}

\logicRule
{\mathit{iet}_1 : \mathit{exp}_1\quad
\mathit{iet}_2 : \mathit{exp}_2\quad
\mathit{exp}_1 + \mathit{exp}_2 = \mathit{exp}_3
}
{\mathit{iet}_1 \ \mf{+} \ \mathit{iet}_2 : \mathit{exp}_3}
{}

\logicRule
{i:\mathit{Int}\quad
\mathit{iet} : \mathit{exp}_0\quad
\mathit{exp}_0 * i = \mathit{exp}_1
}
{\mathit{iet} \ \mf{*} \ \mathit{i} : \mathit{exp}_1}
{}

\logicRule
{a = \mathit{exp}
}
{\mathit{a}:\mathit{exp}}
{}

#### qualifier-type

Judgment: $\mathit{qt}:q$

This judgment is used to convert from $\mf{qualifier-type}$ to $\mathcal{Q}$. 

\logicRule
{
}
{\mf{True}:\mathit{True}}
{}

\logicRule
{
}
{\mf{False}:\mathit{False}}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\mathit{exp}_0 < \nu = q
}
{\mf{(<)} \ \mathit{iet} \ \mf{v}:q}
{}
Note that where we replace the letter $\mf{v}$ with a special character $\nu$.

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
\nu < \mathit{exp}_0 = q
}
{\mf{(<) v} \ \mathit{iet}:q}
{}

\logicRule
{\mathit{iet}:\mathit{exp}_0\quad
(\nu = \mathit{exp}_0) = \mathit{q}
}
{\mf{(=) v} \ \mathit{iet}:\mathit{q}}
{}

\logicRule
{\mathit{qt}_1:\mathit{q}_1\quad
\mathit{qt}_2:\mathit{q}_2\quad
\mathit{q}_1 \land \mathit{q}_2 = \mathit{q}_3
}
{\mf{(\&\&)} \ \mathit{qt}_1 \ \mathit{qt}_2:\mathit{q}_3}
{}


\logicRule
{\mathit{qt}_1:\mathit{q}_1\quad
\mathit{qt}_2:\mathit{q}_2\quad
\mathit{q}_1 \lor \mathit{q}_2 = \mathit{q}_3
}
{\mf{(||)} \ \mathit{qt}_1 \ \mathit{qt}_2:\mathit{q}_3}
{}

\logicRule
{\mathit{qt}:\mathit{q}_1\quad
\neg\mathit{q}_1 = \mathit{q}_2
}
{\mf{not} \ \mathit{qt}:\mathit{q}_2}
{}

#### liquid-type

Judgment: $\mathit{lt}:_\Theta\hat{T}$

\logicRule
{\mathit{qt}:q\quad
\{\nu:\mathit{Int}| \ q \ \}=\hat{T}\quad
\text{wellFormed}(\hat{T}_2,\Theta\cup\{(\nu,\mathit{Int})\})
}
{\mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"}:_\Theta\hat{T}}
{}

\logicRule
{\mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"}:_\Theta\hat{T}_1\quad
\mathit{lt}:_{\Theta\cup\{(a,\hat{T}_1)\}}\hat{T}_2\quad
(a:\hat{T}_1\rightarrow\hat{T}_2) = \hat{T}_3
}
{a \ \mf{":"} \ \mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"} \ \mf{"->"} \ \mathit{lt}:_\Theta\hat{T}_3}
{}

#### type

Judgment: $\Gamma\vdash t:T$

\logicRule
{\mathit{lt}:_{\{\}}\hat{T}
}
{\Gamma\vdash \mathit{lt}:\hat{T}}
{}

All other inference rules for types have already been described.

### Inference Rules for Expressions

#### Exp

The following are special inference rules for liquid types. For non-liquid types the old rules still apply.

\logicRule
{}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"(+)"}:(a:\mathit{Int}\to b:\mathit{Int}\to\{\nu:\mathit{Int} \ | \ \nu = a + b\})}
{}

\logicRule
{}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"(-)"}:(a:\mathit{Int}\to b:\mathit{Int}\to\{\nu:\mathit{Int} \ | \ \nu = a + (-b)\})}
{}

\logicRule
{}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"(*)"}:(a:\mathit{Int}\to b:\mathit{Int}\to\{\nu:\mathit{Int} \ | \ \nu = a * b\})}
{}

\logicRule
{}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"(//)"}:\mathit{Int}\to\{\nu:\mathit{Int} \ | \ \neg (\nu = 0)\}\to\mathit{Int}}
{}

By using a liquid type we can avoid dividin by zero.

\logicRule
{
\begin{gathered}
\Gamma,\Delta,\Theta,\Lambda\vdash e_1:\textit{Bool}\quad
e_1:e_1'\\
\Gamma,\Delta,\Theta,\Lambda\cup\{e_1'\}\vdash e_2: \hat{T}\quad
\Gamma,\Delta,\Theta,\Lambda\cup\{\neg e_1'\}\vdash e_3: \hat{T}
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"if"} \ e_1  \ \mf{"then"} \ e_2 \ \mf{"else"} \ e_3:\hat{T}}
{}

We add the condition $e_1$ to $\Lambda$ and ensure that the resulting liquid type is well-formed.
Note that we assume that $e_1\in\mf{<qualifier-type>}$. If this is not the case, then the inference rule can not be applied and therefore the judgment can not be derived. In some cases we can recover by falling back to the old rule for non-liquid types, but recovery is not guaranteed.

\logicRule
{\begin{gathered}
\Gamma,\Delta,\Theta,\Lambda\vdash e_1: (a:\hat{T}_1\to \hat{T}_2)\\
\Gamma,\Delta,\Theta,\Lambda\vdash e_2: \hat{T}_1\quad
e_2:e_2'\quad
[\hat{T}_2]_{a\leftarrow e_2'} =\hat{T}_3
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash e_1 \ e_2: \hat{T}_3}
{}

We change the type of $e_1$ to $a:\hat{T}_1\to \hat{T}_2$. To ensure that $a$ can't escape the scope, we substitute it with $e_2'$. Note that we assume that $e_2\in\mf{<qualifier-type>}$, else we can try to recover by using the inference rules for non-liquid types.

\logicRule
{\begin{gathered}
a:\hat{T}_1\to \hat{T}_2 = \hat{T}_3\\
\Gamma,\Delta\cup\{(a,\hat{T}_1)\},\Theta\cup\{(a,\hat{T}_1)\},\Lambda\vdash e: \hat{T}_2
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash\mf{"\textbackslash"} \ a \ \mf{"->"} \ e: \hat{T}_3}
{}

We define the type as $a:\hat{T}_1\to \hat{T}_2 = \hat{T}_3$. Note that the variable $a$ in the expression realm and the variable $a$ within the context of liquid types are the same. This is because we assume that renaming can be applied at any step of the type inference. To avoid having double bound variables, we require that $a:\hat{T}_1\to \hat{T}_2$ is well-formed.

\logicRule
{\begin{gathered}
\{\nu:\hat{T}| \ \nu = a\}<:_{\Theta,\Lambda}\{\nu:\hat{T}| \ r\}\\
(a,\{\nu:\hat{T}| \ r\}) \in \Delta\quad
(a,\{\nu:\hat{T}| \ r\}) \in \Theta
\end{gathered}
}
{\Gamma,\Delta,\Theta,\Lambda\vdash a: \{\nu:\hat{T}| \ \nu = a\}}
{}

We can give a variable a sharp liquid type.

\text{\textemdash}

All other inference rules for expressions have not changed.

### Denotational Semantic

For the denotational semantic we only need to extend the semantic for type signatures.

```{definition, name="Type Signature Semantic"}
\begin{letIn}
Let $\Gamma$ be a type context. Let $\Theta:\mathcal{V}\nrightarrow\mathcal{T}$.
\end{letIn}
$$
\begin{aligned}
\semantic{.}:&\mf{<int-exp-type>}\to\mathit{IntExp}\\
\semantic{$n$} = & n\\
\semantic{$\mathit{iet}_1 \mf{+} \mathit{iet}_2$} = & i_1 + i_2\\
    &\text{such that } i_1 = \semantic{$\mathit{iet}_1$} \text{ and } i_2 = \semantic{$\mathit{iet}_2$} \text{ where } i_1,i_2\in\mathit{IntExp}\\
\semantic{$\mathit{iet} \mf{*} n$} = & i \cdot n\\
    &\text{such that } i = \semantic{$\mathit{iet}$}\text{ where } i\in\mathit{IntExp}\\
\semantic{$a$} = & a
\end{aligned}
$$
$$
\begin{aligned}
\semantic{.}:&\mf{<qualifier-type>}\to\mathcal{Q}\\
\semantic{"True"} = & \mathit{True}\\
\semantic{"False"} = & \mathit{False}\\
\semantic{"(<)" $\mathit{iet} \ v$} = & i < \nu\\
    &\text{such that } i = \semantic{$\mathit{iet}$}\text{ where } i\in\mathit{IntExp}\\
\semantic{$\mf{"(<)"} \ v \ \mathit{iet}$} = &\nu < i\\
    &\text{such that } i = \semantic{$\mathit{iet}$}\text{ where } i\in\mathit{IntExp}\\
\semantic{$\mf{"(==)"} \ v\ \mathit{iet}$} = &\nu = i\\
    &\text{such that } i = \semantic{$\mathit{iet}$}\text{ where } i\in\mathit{IntExp}\\
\semantic{$\mf{"(\&\&)"} \ qt_1 \ qt_2$} = &q_1 \land q_2\\
    &\text{such that } q_1 =  \semantic{$qt_1$}\text{ and } q_2 =\semantic{$qt_2$}\\
    &\text{where } q_1\in\mathcal{Q}\text{ and } q_2\in\mathcal{Q}\\
\semantic{$\mf{"(||)"}\ qt_1\ qt_2$} = &q_1 \lor q_2\\
    &\text{such that } q_1 = \semantic{$qt_1$}\text{ and } q_2 = \semantic{$qt_2$}\\
    &\text{where } q_1\in\mathcal{Q}\text{ and } q_2\in\mathcal{Q}\\
\semantic{$\mf{"not"} \ qt$} = &\neg q\\
    &\text{such that } q = \semantic{$qt$}\text{ where } q\in\mathcal{Q}
\end{aligned}
$$
$$
\begin{aligned}
\semantic{.}:&\mf{<liquid-type>}\to\mathcal{T}\\
\semantic{$\mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"}$}=&\{\nu:\mathit{Int}|\ r \ \}\\
    &\text{such that } r = \semantic{$\mathit{qt}$}\text{ where } r\in\mathcal{Q}\\
\semantic{$a \ \mf{":"} \ \mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"} \ \mf{"->"} \ \mathit{lt}$}=& a: \hat{T}_1 \to \hat{T}_2\\
    &\text{such that } \hat{T}_1 = \semantic{$\mf{"\{v:Int|"}\ \mathit{qt} \ \mf{"\}"}$},\\
    &\text{and } \hat{T}_2 \semantic{$\mathit{lt}$}\text{ where } \hat{T}_1,\hat{T}_2 \text{ are liquid types}
\end{aligned}
$$

We extend $\semantic{.}_\Gamma:\mf{<type>}\to\mathcal{T}$ by \(\semantic{$lt$}_\Gamma =\semantic{$lt$}\) to now allow liquid types as type signatures.
```