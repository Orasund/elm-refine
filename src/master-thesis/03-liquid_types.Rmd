\setcounter{section}{2}

# Liquid Types

## Definiting the Type System

First, we define some notations:

* $\mathbb{N}$ are the natural numbers starting from $1$.
* $\mathbb{N}_0$ are the natural numbers starting from $0$.
* $\mathbb{N}_a^b:=\{i\in \mathbb{N}_0 | a \leq i \land i \leq b\}$.
* We'll use "$.$" to seperate a quantifer from a statement: $\forall a . b$ and $\exists a . b$.
* Functions will be written as $a_1 \to .. \to a_n \to b$ instead of $a_1 \times .. \times a_n \to b$.

For this thesis we will use a Hindley-Milner type system.

```{block2, type="axiom" ,latex.options="[Types]_"}
\begin{letIn}
n\in\mathbb{N};\quad \forall i\in\mathbb{N}_a^b.k_i\in\mathbb{N}_0;\quad \forall i\in\mathbb{N}_a^b.C_i\text{ be a unique symbol}
\end{letIn}

$T$ is a _type_ if either

* (_Type variable_) $T$ is a symbol.

* (_Type application_) $T$ has the form
    $T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n}$
    
    where $\forall i\in\mathbb{N}_1^n \forall j\in\mathbb{N}_0^{k_i}. T_{i,j}$ is a type application or type variable.

* (_Quantified Type_) $T$ has the form $T = \forall a_1 .. \forall a_n.T'$

    where $T'$ is a type application or a type variable and $\forall i\in\mathbb{N}_1^n.a_i$ is a type variable.

We write $v:T$ to declare that $v$ has the type $T$.
```

For applied quanitifed types, the quantifer moves to the upper most level.
      As an example: $List (\forall a.a)$ is the same as $\forall a.List a$. This property will later be used for comparing two types.(See Unification).

```{definition,name="Meta-level types"}
For simpler notation, we will define Meta-level types.

We define

  * $\mathcal{V}$ as the (meta-level) type of all type variables.
  * $\mathcal{A}$ as the (meta-level) type of all type applications.
  * Mono types $\mathcal{M}::= \mathcal{V} \ | \mathcal{A}$.
  * Poly types $\mathcal{P}$ as the (meta-level) type of all quantified types.
  * Type of Types $\mathcal{T}::= \mathcal{V} \ | \mathcal{A} \ | \ \mathcal{P}$.

&nbsp;
```

Using these types we can now differenciate between a type variable ($a:\mathcal{V}$), a type application ($a:\mathcal{A}$) and a poly type ($a:\mathcal{P}$). We can also define a general type ($a:\mathcal{T}$) or a mono type ($a:\mathcal{M}$).

```{definition,name="Sort, Value, Constructor"}
\begin{letIn}
n\in\mathbb{N};\quad
\forall j\in\mathbb{N}_1^n k_j\in\mathbb{N};\quad
{i\in\mathbb{N}_1^n};\quad
\forall j:\mathbb{N}_0^{k_i}.t_j: T_{i,j};\\
T:\mathcal{A}.\quad
T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n}
\end{letIn}
We call

* $C_i \ T_{i,1} \ .. \ T_{i,k_1}$ a _sort_ of $T$,
* $C_i \ t_0 \ .. \ t_{k_i}$ a _value_ of $T$,
* $C_i$ a _terminal_ of $T$,
* the function
    $$
      \begin{aligned}
      C_i&: T_{i,1} \to .. \to T_{i,k_1} \to T\\
      C_i&(t_1,..,t_n) := C_i \ t_1 \ .. \ t_n
      \end{aligned}
    $$
    a _constructor_ of $T$.

&nbsp;
```

```{definition,name="Bounded, Free, Set of free variables"}
\begin{letIn}
T:\mathcal{P};\quad
T=\forall a.T'.
\end{letIn}
$a:\mathcal{V}$ is called _bounded_. Unbounded type variables are called _free_. 

The set of all free type variables of a type is denoted as $\text{free}$:

$$
  \begin{aligned}
    \text{free}(a:\mathcal{V}) :=& {a}\\
    \text{free}(T:\mathcal{A}) :=& \text{let } T ::= C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n} \text{ in }\\
    &\bigcup_{i\in\mathbb{N}_0^n}\bigcup_{j\in\mathbb{N}_0^{k_i}}\text{free}(T_{i,j}:\mathcal{V})\\
    \text{free}(T:\mathcal{P}) :=& \text{let } T=\forall a_1 .. \forall a_n.T' \text{ in }\\
    &\text{free}(T':\mathcal{M})\backslash\{a_1,..,a_n\}
  \end{aligned}
$$
```

A type can be substituted by replacing a bounded type variable with a mono type:

```{definition,name="Type substitution"}
$$
  \begin{aligned}[]
    [a:\mathcal{V}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}} :=& \begin{cases} S & \text{if } a = a_i\\ a &\text{else} \end{cases}\\
    [T:\mathcal{A}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}}:=& \text{let } C_1 \ T_{1,1} \ .. \ T_{1,k_1} \ | \ .. \ | \ C_n \ T_{n,1} \ .. \ T_{n,k_n} \text{ in }\\
    &C_1 \ [T_{1,1}]_{a_i \mapsto S} \ ..\ [T_{1,k_1}]_{a_i \mapsto S} \\
    &| \ .. \\
    &| \ C_n \ [T_{n,1}]_{a_i \mapsto S} \ .. \ [T_{n,k_n}]_{a_i \mapsto S}\\
    [T:\mathcal{P}]_{a_i:\mathcal{V} \mapsto S:\mathcal{M}} :=& \text{let } T = \forall a_1 .. \forall a_n.T' \text{ in }\\
    & \forall a_1 .. \forall a_{i-1} \forall a_{i+1} .. \forall a_n[T']_{a_i \mapsto S}
  \end{aligned}
$$
```

The type substitution gives raise to a partical order $\sqsubseteq$:

```{block2, type="axiom" ,latex.options="[Type Order]_"}
$$
\dfrac
{T'=[T]_{\forall i\in\mathbb{N}_0^n.a_i \mapsto T_i:\mathcal{M}} 
\quad \forall i\in\mathbb{N}_0^m.b_i\not\in \text{free}(\forall a_1 .. \forall a_n.T)
\quad m \leq n
}
{\forall a_1 .. \forall a_n.T \sqsubseteq \forall b_1 .. \forall b_m.T'}
$$
```

Informal the rule can be read as follows:

* First replace all bounded variables with mono types.
* Next rebound any new variables (variables that where previously not free).

```{block2, type="axiom" ,latex.options="[Product Type]_"}
\begin{letIn}
n \in \mathbb{N};\quad
\forall i\in\mathbb{N}_1^n.T_i:\mathbb{T}, l_i \text{ be a unique symbol}.
\end{letIn}

We call $T = \{l_1:T_1,..,l_n:T_n\}$ a _product type_. We say that $T:\mathcal{A}$.

* We call $\forall i\in\mathbb{N}_1^n.l_i$ the labels of the product type.
* The values of a product type have the form $\{l_1=t_1,..,l_n=t_n\}$ where $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
* The types $T_i$ are unordered: $\{a:T_1,b:T_2\} = \{b:T_2,a:T_1\}$.

For ordered product types we write

$T_1 \times .. \times T_n := \{1:T_1,..,n:T_n\}.$

Values of a ordered product type have the form $(t_1,..,t_n)$ $\forall_{i\in\mathbb{N}_1^n}.t_i:T_i$.
```

```{block2, type="axiom" ,latex.options="[Functions]_"}

The function $T_1:\mathcal{T} \rightarrow T_2:\mathcal{T}$ is a mono type.

```

```{definition,name="Set of Types"}

We define $s \subseteq T:\mathcal{T}$ as a set containing elements of type $T$.

```