# Semantic Domains

STATE_CONSTS := 𝒫(VAR_S × VALUE)
STATE_TYPES := 𝒫(TYPE_S × TYPE)
STATEMENT_CONF := STATEMENT × STATE_CONSTS × STATE_TYPES
EXPRESSION_CONF := EXP × STATE_CONSTS × STATE_TYPES

# Helper functions

vars ⊆ STATE_CONSTS x 𝒫(VALUE)
vars(sc) := { v:VALUE | ∃ x:STATE . (v,x) ∈ sc }

vars ⊆ STATE_TYPES x 𝒫(TYPE)
vars(st) := { v:TYPES | ∃ x:STATE . (v,x) ∈ st }

# Transitions

. ->> . ⊆ STATEMENT_CONF × VALUE
. ->> . ⊆ EXPRESSION_CONF × STATE




# Inference Rules for statements

[[TypeVariable n vs ss]]✔<{},types(st)>      #              Type is well defined
st' := (n,TypeVariable n vs ss) ∪ st         #    Type definition is now defined
(C,sv,st') ->> v                             # Next statement uses the new state
---------------------------------
( Type n vs ss C , sc, st ) ->> v

[[tn]]✔<ts,types(st)>                        #              Type is well defined
st' = (n,tn) ∪ st                            #    Type definition is now defined
(C,sc,st') ->> v                             # Next statement uses the new state
--------------------------------
( Alias n ts tn C, sc, st) ->> v

[[t]]✔<{},types(st)>                         #              Type is well defined
(e,sc,st) ->> v'                             #         expression gets evaluated
n ∉ values(sc)                               #         variable name is not used
sc' := (n,v') ∪ sc                           #       new constant is now defined
(C,sc',st) ->> v                             # Next statement uses the new state
----------------------------------
( Constant n t e C, sc, st ) ->> v

[[t]]✔<{},types(st)>                         #              Type is well defined
(e,sc,st) ->> v                              #         expression gets evaluated
--------------------------
( Main t e, sc, st ) ->> v




# Inference Rules for expressions

                              #requires pattern matching
--------------------------
Call EXP EXP

                              #requires pattern matching
----------------------- 
Case EXP (PATTERN EXP)*

(Value v, sc, st ) ->> v

[[t]]✔<{},types(st)>                         #              Type is well defined
(e,sc,st) ->> v'                             #         expression gets evaluated
n ∉ values(sc)                               #         variable name is not used
sc' := (n,v') ∪ sc                           #       new constant is now defined
(E,sc',st) ->> v                             # Next statement uses the new state
------------------------------
(LetIn n t e E, sc, st ) ->> v

(n,Record (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) ∈ sc  #n is record with field f_i
---------------------------------------------------
(Get n f_i, sc, st) ->> v_i

(n,Record (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) ∈ sc  #n is record with field f_i
(e, sc, st) ->> v                                          #field gets evaluated
------------------------------------------------------------------
(Set n f_i e, sc, st) ->> Record (f_1 v_1) .. (f_i v) .. (f_k v_k)

(RecordConstructor (f_1 v_1) .. (f_i v_i) .. (f_k v_k), sc, st) ->> Record (f_1 v_1) .. (f_i v_i) .. (f_k v_k)

∃ (n,TypeVariable _ _ (s_1 _) .. (s _) .. (s_1 _) ∈ sc       #Constructor exists
---------------------------------------------------------------
(Constructor s e_1 .. e_k, sc, st) ->> CustomValue s e_1 .. e_k

(b, sc, st) ->> BoolValue True
(e1, sc, st) ->> v
----------------------------------
(IfThenElse b e1 e1, sc, st) ->> v

(b, sc, st) ->> BoolValue False
(e2, sc, st) ->> v
----------------------------------
(IfThenElse b e1 e2, sc, st) ->> v


# Builtin Functions

(Call (LambdaValue i2 o2) (Call (LambdaValue i1 o1) i3), sc, st) ->> o3
---------------------------------------------------------------------------------------------------------------
(Composition, sc, st) ->> LambdaValue (LambdaValue i1 o1) (LambdaValue (LambdaValue i2 o2) (LambdaValue i3 o3))

(Call (LambdaValue i o) e) ->> e'
-------------------------------------------------------------------
(Pipe, sc, st) ->> LambdaValue e (LambdaValue (LambdaValue i o) e')

(e1, sc, st) ->> BoolValue b1
(e2, sc, st) ->> BoolValue b2
b3 <=> b1 ∨ b2
---------------------------------------------------------------
(Or, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> BoolValue b1
(e2, sc, st) ->> BoolValue b2
b3 <=> b1 ∧ b2
----------------------------------------------------------------
(And, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> BoolValue b1
b2 <=> ¬ b1
-----------------------------------------------
(Not, sc, st) ->> LambdaValue e1 (BoolValue b2)

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
e3 <=> a = b
------------------------------------------------------------------
(Equal, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
a < b
-----------------------------------------------------------------
(Less, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
∃d∈ℤ. d < b ∧ a = c*b + d
---------------------------------------------------------------
(Divide, sc, st) ->> LambdaValue e1 (LambdaValue e2 IntValue c)

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a ⋅ b
-------------------------------------------------------------------
(Multiply, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a - b
-------------------------------------------------------------------
(Subtract, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a + b
--------------------------------------------------------------
(Add, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->>  a_1
(e2, sc, st) ->> (ListValue a_2 .. a_k)
------------------------------------------------------------------------
Cons, sc, st) ->> LambdaValue e1 (LambdaValue e2 (ListValue a_1 .. a_k))


(l, sc, st) ->> (ListValue)
(i, sc, st) ->> o
-----------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))

(l, sc, st) ->> (ListValue h l_1 .. l_j)
(i, sc, st) ->> (ListValue o_1 .. o_k)
(Call (Call (LambdaValue (LambdaValue a (LambdaValue b1 b2))) h) (ListValue o_1 .. o_k), sc ,st) ->> h'
(Call (Call (Call Foldl (LambdaValue (LambdaValue a (LambdaValue b1 b2)))) (ListValue h' o_1' .. o_k')) (ListValue l_1 .. l_j),sc ,st) -> o
------------------------------------------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))