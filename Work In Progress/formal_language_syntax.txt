Let `VAR_S`,`TYPE_S` be disjoint types of Symbols.

#---------------------------------------
# Types
#---------------------------------------

TYPE =
  Unit                                             #Notation: `()`
| Bool
| Int
| List TYPE
| Tuple TYPE TYPE                                #Notation: `(TYPE,TYPE)`
| Record (LIST (VAR_S TYPE))                           #Notation: `{VAR_S:TYPE,..,VAR_S:TYPE}`
| Function TYPE TYPE                             #Notation: `TYPE -> TYPE`
| Algebraic TYPE_S (LIST VAR_S) (LIST (TYPE_S (LIST TYPE_S)))   #Notation: `TYPE_S VAR_S..VAR_S`
| TypeVariable VAR_S                                     #Notation: `VAR_S`

#---------------------------------------
# Expressions and Statements
#---------------------------------------

                               #Type                                Notation
EXP =                 
  Foldl                        #`(a -> b -> b) -> b -> List a -> b` `foldl`
| Cons                         #`a -> List a -> List a`             `::`  (infix)
| Add                          #`Int -> Int -> Int`                 `+`   (infix)
| Subtract                     #`Int -> Int -> Int`                 `-`   (infix)
| Multiply                     #`Int -> Int -> Int`                 `*`   (infix)
| Divide                       #`Int -> Int -> Int`                 `//`  (infix) Note: a // 0 == 0
| Less                         #`Int -> Int -> Bool`                `<`   (infix)
| Equal                        #`Int -> Int -> Bool`                `==`  (infix)
| Not                          #`Bool -> Bool`                      `not`
| And                          #`Bool -> Bool -> Bool`              `&&`  (infix)
| Or                           #`Bool -> Bool -> Bool`              `||`  (infix)
| Pipe                         #`a -> (a -> b) -> b`                `|>`  (infix)
| Composition                  #`(a->b) -> (b->c) -> (a->c)`        `>>`  (infix)
| IfThenElse                   #`Bool -> a -> a -> a`               `if EXP then EXP else EXP`
| Constructor TYPE_S (LIST EXP)                        #Notation: `TYPE_S EXP..EXP`
| RecordConstructor (LIST (VAR_S EXP))                 #Notation: `{VAR_S = EXP,..,VAR_S = EXP}`
| Set VAR_S VAR_S EXP                            #Notation: `{VAR_S | VAR_S = EXP}`
| Get VAR_S VAR_S                                #Notation: `VAR_S.VAR_S`
| LetIn VAR_S TYPE EXP EXP                       #Notation: `let VAR_S : TYPE; VAR_S = EXP; in EXP`
| Case EXP (LIST (PATTERN EXP))                        #Notation: `case EXP of [ PATTERN -> EXP;..; PATTERN -> EXP ]`
| Call EXP EXP                                   #Notation: `EXP EXP` 
| UnitLiteral                                      #Notation: `()`
| BoolLiteral BOOL
| IntLiteral INT
| ListExp (LIST EXP)                                 #Notation: `[EXP,..,EXP]`
| TupleExp EXP EXP                             #Notation: `(EXP,EXP)`
| RecordExp (LIST (VAR_S,EXP))                       #Notation: `{VAR_S=EXP,..,VAR_S=EXP}`
| LambdaExp PATTERN EXP                        #Notation: `\PATTERN -> EXP`
| AlgebraicExp TYPE_S (LIST EXP)
| Variable VAR_S

BOOL = True | False

INT = 0 | 1 | -1 | 2 | -2 | ...

LIST a =
  Empty
  | Cons a (LIST a)

MAYBE a =
  JUST a
  | Nothing

PATTERN =
| UnitPattern
| BoolPattern BOOL
| IntPattern INT
| ListPattern (LIST PATTERN)
| TuplePattern PATTERN PATTERN
| AlgebraicPattern TYPE_S (LIST PATTERN)
| VariablePattern
| As PATTERN VAR_S                               #Notation: `(PATTERN as VAR_S)`
| Fields (LIST PATTERN)                                #Notation: `{PATTERN,..,PATTERN}` Note: For Records
| HeadAndTail PATTERN PATTERN                    #Notation: `PATTERN :: PATTERN`   Note: For Lists
| Wildcard                                       #Notation: `_`

STATEMENT =
| Constant VAR_S TYPE EXP                        #Notation: `VAR_S : TYPE; VAR_S = EXP; STATEMENT`
| Alias TYPE_S (LIST VAR_S) TYPE                       #Notation: `type alias TYPE_S VAR_S..VAR_S = TYPE; STATEMENT`
| Type TYPE_S (LIST VAR_S) (LIST ( TYPE_S (LIST TYPE))) #Notation: `type TYPE_S VAR_S..VAR_S = TYPE_S TYPE..TYPE |..| TYPE_S TYPE..TYPE`

(alias) PROGRAM =
  (LIST STATEMENT) (MAYBE TYPE) EXP              #Notation: `main : TYPE; main = EXP`