# Semantic Domains

STATE_CONSTS ⊆ VAR_S × VALUE
STATE_TYPES ⊆ TYPE_S × TYPE


# Helper functions

vars ⊆ STATE_CONSTS x 𝒫(VALUE)
vars(sc) := { v:VALUE | ∃ x:STATE . (v,x) ∈ sc }

vars ⊆ STATE_TYPES x 𝒫(TYPE)
vars(st) := { v:TYPES | ∃ x:STATE . (v,x) ∈ st }


# denoational semantics for statements

[[Type n vs ss C]](sc,st) = v ⇐
  let st' := st ∪ (n,TypeVariable n vs ss)
  in
  [[TypeVariable n vs ss]]✔<{},types(st)>
  ∧ [[C,sc,st']] = v

[[Alias n ts tn C]](sc,st) = v ⇐
  let st' := st ∪ (n,tn)
  in
  [[tn]]✔<ts,types(st)>
  ∧ [[C,sc,st']] = v

[[Constant n t e C]](sc,st) = v ⇐           #unused constants will be elimiated
  let v' := [[e]](sc,st)                                      #during compilation
    , sc' := sc ∪ (n,v')
  in
  [[t]]✔<{},types(st)>
  ∧ n ∉ values(sc)                                    #variable name is not used
  ∧ [[C,sc',st]] = v

[[Main t e]](sc,st) = v ⇐
  [[e]](sc,st) = v


# denoational semantics for expressions

                              #requires pattern matching
--------------------------
Call EXP EXP

                              #requires pattern matching
----------------------- 
Case EXP (PATTERN EXP)*

                                              # Substitute Variables with Values
[[Value (Variable n)]](sc,st) = v ⇐
  if (n,BoolValue b) ∈ sc then
    v = BoolValue b
  else if (n,IntValue i) ∈ sc then
    v = IntValue i
  else if (n,ListValue e_1 .. e_k) ∈ sc then
    [[e_1]](sc,st) = v_1
    ∧ ..
    ∧ [[e_k]](sc,st) = v_k
    ∧ v = ListValue (Value v_1) .. (Value v_k)
  else if (n,TupleValue e_1 e_2) ∈ sc then
    [[e_1]](sc,st) = v_1
    ∧ [[e_2]](sc,st) = v_2
    ∧ v = TupleValue (Value e_1) (Value e_2)
  else if (n,RecordValue (f_1,e_1) .. (f_n,e_k)) ∈ sc then
    [[e_1]](sc,st) = v_1
    ∧ ..
    ∧ [[e_k]](sc,st) = v_k
    ∧ 

[[Value v]](sc,st) = v ⇐                                                  #else
                              #TODO: applying variables to values

[[LetIn n t e E]] = v ⇐
  let v' := (e,sc,st)
    , sc' := sc ∪ (n,v')
  in
  [[t]]✔<{},types(st)>
  ∧ n ∉ values(sc)
  ∧ [[E]](sc',st) = v

[[Get n f_i]](sc,st) = v_i ⇐
  (n,RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) ∈ sc

[[Set n f_i e]](sc,st) = RecordValue (f_1 v_1) .. (f_i v) .. (f_k v_k) ⇐
  (n,RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) ∈ sc
  ∧ [[e]](sc,st) = v

[[RecordConstructor (f_1 v_1) .. (f_i v_i) .. (f_k v_k)]](sc, st) =
  RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)

[[IfThenElse b e1 e2]](sc,st) = v ⇐
  let t := [[b]](s)
  in
  if t then
    v = [[e1]](sc,st)
  else
    v = [[e2]](sc,st)


# Builtin Lambda Functions

[[Constructor s]](sc, st) =                      #Every Sort of every CustomType
  LambdaValue (Single (Variable v_1))                         #has a Constructor
  ( ..
      LambdaValue (Single (Variable v_n))
        (Value (CustomValue s (Variable v_1) .. (Variable v_n)))
  ) ⇐
    ∃! (_,TypeVariable _ _ (s_1 _) .. (s _) .. (s_1 _) ∈ st         #Type exists

#Side note:
#There also exists a notion of modules, where each module has its own scope.
#Then each Sort needs to be unique to the module. Outside of the module the
#constructor can then be called by `Module.Name` where `Module` is the name of
#module and `name` is the name of the sort.
#
#Unless the abstract language will also include modules, the name of the sort
#needs to be unique.

[[Composition]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value LambdaValue (Single (Variable in))
        (Call (Variable v2) (Call (Variable v1) (Variable in)))
      )
    ))

[[Pipe]](sc,st) = 
  LambdaValue (Single (Variable v))
    (Value (LambdaValue (Single (Variable f))
      (Call (Variable f) (Variable v))
    ))

[[Or]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value (BoolValue (v1 ∨ v2))
    ))

[[And]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value (BoolValue (v1 ∧ v2))
    ))

[[Not]](sc,st) =
  LambdaValue (Single v1)
    (Value (BoolValue ¬v1)

[[Equal]](sc,st) =
  LambdaValue (Single v1)
    (Value (LambdaValue (Single v2)
      (Value (BoolValue (v1 = v2))
    ))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
e3 <=> a = b
------------------------------------------------------------------
(Equal, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
a < b
-----------------------------------------------------------------
(Less, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
∃d∈ℤ. d < b ∧ a = c*b + d
---------------------------------------------------------------
(Divide, sc, st) ->> LambdaValue e1 (LambdaValue e2 IntValue c)

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a ⋅ b
-------------------------------------------------------------------
(Multiply, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a - b
-------------------------------------------------------------------
(Subtract, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a + b
--------------------------------------------------------------
(Add, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->>  a_1
(e2, sc, st) ->> (ListValue a_2 .. a_k)
------------------------------------------------------------------------
Cons, sc, st) ->> LambdaValue e1 (LambdaValue e2 (ListValue a_1 .. a_k))


(l, sc, st) ->> (ListValue)
(i, sc, st) ->> o
-----------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))

(l, sc, st) ->> (ListValue h l_1 .. l_j)
(i, sc, st) ->> (ListValue o_1 .. o_k)
(Call (Call (LambdaValue (LambdaValue a (LambdaValue b1 b2))) h) (ListValue o_1 .. o_k), sc ,st) ->> h'
(Call (Call (Call Foldl (LambdaValue (LambdaValue a (LambdaValue b1 b2)))) (ListValue h' o_1' .. o_k')) (ListValue l_1 .. l_j),sc ,st) -> o
------------------------------------------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))