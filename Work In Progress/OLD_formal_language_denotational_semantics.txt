# Semantic Domains

STATE_CONSTS âŠ† VAR_S Ã— VALUE
STATE_TYPES âŠ† TYPE_S Ã— TYPE


# Helper functions

vars âŠ† STATE_CONSTS x ğ’«(VALUE)
vars(sc) := { v:VALUE | âˆƒ x:STATE . (v,x) âˆˆ sc }

vars âŠ† STATE_TYPES x ğ’«(TYPE)
vars(st) := { v:TYPES | âˆƒ x:STATE . (v,x) âˆˆ st }


# denoational semantics for statements

[[Type n vs ss C]](sc,st) = v â‡
  let st' := st âˆª (n,TypeVariable n vs ss)
  in
  [[TypeVariable n vs ss]]âœ”<{},types(st)>
  âˆ§ [[C,sc,st']] = v

[[Alias n ts tn C]](sc,st) = v â‡
  let st' := st âˆª (n,tn)
  in
  [[tn]]âœ”<ts,types(st)>
  âˆ§ [[C,sc,st']] = v

[[Constant n t e C]](sc,st) = v â‡           #unused constants will be elimiated
  let v' := [[e]](sc,st)                                      #during compilation
    , sc' := sc âˆª (n,v')
  in
  [[t]]âœ”<{},types(st)>
  âˆ§ n âˆ‰ values(sc)                                    #variable name is not used
  âˆ§ [[C,sc',st]] = v

[[Main t e]](sc,st) = v â‡
  [[e]](sc,st) = v


# denoational semantics for expressions

                              #requires pattern matching
--------------------------
Call EXP EXP

                              #requires pattern matching
----------------------- 
Case EXP (PATTERN EXP)*

                                              # Substitute Variables with Values
[[Value (Variable n)]](sc,st) = v â‡
  if (n,BoolValue b) âˆˆ sc then
    v = BoolValue b
  else if (n,IntValue i) âˆˆ sc then
    v = IntValue i
  else if (n,ListValue e_1 .. e_k) âˆˆ sc then
    [[e_1]](sc,st) = v_1
    âˆ§ ..
    âˆ§ [[e_k]](sc,st) = v_k
    âˆ§ v = ListValue (Value v_1) .. (Value v_k)
  else if (n,TupleValue e_1 e_2) âˆˆ sc then
    [[e_1]](sc,st) = v_1
    âˆ§ [[e_2]](sc,st) = v_2
    âˆ§ v = TupleValue (Value e_1) (Value e_2)
  else if (n,RecordValue (f_1,e_1) .. (f_n,e_k)) âˆˆ sc then
    [[e_1]](sc,st) = v_1
    âˆ§ ..
    âˆ§ [[e_k]](sc,st) = v_k
    âˆ§ 

[[Value v]](sc,st) = v â‡                                                  #else
                              #TODO: applying variables to values

[[LetIn n t e E]] = v â‡
  let v' := (e,sc,st)
    , sc' := sc âˆª (n,v')
  in
  [[t]]âœ”<{},types(st)>
  âˆ§ n âˆ‰ values(sc)
  âˆ§ [[E]](sc',st) = v

[[Get n f_i]](sc,st) = v_i â‡
  (n,RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) âˆˆ sc

[[Set n f_i e]](sc,st) = RecordValue (f_1 v_1) .. (f_i v) .. (f_k v_k) â‡
  (n,RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)) âˆˆ sc
  âˆ§ [[e]](sc,st) = v

[[RecordConstructor (f_1 v_1) .. (f_i v_i) .. (f_k v_k)]](sc, st) =
  RecordValue (f_1 v_1) .. (f_i v_i) .. (f_k v_k)

[[IfThenElse b e1 e2]](sc,st) = v â‡
  let t := [[b]](s)
  in
  if t then
    v = [[e1]](sc,st)
  else
    v = [[e2]](sc,st)


# Builtin Lambda Functions

[[Constructor s]](sc, st) =                      #Every Sort of every CustomType
  LambdaValue (Single (Variable v_1))                         #has a Constructor
  ( ..
      LambdaValue (Single (Variable v_n))
        (Value (CustomValue s (Variable v_1) .. (Variable v_n)))
  ) â‡
    âˆƒ! (_,TypeVariable _ _ (s_1 _) .. (s _) .. (s_1 _) âˆˆ st         #Type exists

#Side note:
#There also exists a notion of modules, where each module has its own scope.
#Then each Sort needs to be unique to the module. Outside of the module the
#constructor can then be called by `Module.Name` where `Module` is the name of
#module and `name` is the name of the sort.
#
#Unless the abstract language will also include modules, the name of the sort
#needs to be unique.

[[Composition]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value LambdaValue (Single (Variable in))
        (Call (Variable v2) (Call (Variable v1) (Variable in)))
      )
    ))

[[Pipe]](sc,st) = 
  LambdaValue (Single (Variable v))
    (Value (LambdaValue (Single (Variable f))
      (Call (Variable f) (Variable v))
    ))

[[Or]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value (BoolValue (v1 âˆ¨ v2))
    ))

[[And]](sc,st) =
  LambdaValue (Single (Variable v1))
    (Value (LambdaValue (Single (Variable v2))
      (Value (BoolValue (v1 âˆ§ v2))
    ))

[[Not]](sc,st) =
  LambdaValue (Single v1)
    (Value (BoolValue Â¬v1)

[[Equal]](sc,st) =
  LambdaValue (Single v1)
    (Value (LambdaValue (Single v2)
      (Value (BoolValue (v1 = v2))
    ))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
e3 <=> a = b
------------------------------------------------------------------
(Equal, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
a < b
-----------------------------------------------------------------
(Less, sc, st) ->> LambdaValue e1 (LambdaValue e2 (BoolValue b3))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
âˆƒdâˆˆâ„¤. d < b âˆ§ a = c*b + d
---------------------------------------------------------------
(Divide, sc, st) ->> LambdaValue e1 (LambdaValue e2 IntValue c)

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a â‹… b
-------------------------------------------------------------------
(Multiply, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a - b
-------------------------------------------------------------------
(Subtract, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->> IntValue a
(e2, sc, st) ->> IntValue b
c = a + b
--------------------------------------------------------------
(Add, sc, st) ->> LambdaValue e1 (LambdaValue e2 (IntValue c))

(e1, sc, st) ->>  a_1
(e2, sc, st) ->> (ListValue a_2 .. a_k)
------------------------------------------------------------------------
Cons, sc, st) ->> LambdaValue e1 (LambdaValue e2 (ListValue a_1 .. a_k))


(l, sc, st) ->> (ListValue)
(i, sc, st) ->> o
-----------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))

(l, sc, st) ->> (ListValue h l_1 .. l_j)
(i, sc, st) ->> (ListValue o_1 .. o_k)
(Call (Call (LambdaValue (LambdaValue a (LambdaValue b1 b2))) h) (ListValue o_1 .. o_k), sc ,st) ->> h'
(Call (Call (Call Foldl (LambdaValue (LambdaValue a (LambdaValue b1 b2)))) (ListValue h' o_1' .. o_k')) (ListValue l_1 .. l_j),sc ,st) -> o
------------------------------------------------------------------------------------------------------------------------------------
(Foldl, sc, st) ->> LambdaValue (LambdaValue a (LambdaValue b1 b2)) (LambdaValue i (LambdaValue l o))